{
  "version": "0.1.0",
  "types": {
    "peripherals": {
      "A1_Regs": {
        "description": "Selects source APB Master to SPI Master between M4/AP and Fabric",
        "children": {
          "registers": {
            "CFG_CTRL": {
              "description": "Configuration Control",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "CFG_IN_SEL": {
                    "description": "Selects source APB master to SPI Master between M4/AP and Fabric",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            }
          }
        }
      },
      "IOMUX": {
        "description": "IO Multiplexing Control",
        "children": {
          "registers": {
            "PAD_CTRL": {
              "description": "PAD_[%s] control register",
              "offset": 0,
              "size": 32,
              "count": 46,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FUNC_SEL": {
                    "description": "Functional selection for IO output. Refer to IO Mux",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.FUNC_SEL_ENUM"
                  },
                  "CTRL_SEL": {
                    "description": "Control selection for IO Output. 0x0 = A0 registers, 0x1 = Others, 0x2 = Fabric",
                    "offset": 3,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.CTRL_SEL_ENUM"
                  },
                  "OEN": {
                    "description": "Active low output enable",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.OEN_ENUM"
                  },
                  "P": {
                    "description": "Driver state control",
                    "offset": 6,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.P_ENUM"
                  },
                  "E": {
                    "description": "Driver Strength",
                    "offset": 8,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.DriverStrength"
                  },
                  "SR": {
                    "description": "Slew Rate",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SlewRate"
                  },
                  "REN": {
                    "description": "Receive Enable",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.REN"
                  },
                  "SMT": {
                    "description": "Schmitt Trigger",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SMT_ENUM"
                  }
                }
              }
            },
            "SDA0_SEL_REG": {
              "description": "Select pad for SDA function in I2C0 (only pad 1 is selectable)",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SDA0_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SDA1_SEL_REG": {
              "description": "Select pad for SDA function in I2C1 (3 pads available)",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.SDA1_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SDA2_SEL_REG": {
              "description": "Select pad for SDA function in I2C2 (only pad 41 is selectable)",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SDA2_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SCL0_SEL_REG": {
              "description": "Select pad for SCL function in I2C0 (only pad 0 is selectable)",
              "offset": 268,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SCL0_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SCL1_SEL_REG": {
              "description": "Select pad for SCL function in I2C1 (3 pads available)",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.SCL1_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SCL2_SEL_REG": {
              "description": "Select pad for SCL function in I2C2 (only pad 40 is selectable)",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SCL2_SEL_REG_ENUM"
                  }
                }
              }
            },
            "SPIs_CLK_SEL": {
              "description": "Select pad for SPI CLK function (only pad 16 is selectable)",
              "offset": 280,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SPIs_SSn_SEL": {
              "description": "Select pad for SPI SS function (only pad 20 is selectable)",
              "offset": 284,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SPIs_MOSI_SEL": {
              "description": "Select pad for SPI MOSI function (only pad 19 is selectable)",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SPIs_MISO_SEL": {
              "description": "Select pad for SPI MISO function (only pad 36 is selectable)",
              "offset": 292,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PDM_DATA_SELE": {
              "description": "Select pad for PDM microphone data line",
              "offset": 296,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.PDM_DATA_SELE_ENUM"
                  }
                }
              }
            },
            "I2S_DATA_SELECT": {
              "description": "Select pad for the I2S Serial Data (SD)",
              "offset": 300,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.I2S_DATA_SELECT_ENUM"
                  }
                }
              }
            },
            "UART_rxd_SEL": {
              "description": "a",
              "offset": 308,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.UART_rxd_SEL_ENUM"
                  }
                }
              }
            },
            "IrDA_Sirin_SEL": {
              "description": "Select pad for SIREN in function",
              "offset": 312,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.IrDA_Sirin_SEL_ENUM"
                  }
                }
              }
            },
            "S_INTR_0_SEL_REG": {
              "description": "Select pad that triggers GPIO interrupt 0",
              "offset": 316,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_0_SEL_REG_ENUM"
                  }
                }
              }
            },
            "S_INTR_1_SEL_REG": {
              "description": "Select pad that triggers GPIO interrupt 1",
              "offset": 320,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_1_SEL_REG_ENUM"
                  }
                }
              }
            },
            "S_INTR_2_SEL": {
              "description": "Select pad that triggers GPIO interrupt 2",
              "offset": 324,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_2_SEL_ENUM"
                  }
                }
              }
            },
            "S_INTR_3_SEL": {
              "description": "Select pad that triggers GPIO interrupt 3",
              "offset": 328,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_3_SEL_ENUM"
                  }
                }
              }
            },
            "S_INTR_4_SEL": {
              "description": "Select pad that triggers GPIO interrupt 4",
              "offset": 332,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_4_SEL_ENUM"
                  }
                }
              }
            },
            "S_INTR_5_SEL": {
              "description": "Select pad that triggers GPIO interrupt 5",
              "offset": 336,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_5_SEL_ENUM"
                  }
                }
              }
            },
            "S_INTR_6_SEL": {
              "description": "Select pad that triggers GPIO interrupt 6",
              "offset": 340,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.SEL"
                  }
                }
              }
            },
            "S_INTR_7_SEL": {
              "description": "Select pad that triggers GPIO interrupt 7",
              "offset": 344,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.IOMUX.children.enums.S_INTR_7_SEL_ENUM"
                  }
                }
              }
            },
            "NUARTCTS_SEL": {
              "description": "Pad Selection for the CTS nUART function",
              "offset": 348,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2
                  }
                }
              }
            },
            "IO_REG_SEL": {
              "description": "Selects which IO input will be registered (Pads used as GPIOS)",
              "offset": 352,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "IO_SEL_0": {
                    "description": "Select pad for IO maped to bit 0",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_0"
                  },
                  "IO_SEL_1": {
                    "description": "Select pad for IO maped to bit 1",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_1"
                  },
                  "IO_SEL_2": {
                    "description": "Select pad for IO maped to bit 2",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_2"
                  },
                  "IO_SEL_3": {
                    "description": "Select pad for IO maped to bit 3",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_3"
                  },
                  "IO_SEL_4": {
                    "description": "Select pad for IO maped to bit 4",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_4"
                  },
                  "IO_SEL_5": {
                    "description": "Select pad for IO maped to bit 5",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_5"
                  },
                  "IO_SEL_6": {
                    "description": "Select pad for IO maped to bit 6",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_6"
                  },
                  "IO_SEL_7": {
                    "description": "Select pad for IO maped to bit 7",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.IO_SEL_7"
                  }
                }
              }
            },
            "SW_CLK_SEL": {
              "description": "Selection for SWD clock pad (SCK)",
              "offset": 368,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SW_CLK_SEL_ENUM"
                  }
                }
              }
            },
            "SW_IO_SEL": {
              "description": "Selection for SWD IO pad (SDIO)",
              "offset": 372,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.IOMUX.children.enums.SW_IO_SEL_ENUM"
                  }
                }
              }
            },
            "FBIO_SEL_1": {
              "description": "Lacking proper documentation. Configuration of pins 0-31 related to Fabric",
              "offset": 384,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 32,
                    "enum": "types.peripherals.IOMUX.children.enums.FBIO_SEL_1_ENUM"
                  }
                }
              }
            },
            "FBIO_SEL_2": {
              "description": "Lacking proper documentation. Configuration of pins 32-45 related to Fabric",
              "offset": 388,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16383,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 14,
                    "enum": "types.peripherals.IOMUX.children.enums.FBIO_SEL_2_ENUM"
                  }
                }
              }
            },
            "SPI_SENSOR_MISO_SEL": {
              "description": "Selects pad for MISO function for the sensor SPI",
              "offset": 400,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.SPI_SENSOR_MISO_SEL_ENUM"
                  }
                }
              }
            },
            "SPI_SENSOR_MOSI_SEL": {
              "description": "Selects pad for MOSI function for the sensor SPI",
              "offset": 404,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.IOMUX.children.enums.SPI_SENSOR_MOSI_SEL_ENUM"
                  }
                }
              }
            },
            "I2S_WD_CLKIN_SEL": {
              "description": "Selects pad for the I2S Data-Word Select (WS)",
              "offset": 416,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "I2S_CLKIN_SEL": {
              "description": "Selects pad for I2S clock (SCK)",
              "offset": 420,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PDM_STAT_IN_SEL": {
              "description": "Selects pin for PDM STATUS_IN function",
              "offset": 424,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 2
                  }
                }
              }
            },
            "PDM_CLKIN_SEL": {
              "description": "Selects pin for PDM CLKIN source (AP PDM CKO IN)",
              "offset": 428,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SEL": {
                    "description": "Sel",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            }
          },
          "enums": {
            "FUNC_SEL_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "alternative_0": {
                    "description": "Select alternative function 0",
                    "value": 0
                  },
                  "alternative_1": {
                    "description": "Select alternative function 1",
                    "value": 1
                  },
                  "alternative_2": {
                    "description": "Select alternative function 2",
                    "value": 2
                  },
                  "alternative_3": {
                    "description": "Select alternative function 3",
                    "value": 3
                  }
                }
              }
            },
            "CTRL_SEL_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "a0_registers": {
                    "description": "A0 registers",
                    "value": 0
                  },
                  "others": {
                    "description": "Others",
                    "value": 1
                  },
                  "fabric": {
                    "description": "Fabric",
                    "value": 2
                  }
                }
              }
            },
            "OEN_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "normal_operation": {
                    "description": "normal operation",
                    "value": 0
                  },
                  "driver_disabled": {
                    "description": "driver disabled",
                    "value": 1
                  }
                }
              }
            },
            "P_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "z": {
                    "description": "floating, high impedance",
                    "value": 0
                  },
                  "pull_up": {
                    "description": "pull-up mode",
                    "value": 1
                  },
                  "pull_down": {
                    "description": "pull-down mode",
                    "value": 2
                  },
                  "keeper": {
                    "description": "bus keeper mode",
                    "value": 3
                  }
                }
              }
            },
            "DriverStrength": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "current_2ma": {
                    "description": "Configures the drive current at 2mA",
                    "value": 0
                  },
                  "current_4ma": {
                    "description": "Configures the drive current at 4mA",
                    "value": 1
                  },
                  "current_8ma": {
                    "description": "Configures the drive current at 8mA",
                    "value": 2
                  },
                  "current_12ma": {
                    "description": "Configures the drive current at 12mA",
                    "value": 3
                  }
                }
              }
            },
            "SlewRate": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "slow": {
                    "description": "slow (half frequency) slew rate",
                    "value": 0
                  },
                  "fast": {
                    "description": "fast slew rate",
                    "value": 1
                  }
                }
              }
            },
            "REN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_receive": {
                    "description": "disable receive",
                    "value": 0
                  },
                  "enable_receive": {
                    "description": "enable receive",
                    "value": 1
                  }
                }
              }
            },
            "SMT_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_trigger": {
                    "description": "Disable the Schmitt trigger",
                    "value": 0
                  },
                  "enable_trigger": {
                    "description": "Enable the Schmitt trigger",
                    "value": 1
                  }
                }
              }
            },
            "SDA0_SEL_REG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Selects pad #1 for the SDA function in I2C0",
                    "value": 0
                  },
                  "pad_01": {
                    "description": "Selects pad #1 for the SDA function in I2C0",
                    "value": 1
                  }
                }
              }
            },
            "SDA1_SEL_REG_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Select pad #15 for the SDA function in I2C1",
                    "value": 0
                  },
                  "pad_15": {
                    "description": "Select pad #15 for the SDA function in I2C1",
                    "value": 1
                  },
                  "pad_32": {
                    "description": "Select pad #32 for the SDA function in I2C1",
                    "value": 2
                  },
                  "pad_44": {
                    "description": "Select pad #44 for the SDA function in I2C1",
                    "value": 3
                  }
                }
              }
            },
            "SDA2_SEL_REG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Selects pad #41 for the SDA function in I2C2",
                    "value": 0
                  },
                  "pad_41": {
                    "description": "Selects pad #41 for the SDA function in I2C2",
                    "value": 1
                  }
                }
              }
            },
            "SCL0_SEL_REG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Selects pad #0 for the SCL function in I2C0",
                    "value": 0
                  },
                  "pad_00": {
                    "description": "Selects pad #0 for the SCL function in I2C0",
                    "value": 1
                  }
                }
              }
            },
            "SCL1_SEL_REG_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Select pad #14 for the SCL function in I2C1",
                    "value": 0
                  },
                  "pad_14": {
                    "description": "Select pad #14 for the SCL function in I2C1",
                    "value": 1
                  },
                  "pad_33": {
                    "description": "Select pad #33 for the SCL function in I2C1",
                    "value": 2
                  },
                  "pad_45": {
                    "description": "Select pad #45 for the SCL function in I2C1",
                    "value": 3
                  }
                }
              }
            },
            "SCL2_SEL_REG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "default_undefined": {
                    "description": "Documentation lacking, guessed meaning: Selects pad #40 for the SCL function in I2C2",
                    "value": 0
                  },
                  "pad_40": {
                    "description": "Selects pad #40 for the SCL function in I2C2",
                    "value": 1
                  }
                }
              }
            },
            "PDM_DATA_SELE_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_10": {
                    "description": "Selects pad #10 for PDM data line",
                    "value": 1
                  },
                  "pad_28": {
                    "description": "Selects pad #28 for PDM data line",
                    "value": 2
                  }
                }
              }
            },
            "I2S_DATA_SELECT_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_10": {
                    "description": "Selects pad #10 for I2S data line",
                    "value": 1
                  },
                  "pad_28": {
                    "description": "Selects pad #28 for I2S data line",
                    "value": 2
                  }
                }
              }
            },
            "UART_rxd_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_14": {
                    "description": "Selects pad #14 for UART RXD line",
                    "value": 1
                  },
                  "pad_16": {
                    "description": "Selects pad #16 for UART RXD line",
                    "value": 2
                  },
                  "pad_25": {
                    "description": "Selects pad #25 for UART RXD line",
                    "value": 3
                  },
                  "pad_45": {
                    "description": "Selects pad #45 for UART RXD line",
                    "value": 4
                  }
                }
              }
            },
            "IrDA_Sirin_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_06": {
                    "description": "Selects pad #14 for Siren in line",
                    "value": 1
                  },
                  "pad_15": {
                    "description": "Selects pad #15 for Siren in line",
                    "value": 2
                  },
                  "pad_21": {
                    "description": "Selects pad #21 for Siren in line",
                    "value": 3
                  },
                  "pad_24": {
                    "description": "Selects pad #24 for Siren in line",
                    "value": 4
                  },
                  "pad_28": {
                    "description": "Selects pad #28 for Siren in line",
                    "value": 5
                  },
                  "pad_40": {
                    "description": "Selects pad #40 for Siren in line",
                    "value": 6
                  },
                  "pad_44": {
                    "description": "Selects pad #44 for Siren in line",
                    "value": 7
                  }
                }
              }
            },
            "S_INTR_0_SEL_REG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_03": {
                    "description": "Selects pad #3 as the trigger",
                    "value": 1
                  }
                }
              }
            },
            "S_INTR_1_SEL_REG_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_02": {
                    "description": "Selects pad #2 as the trigger",
                    "value": 1
                  },
                  "pad_06": {
                    "description": "Selects pad #6 as the trigger",
                    "value": 2
                  },
                  "pad_18": {
                    "description": "Selects pad #18 as the trigger",
                    "value": 3
                  },
                  "pad_24": {
                    "description": "Selects pad #24 as the trigger",
                    "value": 4
                  },
                  "pad_35": {
                    "description": "Selects pad #35 as the trigger",
                    "value": 5
                  },
                  "pad_36": {
                    "description": "Selects pad #36 as the trigger",
                    "value": 6
                  }
                }
              }
            },
            "S_INTR_2_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_04": {
                    "description": "Selects pad #4 as the trigger",
                    "value": 1
                  },
                  "pad_08": {
                    "description": "Selects pad #8 as the trigger",
                    "value": 2
                  },
                  "pad_21": {
                    "description": "Selects pad #21 as the trigger",
                    "value": 3
                  },
                  "pad_25": {
                    "description": "Selects pad #25 as the trigger",
                    "value": 4
                  },
                  "pad_37": {
                    "description": "Selects pad #37 as the trigger",
                    "value": 5
                  },
                  "pad_38": {
                    "description": "Selects pad #38 as the trigger",
                    "value": 6
                  }
                }
              }
            },
            "S_INTR_3_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_05": {
                    "description": "Selects pad #2 as the trigger",
                    "value": 1
                  },
                  "pad_09": {
                    "description": "Selects pad #9 as the trigger",
                    "value": 2
                  },
                  "pad_22": {
                    "description": "Selects pad #22 as the trigger",
                    "value": 3
                  },
                  "pad_28": {
                    "description": "Selects pad #28 as the trigger",
                    "value": 4
                  },
                  "pad_39": {
                    "description": "Selects pad #39 as the trigger",
                    "value": 5
                  },
                  "pad_40": {
                    "description": "Selects pad #40 as the trigger",
                    "value": 6
                  }
                }
              }
            },
            "S_INTR_4_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_07": {
                    "description": "Selects pad #7 as the trigger",
                    "value": 1
                  },
                  "pad_10": {
                    "description": "Selects pad #10 as the trigger",
                    "value": 2
                  },
                  "pad_26": {
                    "description": "Selects pad #26 as the trigger",
                    "value": 3
                  },
                  "pad_29": {
                    "description": "Selects pad #29 as the trigger",
                    "value": 4
                  },
                  "pad_44": {
                    "description": "Selects pad #44 as the trigger",
                    "value": 5
                  }
                }
              }
            },
            "S_INTR_5_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_11": {
                    "description": "Selects pad #11 as the trigger",
                    "value": 1
                  },
                  "pad_14": {
                    "description": "Selects pad #14 as the trigger",
                    "value": 2
                  },
                  "pad_27": {
                    "description": "Selects pad #27 as the trigger",
                    "value": 3
                  },
                  "pad_30": {
                    "description": "Selects pad #30 as the trigger",
                    "value": 4
                  },
                  "pad_45": {
                    "description": "Selects pad #45 as the trigger",
                    "value": 5
                  }
                }
              }
            },
            "SEL": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_12": {
                    "description": "Selects pad #12 as the trigger",
                    "value": 1
                  },
                  "pad_15": {
                    "description": "Selects pad #15 as the trigger",
                    "value": 2
                  },
                  "pad_31": {
                    "description": "Selects pad #31 as the trigger",
                    "value": 3
                  },
                  "pad_32": {
                    "description": "Selects pad #32 as the trigger",
                    "value": 4
                  },
                  "pad_41": {
                    "description": "Selects pad #41 as the trigger",
                    "value": 5
                  }
                }
              }
            },
            "S_INTR_7_SEL_ENUM": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_13": {
                    "description": "Selects pad #13 as the trigger",
                    "value": 1
                  },
                  "pad_23": {
                    "description": "Selects pad #23 as the trigger",
                    "value": 2
                  },
                  "pad_33": {
                    "description": "Selects pad #33 as the trigger",
                    "value": 3
                  },
                  "pad_34": {
                    "description": "Selects pad #34 as the trigger",
                    "value": 4
                  },
                  "pad_42": {
                    "description": "Selects pad #42 as the trigger",
                    "value": 5
                  }
                }
              }
            },
            "IO_SEL_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_06": {
                    "description": "Enable pad #6 as GPIO",
                    "value": 0
                  },
                  "pad_24": {
                    "description": "Enable pad #24 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_1": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_09": {
                    "description": "Enable pad #9 as GPIO",
                    "value": 0
                  },
                  "pad_26": {
                    "description": "Enable pad #26 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_2": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_11": {
                    "description": "Enable pad #11 as GPIO",
                    "value": 0
                  },
                  "pad_28": {
                    "description": "Enable pad #28 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_3": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_14": {
                    "description": "Enable pad #14 as GPIO",
                    "value": 0
                  },
                  "pad_30": {
                    "description": "Enable pad #30 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_18": {
                    "description": "Enable pad #18 as GPIO",
                    "value": 0
                  },
                  "pad_31": {
                    "description": "Enable pad #31 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_5": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_21": {
                    "description": "Enable pad #21 as GPIO",
                    "value": 0
                  },
                  "pad_26": {
                    "description": "Enable pad #26 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_6": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_22": {
                    "description": "Enable pad #22 as GPIO",
                    "value": 0
                  },
                  "pad_38": {
                    "description": "Enable pad #38 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "IO_SEL_7": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pad_23": {
                    "description": "Enable pad #23 as GPIO",
                    "value": 0
                  },
                  "pad_45": {
                    "description": "Enable pad #45 as GPIO",
                    "value": 1
                  }
                }
              }
            },
            "SW_CLK_SEL_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "select_strap_pad_14_45": {
                    "description": "pad #14/#45 (pad selection will depend on pad #8, See ch. 30 of TechRef Manual)",
                    "value": 0
                  },
                  "undefined": {
                    "description": "Lacking documentation. Might mean the same as `select_strap_pad`",
                    "value": 1
                  }
                }
              }
            },
            "SW_IO_SEL_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "select_strap_pad_15_44": {
                    "description": "pad #15/#44 (pad selection will depend on pad #8, See ch. 30 of TechRef Manual)",
                    "value": 0
                  },
                  "undefined": {
                    "description": "Lacking documentation. Might mean the same as `select_strap_pad`",
                    "value": 1
                  }
                }
              }
            },
            "FBIO_SEL_1_ENUM": {
              "size": 32,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "Lacking documentation. Guess: Leaves pad unselected",
                    "value": 0
                  },
                  "select_pad": {
                    "description": "Lacking documentation. Guess: Activates some sort of FPGA Fabric control for pads 0-31",
                    "value": 1
                  }
                }
              }
            },
            "FBIO_SEL_2_ENUM": {
              "size": 14,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "Lacking documentation. Guess: Leaves pad unselected",
                    "value": 0
                  },
                  "select_pad": {
                    "description": "Lacking documentation. Guess: Activates some sort of FPGA Fabric control for pads 32-45",
                    "value": 1
                  }
                }
              }
            },
            "SPI_SENSOR_MISO_SEL_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_08": {
                    "description": "Selects pad #8 for sensor SPI MISO",
                    "value": 1
                  },
                  "pad_29": {
                    "description": "Selects pad #29 for sensor SPI MISO",
                    "value": 2
                  }
                }
              }
            },
            "SPI_SENSOR_MOSI_SEL_ENUM": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "undefined": {
                    "description": "undefined (0:0 in documentation)",
                    "value": 0
                  },
                  "pad_06": {
                    "description": "Selects pad #6 for sensor SPI MISO",
                    "value": 1
                  },
                  "pad_28": {
                    "description": "Selects pad #28 for sensor SPI MISO",
                    "value": 2
                  }
                }
              }
            }
          }
        }
      },
      "ADC": {
        "description": "Analog-to-Digital Converter",
        "children": {
          "registers": {
            "ADC_OUT": {
              "description": "Last sampled value",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "OUT": {
                    "description": "Stored last sampled value",
                    "offset": 0,
                    "size": 12
                  }
                }
              }
            },
            "ADC_Status": {
              "description": "Status",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "EOC": {
                    "description": "End of Conversion. Rises when data is valid",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.ADC.children.enums.EOC"
                  }
                }
              }
            },
            "ADC_Control": {
              "description": "Control register",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SOC": {
                    "description": "Asynchronous start-of-conversion. Needs to rise and be held high for each conversion",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.ADC.children.enums.SOC"
                  },
                  "SEL": {
                    "description": "Channel Selection. 0 = CH0, 1 = CH1",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.ADC.children.enums.ADC_Control_SEL_ENUM"
                  },
                  "BAT": {
                    "description": "Battery measurement enable",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.ADC.children.enums.BAT"
                  }
                }
              }
            }
          },
          "enums": {
            "EOC": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "non_valid": {
                    "description": "data in OUT field is not valid",
                    "value": 0
                  },
                  "valid": {
                    "description": "data in OUT field is valid",
                    "value": 1
                  }
                }
              }
            },
            "SOC": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "stop": {
                    "description": "Stop conversion",
                    "value": 0
                  },
                  "start": {
                    "description": "Start conversion. Needs to be held high until EOC is valid",
                    "value": 1
                  }
                }
              }
            },
            "ADC_Control_SEL_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "select_ch0": {
                    "description": "Select channel 0",
                    "value": 0
                  },
                  "select_ch1": {
                    "description": "Select channel 1",
                    "value": 1
                  }
                }
              }
            },
            "BAT": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Disables battery measurement",
                    "value": 0
                  },
                  "enable": {
                    "description": "Enables battery measurement",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "AIP": {
        "description": "Analog IP block",
        "children": {
          "registers": {
            "RTC_CTRL_1": {
              "description": "RTC control register 1",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "clkdiv": {
                    "description": "5'b00000 : 32.768 Khz Please refer to the Technical Reference Manual for others (No SYNC Needed)",
                    "offset": 0,
                    "size": 5
                  }
                }
              }
            },
            "RTC_CTRL_2": {
              "description": "RTC control register 2",
              "offset": 8,
              "size": 32,
              "reset_value": 1,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "clke": {
                    "description": "1'b1 RTC Clock Output Enable (No SYNC Needed)",
                    "offset": 0,
                    "size": 1
                  },
                  "byp16k": {
                    "description": "Changes internal clock division for 16384 Hz bypass compatibility -- 1'b0 : xtal is 32KHz - 1'b1 : xtal is 16KHz",
                    "offset": 1,
                    "size": 1
                  },
                  "test_ctrl": {
                    "description": "RTC Test[4:3] control for rtc bypass mode -- 0: Test[4:3] will be forced to 2'b11 when pad8 is strapped to 1, and forced to 2'b00 when pad8 is strapped to 0 , 1: normal mode; Test[4:0] controlled from 0x1C",
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "RTC_CTRL_3": {
              "description": "RTC control register 3",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ce": {
                    "description": "3'b000 Normal Function. Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 3
                  }
                }
              }
            },
            "RTC_CTRL_4": {
              "description": "RTC Control register 4",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "wr": {
                    "description": "Write Pulse to program the RTC internal Register. Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "RTC_CTRL_5": {
              "description": "RTC control register 5",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "c": {
                    "description": "Serial Input clock",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "RTC_CTRL_6": {
              "description": "RTC control register 6",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "PI": {
                    "description": "Parallel Input data. Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RTC_CTRL_7": {
              "description": "RTC control register 7 ",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "Test": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 5
                  }
                }
              }
            },
            "RTC_STA_0": {
              "description": "Incomplete information. Probably related to AIP RTC hardware status",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "alarm": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 0,
                    "size": 1
                  },
                  "testreq": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 1,
                    "size": 1
                  },
                  "digtestbus": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 2,
                    "size": 1
                  },
                  "oscok": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "RTC_STA_1": {
              "description": "Incomplete information. Probably related to AIP RTC hardware status",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PO": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "OSC_CTRL_0": {
              "description": "Oscilator control register 0",
              "offset": 128,
              "size": 32,
              "reset_value": 1,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "en": {
                    "description": "1'b0 : OSC OFF  -- 1'b1 : OSC ON , (NO SYNC needed, OSC guarantee there is no Glitch)",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.AIP.children.enums.en"
                  },
                  "fref16k_sel": {
                    "description": "Reference clock selection",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.AIP.children.enums.fref16k_sel"
                  }
                }
              }
            },
            "OSC_CTRL_1": {
              "description": "Oscilator control register 1",
              "offset": 132,
              "size": 32,
              "reset_value": 2349,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "prog": {
                    "description": "Please refer to the Technical Reference Manual for others (No SYNC Needed). Power On Default Value is 76.97 MHz. No Support on 'Delta Mode'.",
                    "offset": 0,
                    "size": 13
                  },
                  "General_Purpos_SFR": {
                    "description": "No description given",
                    "offset": 13,
                    "size": 3
                  }
                }
              }
            },
            "OSC_CTRL_2": {
              "description": "Oscilator control register 2",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "delta": {
                    "description": "Write 1, trigger delta mode, Note : This feature is NOT going to support, Keep it Low",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "OSC_CTRL_3": {
              "description": "Oscilator control register 3",
              "offset": 140,
              "size": 32,
              "reset_value": 8,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "refok": {
                    "description": "If 1'b1, will force the refok pin to 1, otherwise, it is control by the RTC/oscok",
                    "offset": 0,
                    "size": 1
                  },
                  "enmon": {
                    "description": "Turn on Monitor function by default",
                    "offset": 3,
                    "size": 1
                  },
                  "General_Purpos_SFR": {
                    "description": "No description given",
                    "offset": 4,
                    "size": 4
                  }
                }
              }
            },
            "OSC_CTRL_4": {
              "description": "Oscilator control register 4",
              "offset": 144,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "Test": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 3
                  },
                  "ce": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 3,
                    "size": 2
                  },
                  "wr": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "OSC_CTRL_5": {
              "description": "Oscilator control register 5",
              "offset": 148,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "sdi": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "OSC_CTRL_6": {
              "description": "Oscilator control register 6",
              "offset": 152,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "sck": {
                    "description": "Please refer to the Technical Reference Manual for detail",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "OSC_CTRL_7": {
              "description": "Oscilator control register 7",
              "offset": 156,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295
            },
            "OSC_STA_0": {
              "description": "Contains information about oscilator status",
              "offset": 160,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "lock": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 0,
                    "size": 1
                  },
                  "anatestreq_": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 1,
                    "size": 1
                  }
                }
              }
            },
            "OSC_STA_1": {
              "description": "Contains information about oscilator status",
              "offset": 164,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "sdo": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "APC_CTRL_0": {
              "description": "APC control register 0",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "dis": {
                    "description": "1'b0 : APC ON, Always ON",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "APC_CTRL_1": {
              "description": "APC control register 1",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "tt": {
                    "description": "Please refer to the Technical Reference Manual for others (No SYNC Needed)",
                    "offset": 0,
                    "size": 3
                  },
                  "vt": {
                    "description": "Please refer to the Technical Reference Manual for others (No SYNC Needed)",
                    "offset": 3,
                    "size": 5
                  }
                }
              }
            },
            "APC_CTRL_2": {
              "description": "APC control register 2",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "it": {
                    "description": "Please refer to the Technical Reference Manual for others (No SYNC Needed)",
                    "offset": 0,
                    "size": 3
                  },
                  "Test": {
                    "description": "Please refer to the Technical Reference Manual for others (No SYNC Needed)",
                    "offset": 3,
                    "size": 4
                  }
                }
              }
            },
            "APC_CTRL_3": {
              "description": "APC control register 3 // Reserved",
              "offset": 268,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "APC_CTRL_4": {
              "description": "APC control register 4 // Reserved",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "APC_CTRL_5": {
              "description": "APC control register 5 // Reserved",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "APC_CTRL_6": {
              "description": "APC control register 6 // Reserved",
              "offset": 280,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "APC_CTRL_7": {
              "description": "APC control register 7 // Reserved",
              "offset": 284,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "APC_STA_0": {
              "description": "APC status register 0",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "porz": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 2,
                    "size": 1
                  },
                  "digtestbus": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 3,
                    "size": 1
                  },
                  "testreq": {
                    "description": "Please refer to the Technical Reference Manual for detail, NO SYNC, FW need to read it twice to ensure the value.",
                    "offset": 4,
                    "size": 1
                  }
                }
              }
            },
            "APC_STA_1": {
              "description": "APC status register 1",
              "offset": 292,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "RING_OSC": {
              "description": "Ring oscilator control register",
              "offset": 384,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RING_OSC_EN": {
                    "description": "1'b1 : Turn on the RING OSC,  Ring OSC will be always on despite the HW control.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.AIP.children.enums.RING_OSC_EN"
                  },
                  "General_Purpos_SFR": {
                    "description": "1'b1 : Turn on the RING OSC,  Ring OSC will be always on despite the HW control.",
                    "offset": 1,
                    "size": 7
                  }
                }
              }
            },
            "LDO_30_CTRL_0": {
              "description": "LDO_30 control register 0",
              "offset": 512,
              "size": 32,
              "reset_value": 556,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DIS": {
                    "description": "Used to disable LDO_30 ",
                    "offset": 0,
                    "size": 1
                  },
                  "DISPG": {
                    "description": "Used to disable the power good comparator ",
                    "offset": 1,
                    "size": 1
                  },
                  "IMAX": {
                    "description": "Configures the control for maximum expected current imax current (mA)",
                    "offset": 2,
                    "size": 3,
                    "enum": "types.peripherals.AIP.children.enums.IMAX"
                  },
                  "DI": {
                    "description": "Output voltage programming. Note: Please keep LDO_30_DI and LDO_50_DI to be equal values for proper operation and lower power consumption.",
                    "offset": 5,
                    "size": 5,
                    "enum": "types.peripherals.AIP.children.enums.DI"
                  }
                }
              }
            },
            "LDO_30_CTRL_1": {
              "description": "LDO_30 control register 1",
              "offset": 516,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TEST": {
                    "description": "Lab Test and internal block characterization Test control pins.",
                    "offset": 0,
                    "size": 4
                  },
                  "TESTREQ": {
                    "description": "Request of connection of the anatestbus to an external pin for characterization",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "LDO_50_CTRL_0": {
              "description": "LDO_50 control register 0",
              "offset": 528,
              "size": 32,
              "reset_value": 556,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DIS": {
                    "description": "Used to disable LDO_30 ",
                    "offset": 0,
                    "size": 1
                  },
                  "DISPG": {
                    "description": "Used to disable the power good comparator ",
                    "offset": 1,
                    "size": 1
                  },
                  "IMAX": {
                    "description": "Configures the control for maximum expected current imax current (mA)",
                    "offset": 2,
                    "size": 3,
                    "enum": "types.peripherals.AIP.children.enums.IMAX"
                  },
                  "DI": {
                    "description": "Output voltage programming. Note: Please keep LDO_30_DI and LDO_50_DI to be equal values for proper operation and lower power consumption.",
                    "offset": 5,
                    "size": 5,
                    "enum": "types.peripherals.AIP.children.enums.DI"
                  }
                }
              }
            },
            "LDO_50_CTRL_1": {
              "description": "LDO_50 control register 1",
              "offset": 532,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TEST": {
                    "description": "Lab Test and internal block characterization Test control pins.",
                    "offset": 0,
                    "size": 4
                  },
                  "TESTREQ": {
                    "description": "Request of connection of the anatestbus to an external pin for characterization",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "en": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "oscillator_off": {
                    "description": "Disable the oscillator",
                    "value": 0
                  },
                  "oscillator_on": {
                    "description": "Enable the oscillator",
                    "value": 1
                  }
                }
              }
            },
            "fref16k_sel": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "with_32k_osc": {
                    "description": "Reference clock is 32KHz",
                    "value": 0
                  },
                  "with_16k_osc": {
                    "description": "Reference clock is 16KHz",
                    "value": 1
                  }
                }
              }
            },
            "RING_OSC_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "oscillator_off": {
                    "description": "Disable the ring oscillator",
                    "value": 0
                  },
                  "oscillator_on": {
                    "description": "Enable the ring oscillator",
                    "value": 1
                  }
                }
              }
            },
            "IMAX": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "max_30mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 30mA",
                    "value": 0
                  },
                  "max_18mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 18mA",
                    "value": 1
                  },
                  "max_12mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 12mA",
                    "value": 2
                  },
                  "max_7_2mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 7.2mA (default)",
                    "value": 3
                  },
                  "max_4_8mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 4.8mA",
                    "value": 4
                  },
                  "max_2_4mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 2.4mA",
                    "value": 5
                  },
                  "max_1_2mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 1.2mA",
                    "value": 6
                  },
                  "max_0_6mA_current": {
                    "description": "Configure the maximum current for LDO_30 as 0.6mA",
                    "value": 7
                  }
                }
              }
            },
            "DI": {
              "size": 5,
              "children": {
                "enum_fields": {
                  "as_0_75v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.75v",
                    "value": 0
                  },
                  "as_0_77v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.77v",
                    "value": 1
                  },
                  "as_0_79v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.79v",
                    "value": 2
                  },
                  "as_0_81v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.81v",
                    "value": 3
                  },
                  "as_0_83v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.83v",
                    "value": 4
                  },
                  "as_0_85v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.85v",
                    "value": 5
                  },
                  "as_0_87v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.87v",
                    "value": 6
                  },
                  "as_0_89v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.89v",
                    "value": 7
                  },
                  "as_0_91v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.91v",
                    "value": 8
                  },
                  "as_0_93v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.93v",
                    "value": 9
                  },
                  "as_0_95v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.95v",
                    "value": 10
                  },
                  "as_0_97v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.97v",
                    "value": 11
                  },
                  "as_0_99v_output": {
                    "description": "Configures the LDO_30 output voltage as 0.99v",
                    "value": 12
                  },
                  "as_1_01v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.01v",
                    "value": 13
                  },
                  "as_1_03v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.03v",
                    "value": 14
                  },
                  "as_1_05v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.05v",
                    "value": 15
                  },
                  "as_1_07v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.07v",
                    "value": 16
                  },
                  "as_1_09v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.09v (default)",
                    "value": 17
                  },
                  "as_1_11v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.11v",
                    "value": 18
                  },
                  "as_1_13v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.13v",
                    "value": 19
                  },
                  "as_1_15v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.15v",
                    "value": 20
                  },
                  "as_1_17v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.17v",
                    "value": 21
                  },
                  "as_1_19v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.19v",
                    "value": 22
                  },
                  "as_1_21v_output": {
                    "description": "Configures the LDO_30 output voltage as 1.21v",
                    "value": 23
                  }
                }
              }
            }
          }
        }
      },
      "AUD": {
        "description": "Audio Subsystem",
        "children": {
          "registers": {
            "VOICE_CONFIG": {
              "description": "Audio system configure register",
              "offset": 0,
              "size": 32,
              "reset_value": 4259840,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DMIC_SEL": {
                    "description": "Select the source for digital mic signal",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.DMIC_SEL"
                  },
                  "LPSD_SEL": {
                    "description": "Select between external or internal sensory LSPD",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_SEL"
                  },
                  "MODE_SEL": {
                    "description": "Select either monoaural or stereo mode",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.MODE_SEL"
                  },
                  "MONO_CHN_SEL": {
                    "description": "Select either right channel in mono mode or left channel",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.MONO_CHN_SEL"
                  },
                  "I2S_DS_EN": {
                    "description": "Set to enable the I2S Deep Sleep mode",
                    "offset": 4,
                    "size": 1
                  },
                  "PDM_VOICE_SCENARIO": {
                    "description": "Choose the PDM voice scenario",
                    "offset": 5,
                    "size": 3,
                    "enum": "types.peripherals.AUD.children.enums.PDM_VOICE_SCENARIO"
                  },
                  "PDM_MIC_SWITCH_TO_AP": {
                    "description": "Set to switch mic to AP",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.PDM_MIC_SWITCH_TO_AP"
                  },
                  "LPSD_USE_DC_BLOCK": {
                    "description": "Set to use LPSD DC Block",
                    "offset": 9,
                    "size": 1
                  },
                  "LPSD_MUX": {
                    "description": "Choose the channel pcm data for LPSD in stereo mode",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_MUX"
                  },
                  "LPSD_NO": {
                    "description": "Set to disable HW LPSD",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_NO"
                  },
                  "I2S_FPGA_EN": {
                    "description": "Set to enable the FPGA I2S",
                    "offset": 12,
                    "size": 1
                  },
                  "DIV_AP": {
                    "description": "AP_PDM_CKO_IN frequency divide-down ratio for AP clock detection",
                    "offset": 15,
                    "size": 3
                  },
                  "DIV_WD": {
                    "description": "AP_PDM_CKO_IN clock detection window range",
                    "offset": 18,
                    "size": 6
                  },
                  "FIFO_0_CLEAR": {
                    "description": "Set to flush FIFO",
                    "offset": 24,
                    "size": 1
                  },
                  "FIFO_1_CLEAR": {
                    "description": "Set to Flush FIFO",
                    "offset": 25,
                    "size": 1
                  },
                  "LPSD_VOICE_DETECTED_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 26,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  },
                  "DMIC_VOICE_DETECTED_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 27,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  },
                  "DMAC_BLK_DONE_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 28,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  },
                  "DMAC_BUF_DONE_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 29,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  },
                  "AP_PDM_CLK_IB_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 30,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  },
                  "AP_PDM_CLK_OFF_MASK": {
                    "description": "Control the masking of the interrupt",
                    "offset": 31,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.LPSD_VOICE_DETECTED_MASK"
                  }
                }
              }
            },
            "LPSD_CONFIG": {
              "description": "LPSD config register",
              "offset": 4,
              "size": 32,
              "reset_value": 1297614000,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "LPSD_THD": {
                    "description": "LPSD threshold parameter",
                    "offset": 0,
                    "size": 16
                  },
                  "LPSD_RATIO_STOP": {
                    "description": "LPSD threshold parameter",
                    "offset": 16,
                    "size": 8
                  },
                  "LPSD_RATIO_RUN": {
                    "description": "LPSD run parameter",
                    "offset": 24,
                    "size": 8
                  }
                }
              }
            },
            "VOICE_DMA_CONFIG": {
              "description": "Audio DMAC configure register",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DMAC_EN": {
                    "description": "Set to enable Voice DMAC",
                    "offset": 0,
                    "size": 1
                  },
                  "DMAC_START": {
                    "description": "Set to start DMA",
                    "offset": 1,
                    "size": 1,
                    "access": "write-only"
                  },
                  "DMAC_STOP": {
                    "description": "Set to Stop DMA",
                    "offset": 2,
                    "size": 1
                  },
                  "AHB_RDY": {
                    "description": "Set to indicate AHB clock is ready",
                    "offset": 3,
                    "size": 1
                  },
                  "AHB_BURST_LENGHT": {
                    "description": "Select the AHB Burst Lenght in words",
                    "offset": 4,
                    "size": 2
                  },
                  "PINGPONG_MODE": {
                    "description": "Select the pingpong mode",
                    "offset": 6,
                    "size": 1
                  },
                  "STEREO_DUAL_BUF_MODE": {
                    "description": "Select how to process stereo buffer data",
                    "offset": 7,
                    "size": 1
                  },
                  "VOICE_DMAC_BURST_SPD": {
                    "description": "AHB cycles between two consecutive AHB Bursts",
                    "offset": 8,
                    "size": 8
                  }
                }
              }
            },
            "VOICE_DMAC_LEN": {
              "description": "Audio DMAC length register",
              "offset": 12,
              "size": 32,
              "reset_value": 78643320,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DMAC_BLK_LEN": {
                    "description": "DMA block transfer length in words",
                    "offset": 0,
                    "size": 16
                  },
                  "DMAC_BUF_LEN": {
                    "description": "DMA buffer transfer length in words",
                    "offset": 16,
                    "size": 16
                  }
                }
              }
            },
            "VOICE_DMAC_FIFO": {
              "description": "Audio DMAC Buffer offset",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294901760,
              "children": {
                "fields": {
                  "DMAC_BUF_OFFSER": {
                    "description": "buffer offset address in dual buffer mode",
                    "offset": 16,
                    "size": 16
                  }
                }
              }
            },
            "VOICE_DMAC_DST_ADDR0": {
              "description": "DMA0 dest address for the first buffer",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "VOICE_DMAC_DST_ADDR0": {
                    "description": "DMA0 dest address for the first buffer",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "VOICE_DMAC_DST_ADDR1": {
              "description": "DMA1 dest address for the first buffer",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "VOICE_DMAC_DST_ADDR1": {
                    "description": "DMA1 dest address for the first buffer",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "PDM_CORE_CONFIG": {
              "description": "PDM2PCM core configure register",
              "offset": 28,
              "size": 32,
              "reset_value": 276981449,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "PDM_CORE_CONFIG": {
                    "description": "Set to enable PDM core",
                    "offset": 0,
                    "size": 1
                  },
                  "SOFT_MUTE": {
                    "description": "Set to enable PDM Soft mute",
                    "offset": 1,
                    "size": 1
                  },
                  "DIV_MODE": {
                    "description": "Select which divider to use in sampler",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.AUD.children.enums.DIV_MODE"
                  },
                  "S_CYCLES": {
                    "description": "Set number of PDM_CLK during gain setting changes or soft mute",
                    "offset": 3,
                    "size": 3
                  },
                  "HP_GAIN": {
                    "description": "Adjust high pass filter coefficients",
                    "offset": 6,
                    "size": 4
                  },
                  "ADCHPD": {
                    "description": "Set to disable high pass filter",
                    "offset": 10,
                    "size": 1
                  },
                  "M_CLK_DIV": {
                    "description": "PDM_CLK frquency divisor",
                    "offset": 11,
                    "size": 2
                  },
                  "SINC_RATE": {
                    "description": "SINC decimation rate",
                    "offset": 13,
                    "size": 7
                  },
                  "PGA_L": {
                    "description": "Left channel PGA gain",
                    "offset": 20,
                    "size": 5
                  },
                  "PGA_R": {
                    "description": "Right channel PGA gain",
                    "offset": 25,
                    "size": 5
                  },
                  "DMICK_DLY": {
                    "description": "Input data sampling with PDM clock cycle delay",
                    "offset": 30,
                    "size": 1
                  },
                  "DIV_WD_MODE": {
                    "description": "Status IN detection windows",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "VOICE_STATUS": {
              "description": "Audio Status Register",
              "offset": 32,
              "size": 32,
              "reset_value": 266513,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FIFO_0A_EMPTY": {
                    "description": "Set if the FIFO is empty",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FIFO_0A_FULL": {
                    "description": "Set if the FIFO is full",
                    "offset": 1,
                    "size": 1
                  },
                  "FIFO_0A_OVERFLOW": {
                    "description": "Set if there's a FIFO overflow",
                    "offset": 2,
                    "size": 1
                  },
                  "FIFO_0B_EMPTY": {
                    "description": "Set if the FIFO is empty",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FIFO_0B_FULL": {
                    "description": "Set if the FIFO is full",
                    "offset": 5,
                    "size": 1
                  },
                  "FIFO_0B_OVERFLOW": {
                    "description": "Set if there's a FIFO overflow",
                    "offset": 6,
                    "size": 1
                  },
                  "FIFO_1A_EMPTY": {
                    "description": "Set if the FIFO is empty",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FIFO_1A_FULL": {
                    "description": "Set if the FIFO is full",
                    "offset": 9,
                    "size": 1
                  },
                  "FIFO_1A_OVERFLOW": {
                    "description": "Set if there's a FIFO overflow",
                    "offset": 10,
                    "size": 1
                  },
                  "FIFO_1B_EMPTY": {
                    "description": "Set if the FIFO is empty",
                    "offset": 12,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FIFO_1B_FULL": {
                    "description": "Set if the FIFO is full",
                    "offset": 13,
                    "size": 1
                  },
                  "FIFO_1B_OVERFLOW": {
                    "description": "Set if there's a FIFO overflow",
                    "offset": 14,
                    "size": 1
                  },
                  "DMIC_VOICE_DETECTED_REG": {
                    "description": "Set if detected",
                    "offset": 16,
                    "size": 1,
                    "access": "read-only"
                  },
                  "LPSD_VOICE_DETECTED_REG": {
                    "description": "Set if detected",
                    "offset": 17,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AP_PDM_CLK_OFF_REG": {
                    "description": "Set if AP PDM clock is off",
                    "offset": 18,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AP_PDM_CLK_ON_REG": {
                    "description": "Set if AP PDM clock is on",
                    "offset": 19,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DMAC1_BUF_DONE_REG": {
                    "description": "Set if done",
                    "offset": 20,
                    "size": 1
                  },
                  "DMAC1_BLK_DONE_REG": {
                    "description": "Set if done",
                    "offset": 21,
                    "size": 1
                  },
                  "DMAC0_BUF_DONE_REG": {
                    "description": "Set if done",
                    "offset": 22,
                    "size": 1
                  },
                  "DMAC0_BLK_DONE_REG": {
                    "description": "Set if done",
                    "offset": 23,
                    "size": 1
                  }
                }
              }
            },
            "I2S_CONFIG": {
              "description": "I2S master configure register",
              "offset": 36,
              "size": 32,
              "reset_value": 8256,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "I2S_LRCDIV": {
                    "description": "I2S_CLK divisor for WD_CLK generator",
                    "offset": 0,
                    "size": 12
                  },
                  "I2S_BLKDIV": {
                    "description": "I2S_MASTER_CLK divisor for I2S_CLK generator",
                    "offset": 12,
                    "size": 6
                  },
                  "I2S_CLK_INV": {
                    "description": "Set to activate inverting",
                    "offset": 18,
                    "size": 1
                  },
                  "I2S_IWL": {
                    "description": "Input sample data bit shift",
                    "offset": 19,
                    "size": 2
                  }
                }
              }
            },
            "FIFO_SRAM_CFG": {
              "description": "FIFO SRAM configure register",
              "offset": 40,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRAM_0A_TEST1": {
                    "description": "Test pin to bypass self-timed circuit",
                    "offset": 0,
                    "size": 1
                  },
                  "SRAM_0A_RME": {
                    "description": "Read-Write margin Enable input",
                    "offset": 1,
                    "size": 1
                  },
                  "SRAM_0A_RM": {
                    "description": "Read-Write margin Input for Left Channel 8KB FIFO",
                    "offset": 2,
                    "size": 4
                  },
                  "SRAM_0B_TEST1": {
                    "description": "Test pin to bypass self-timed circuit",
                    "offset": 6,
                    "size": 1
                  },
                  "SRAM_0B_RME": {
                    "description": "Read-Write margin Enable input",
                    "offset": 7,
                    "size": 1
                  },
                  "SRAM_0B_RM": {
                    "description": "Read-Write margin Input for Left Channel 512B FIFO",
                    "offset": 8,
                    "size": 4
                  },
                  "SRAM_1A_TEST1": {
                    "description": "Test pin to bypass self-timed circuit",
                    "offset": 12,
                    "size": 1
                  },
                  "SRAM_1A_RME": {
                    "description": "Read-Write margin Enable input",
                    "offset": 13,
                    "size": 1
                  },
                  "SRAM_1A_RM": {
                    "description": "Read-Write margin Input for Right Channel 8KB FIFO",
                    "offset": 14,
                    "size": 4
                  },
                  "SRAM_1B_TEST1": {
                    "description": "Test pin to bypass self-timed circuit",
                    "offset": 18,
                    "size": 1
                  },
                  "SRAM_1B_RME": {
                    "description": "Read-Write margin Enable input",
                    "offset": 19,
                    "size": 1
                  },
                  "SRAM_1B_RM": {
                    "description": "Read-Write margin Input for Right Channel 512B FIFO",
                    "offset": 20,
                    "size": 4
                  }
                }
              }
            },
            "PDMA_SRAM_CFG": {
              "description": "PDM core SRAM configure register",
              "offset": 44,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "PDM_SRAM_L_TEST1": {
                    "description": "Test pin to bypass self-timed circuit",
                    "offset": 0,
                    "size": 1
                  },
                  "PDM_SRAM_L_RME": {
                    "description": "Read-Write margin Enable Input",
                    "offset": 1,
                    "size": 1
                  },
                  "PDM_SRAM_L_RM": {
                    "description": "Read-Write margin Input for Right Channel PDM SRAM",
                    "offset": 2,
                    "size": 4
                  }
                }
              }
            },
            "DBG_MUX_CFG": {
              "description": "Audio Debug Register",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DBG_MUX": {
                    "description": "\\n 0000 => dbg_tp[7:0] = dbg_fifo_0a_wptr[7:0] \\n 0001 => dbg_tp[7:0] = dbg_fifo_0a_rptr[7:0] \\n 0010 => dbg_tp[7:0] = {1'b0, dbg_fifo_0a_rptr[10:8], 1'b0, dbg_fifo_0a_wptr[10:8]} \\n\\n 0011 => dbg_tp[7:0] = dbg_fifo_1a_wptr[7:0] \\n 0100 => dbg_tp[7:0] = dbg_fifo_1a_rptr[7:0] \\n 0101 => dbg_tp[7:0] = {1'b0, dbg_fifo_1a_rptr[10:8], 1'b0, dbg_fifo_1a_wptr[10:8]} \\n\\n 0110 => dbg_tp[7:0] = {2'd0, dbg_fifo_0b_wptr[5:0]} \\n\\n 0111 => dbg_tp[7:0] = {2'd0, dbg_fifo_0b_rptr[5:0]} \\n\\n 1000 => dbg_tp[7:0] = {2'd0, dbg_fifo_1b_wptr[5:0]} \\n\\n 1001 => dbg_tp[7:0] = {2'd0, dbg_fifo_1b_rptr[5:0]} \\n\\n 1010 => dbg_tp[7:0] = {2'd0, dbg_afifo_0_rptr[1:0], 2'd0, dbg_afifo_0_wptr[1:0]}  \\n\\n 1011 => dbg_tp[7:0] ={2'd0, dbg_afifo_1_rptr[1:0], 2'd0, dbg_afifo_1_wptr[1:0]} \\n\\n 1100 => dbg_tp[7:0] = {PCM_DATA_L[7:1],VALID} \\n\\n 1101 => dbg_tp[7:0] = {PCM_DATA_L[15:9],VALID}  \\n\\n 1110 => dbg_tp[7:0] = {PCM_DATA_R[7:1],VALID} \\n\\n 1111 => dbg_tp[7:0] = {PCM_DATA_R[15:9],VALID}",
                    "offset": 0,
                    "size": 4
                  }
                }
              }
            }
          },
          "enums": {
            "DMIC_SEL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "pdm": {
                    "description": "DMIC source is PDM",
                    "value": 0
                  },
                  "i2s": {
                    "description": "DMIC source is I2S",
                    "value": 1
                  }
                }
              }
            },
            "LPSD_SEL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "internal": {
                    "description": "Use internal sensory LPSD",
                    "value": 0
                  },
                  "external": {
                    "description": "Use external sensory LPSD",
                    "value": 1
                  }
                }
              }
            },
            "MODE_SEL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mono": {
                    "description": "Audio mode selected as Mono",
                    "value": 0
                  },
                  "stereo": {
                    "description": "Audio mode selected as Stereo",
                    "value": 1
                  }
                }
              }
            },
            "MONO_CHN_SEL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "left_channel": {
                    "description": "Left channel in mono mode",
                    "value": 0
                  },
                  "right_channel": {
                    "description": "Right channel in mono mode",
                    "value": 1
                  }
                }
              }
            },
            "PDM_VOICE_SCENARIO": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "scenario1": {
                    "description": "Choose voice scenario 1",
                    "value": 0
                  },
                  "scenario2": {
                    "description": "Choose voice scenario 2",
                    "value": 1
                  },
                  "scenario3_mode1": {
                    "description": "Choose voice scenario 3 mode 1",
                    "value": 2
                  },
                  "scenario3_mode2": {
                    "description": "Choose voice scenario 3 mode 2",
                    "value": 3
                  },
                  "scenario3_mode3": {
                    "description": "Choose voice scenario 3 mode 3",
                    "value": 4
                  }
                }
              }
            },
            "PDM_MIC_SWITCH_TO_AP": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "no_switch": {
                    "description": "Don't switch to AP",
                    "value": 0
                  },
                  "switch": {
                    "description": "Switch to AP",
                    "value": 1
                  }
                }
              }
            },
            "LPSD_MUX": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "left_channel": {
                    "description": "Left channel pcm data to LPSD in stereo mode",
                    "value": 0
                  },
                  "right_channel": {
                    "description": "Right channel pcm data to LPSD in stereo mode",
                    "value": 1
                  }
                }
              }
            },
            "LPSD_NO": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable_hw": {
                    "description": "Enable hardware LPSD",
                    "value": 0
                  },
                  "disable_hw": {
                    "description": "Disable HW LPSD",
                    "value": 1
                  }
                }
              }
            },
            "LPSD_VOICE_DETECTED_MASK": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "unmask": {
                    "description": "Unmask the interrupt",
                    "value": 0
                  },
                  "mask": {
                    "description": "Mask the interrupt",
                    "value": 1
                  }
                }
              }
            },
            "DIV_MODE": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "left": {
                    "description": "Use PDM_LEFT in sampler",
                    "value": 0
                  },
                  "right": {
                    "description": "Use PDM_RIGHT in sampler",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "CFG_CTL": {
        "description": "PIF Register (FPGA Programming interface)",
        "children": {
          "registers": {
            "CFG_CTL": {
              "description": "Fabric Configuration Control Register",
              "offset": 0,
              "size": 32,
              "reset_value": 2147499518,
              "reset_mask": 2147549183,
              "children": {
                "fields": {
                  "APB_SEL_CFG": {
                    "description": "ARM firmware/software sets this register 1'b1 to Get the Control Right of Cfg_Ctl",
                    "offset": 0,
                    "size": 1
                  },
                  "APB_TRM_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select TRM Block",
                    "offset": 1,
                    "size": 1
                  },
                  "APB_TR_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select TR Block",
                    "offset": 2,
                    "size": 1
                  },
                  "APB_TLM_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select TLM Block",
                    "offset": 3,
                    "size": 1
                  },
                  "APB_TL_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select TL Block",
                    "offset": 4,
                    "size": 1
                  },
                  "APB_BRM_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select BRM Block",
                    "offset": 5,
                    "size": 1
                  },
                  "APB_BR_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select BR Block",
                    "offset": 6,
                    "size": 1
                  },
                  "APB_BLM_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select BLM Block",
                    "offset": 7,
                    "size": 1
                  },
                  "APB_BL_SEL": {
                    "description": "ARM firmware/software sets this register 1'b1 to Select BL Block",
                    "offset": 8,
                    "size": 1
                  },
                  "APB_PARTIAL_LOAD": {
                    "description": "ARM firmware/software sets this register 1'b1 to enable Partial Load",
                    "offset": 9,
                    "size": 1
                  },
                  "APB_WL_DIN": {
                    "description": "ARM firmware/software sets this register to set Word Line Data In",
                    "offset": 10,
                    "size": 4
                  },
                  "APB_CFG_RD": {
                    "description": "ARM firmware/software sets this register 1'b1 and APB_CFG_WR 1'b0 to perform Configuration Read",
                    "offset": 14,
                    "size": 1
                  },
                  "APB_CFG_WR": {
                    "description": "ARM firmware/software sets this register 1'b1 and APB_CFG_RD 1'b0 to perform Configuration Write",
                    "offset": 15,
                    "size": 1
                  },
                  "SW_PWR_GATE": {
                    "description": "Shift Register Power Gate Status: 1 in configuration mode, 0 in normal mode",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "MAX_BL_CNT": {
              "description": "Maximum Bit Length Count: ARM firmware/software sets this register 1'b1 to set the Maximum Bit Line Count",
              "offset": 4,
              "size": 32,
              "reset_value": 45,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "MAX_BL_CNT": {
                    "description": "Maximum Bit Length Count: ARM firmware/software sets this register 1'b1 to set the Maximum Bit Line Count",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "MAX_WL_CNT": {
              "description": "Maximum Word Length Count: ARM firmware/software sets this register 1'b1 to set the Maximum Word Line Count",
              "offset": 8,
              "size": 32,
              "reset_value": 422,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "MAX_WL_CNT": {
                    "description": "Maximum Word Length Count: ARM firmware/software sets this register 1'b1 to set the Maximum Word Line Count",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CFG_DATA": {
              "description": "Configuration Data: ARM firmware/software Access this register to Read/Write the configuration bit cells.",
              "offset": 4092,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "CFG_DATA": {
                    "description": "Configuration Data: ARM firmware/software Access this register to Read/Write the configuration bit cells.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RAMFIFO0": {
              "description": "RAMFIFO0 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO0. From 0x8000 to 0x8FFC.",
              "offset": 16384,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RAMFIFO0": {
                    "description": "RAMFIFO0 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO0. From 0x8000 to 0x8FFC.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RAMFIFO1": {
              "description": "RAMFIFO1 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO1. From 0x9000 to 0x9FFC.",
              "offset": 20480,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RAMFIFO1": {
                    "description": "RAMFIFO1 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO1. From 0x9000 to 0x9FFC.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RAMFIFO2": {
              "description": "RAMFIFO2 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO2. From 0xA000 to 0xAFFC.",
              "offset": 24576,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RAMFIFO2": {
                    "description": "RAMFIFO2 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO2. From 0xA000 to 0xAFFC.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RAMFIFO3": {
              "description": "RAMFIFO3 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO3. From 0xB000 to 0xBFFC.",
              "offset": 28672,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RAMFIFO3": {
                    "description": "RAMFIFO3 Address: ARM firmware/software Access these registers to Read/Write the RAMFIFO3. From 0xB000 to 0xBFFC.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            }
          }
        }
      },
      "CRU": {
        "description": "Clock Reset Unit",
        "children": {
          "registers": {
            "CLK_CTRL_A_0": {
              "description": "For Clock 10 (SYNC Up on A0 and AHB Interface of Batching Memory, AUDIO DMA, M4 SRAMs,M4 Bus Matrix and Trace block)",
              "offset": 0,
              "size": 32,
              "reset_value": 516,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2. default div is 6",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_A_1": {
              "description": "For Clock 10 (SYNC Up on A0 and AHB Interface of Batching Memory, AUDIO DMA, M4 SRAMs,M4 Bus Matrix and Trace block)",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Select the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "CLK_CTRL_B_0": {
              "description": "For Clock 2 (FB, A1 (Including CFGSM))",
              "offset": 8,
              "size": 32,
              "reset_value": 516,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2. default div is 6",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_B_1": {
              "description": "For Clock 2 (FB, A1 (Including CFGSM))",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Select the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "CLK_CTRL_C_0": {
              "description": "For Clock 8 X4 (FFE X4 clk)",
              "offset": 16,
              "size": 32,
              "reset_value": 516,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2. default div is 6",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_D_0": {
              "description": "For Clock 11 (To M4 peripherals - AHB/APB bridge, UART, WDT and TIMER)",
              "offset": 20,
              "size": 32,
              "reset_value": 526,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2, default div is 16",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_E_0": {
              "description": "For Clock 12 - Reserved",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295
            },
            "CLK_CTRL_E_1": {
              "description": "For Clock 12",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "The selected the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "CLK_CTRL_F_0": {
              "description": "For Clock 16 (FB)",
              "offset": 32,
              "size": 32,
              "reset_value": 526,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2, default div is 16",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_F_1": {
              "description": "For Clock 16 (FB)",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Select the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "CLK_CTRL_G_0": {
              "description": "For Clock 30 (PDM LEFT/RIGHT clk, I2S Master clk)",
              "offset": 40,
              "size": 32,
              "reset_value": 526,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2, default div is 32",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_H_0": {
              "description": "For Clock 19 (ADC)",
              "offset": 44,
              "size": 32,
              "reset_value": 526,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2, default div is 16",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_H_1": {
              "description": "For Clock 19 (ADC)",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Select the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "CLK_CTRL_I_0": {
              "description": "For Clock 21 (FB - additional clk)",
              "offset": 52,
              "size": 32,
              "reset_value": 526,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio equals value in register + 2, default div is 16",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "Control if the clock divider is on",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CLK_CTRL_I_1": {
              "description": "For Clock 21 (FB - additional clk)",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Select the clock source",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection"
                  }
                }
              }
            },
            "C01_CLK_GATE": {
              "description": "Gating control for Clock 1",
              "offset": 64,
              "size": 32,
              "reset_value": 657,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To A0",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_1_Gating_Control": {
                    "description": "To SDMA SRAM",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_2_Gating_Control": {
                    "description": "To packet FIFO",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_3_Gating_Control": {
                    "description": "To FFE",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_4_Gating_Control": {
                    "description": "To AHB2APB Bridge /CFG DMA Bridge inside A1 , Allow M4 to configure SPI Master to load the code",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_5_Gating_Control": {
                    "description": "To I2S module inside A1",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_6_Gating_Control": {
                    "description": "To SDMA",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_7_Gating_Control": {
                    "description": "Not specified",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_9_Gating_Control": {
                    "description": "For SPT",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C02_CLK_GATE": {
              "description": "Gating control for Clock 2",
              "offset": 68,
              "size": 32,
              "reset_value": 5,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To A1 (including CFGSM)",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_1_Gating_Control": {
                    "description": "To FB",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_2_Gating_Control": {
                    "description": "Not specified",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C08_X4_CLK_GATE": {
              "description": "Gating control for FFE X4 clock",
              "offset": 72,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To FFE X4 clk",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C08_X1_CLK_GATE": {
              "description": "Gating control for FFE X1  clock",
              "offset": 76,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To FFE X1 clk",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_2_Gating_Control": {
                    "description": "To To A0",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_3_Gating_Control": {
                    "description": "To To PF ASYNC FIFO 0",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C10_FCLK_GATE": {
              "description": "Gating control for Clock 10",
              "offset": 80,
              "size": 32,
              "reset_value": 67,
              "reset_mask": 127,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To M4 Bus Matrix and Trace block",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_1_Gating_Control": {
                    "description": "RWHC: To M4 SRAM Instance, M4S0~M4S3. This bit will be set if any of the Memories (M4S0~M4S3) been wakeup  by Hardware.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_2_Gating_Control": {
                    "description": "RWHC: To M4 SRAM Instance, M4S4~M4S7. This bit will be set if any of the Memories (M4S4~M4S7) been wakeup  by Hardware.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_3_Gating_Control": {
                    "description": "RWHC: To M4 SRAM Instance, M4S8~M4S11. This bit will be set if any of the Memories (M4S8~M4S11) been wakeup by Hardware.",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_4_Gating_Control": {
                    "description": "RWHC: To M4 SRAM Instance, M4S12~M4S15. This bit will be set if any of the Memories (M4S12~M4S15) been wakeup by Hardware.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_5_Gating_Control": {
                    "description": "To AUDIO DMA",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_6_Gating_Control": {
                    "description": "To the SYNC Up on A0 and AHB Interface of Batching Memory",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C11_CLK_GATE": {
              "description": "Gating control for clock 11",
              "offset": 84,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To M4 peripherals - AHB/APB bridge, UART, WDT and TIMER",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C12_CLK_GATE_Reserved": {
              "description": "Gating control for clock 12",
              "offset": 88,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "CS_CLK_GATE": {
              "description": "Gating control for SWD CS clock U",
              "offset": 92,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To SWD Clk from PIN",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "CU_CLK_GATE_Reserved": {
              "description": "Not specified",
              "offset": 96,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "C16_CLK_GATE": {
              "description": "Gating control for FB clock 16",
              "offset": 100,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To SWD Clk from PIN",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "CLK_RESERVED_0": {
              "description": "Not specified",
              "offset": 104,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "C19_CLK_GATE": {
              "description": "Gating control for ADC clock 19",
              "offset": 108,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To ADC",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C21_CLK_GATE": {
              "description": "Gating control for FB additional clock 21",
              "offset": 112,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To FB (additional CLK)",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "PF_SW_RESET": {
              "description": "Packet FIFO power domain Software Reset.Once Program the SW Reset Bit to 1, the corresponding reset will be asserted immediately. Once Program the SW Reset Bit to 0, the corresponding reset will be de-asserted synchronous even the corresponding clock is not running. (Turn off by Clock gating cell)",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 127,
              "children": {
                "fields": {
                  "PF_FIFO_0_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 0,
                    "size": 1
                  },
                  "PF_FIFO_1_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 1,
                    "size": 1
                  },
                  "PF_FIFO_2_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 2,
                    "size": 1
                  },
                  "PF_FIFO_8k_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 3,
                    "size": 1
                  },
                  "PF_ASYNC_FIFO_0_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.(R08_P3 as well)",
                    "offset": 4,
                    "size": 1
                  },
                  "PF_Peripheral_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "FFE_SW_RESET": {
              "description": "Once Program the SW Reset Bit to 1, the corresponding reset will be asserted immediately. Once Program the SW Reset Bit to 0, the corresponding reset will be de-asserted synchronous even the corresponding clock is not running. (Turn off by Clock gating cell)",
              "offset": 132,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "FFE_0_X1_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. (R01_P3_FFE as well)",
                    "offset": 0,
                    "size": 1
                  },
                  "FFE_0_X4_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. (R01_P3_FFE as well)",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "FB_SW_RESET": {
              "description": "Once Program the SW Reset Bit to 1, the corresponding reset will be asserted immediately. Once Program the SW Reset Bit to 0, the corresponding reset will be de-asserted synchronous even the corresponding clock is not running. (Turn off by Clock gating cell)",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "FB_C02_Domain_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.FB_C02_Domain_SW_Reset"
                  },
                  "FB_C09_Domain_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.FB_C02_Domain_SW_Reset"
                  },
                  "FB_C16_Domain_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.FB_C02_Domain_SW_Reset"
                  },
                  "FB_C21_Domain_SW_Reset": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.FB_C02_Domain_SW_Reset"
                  }
                }
              }
            },
            "A1_SW_RESET": {
              "description": "Once Program the SW Reset Bit to 1, the corresponding reset will be asserted immediately. Once Program the SW Reset Bit to 0, the corresponding reset will be de-asserted synchronous even the corresponding clock is not running. (Turn off by Clock gating cell)",
              "offset": 140,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SPT_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. -> This is used to Reset the SPT",
                    "offset": 0,
                    "size": 1
                  },
                  "CfgSM_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. -> This is used to Reset the CfgSM/SPI Master and Related FIFO, DMA and AHB Master",
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "AUDIO_MISC_SW_RESET": {
              "description": "Once Program the SW Reset Bit to 1, the corresponding reset will be asserted immediately. Once Program the SW Reset Bit to 0, the corresponding reset will be de-asserted synchronous even the corresponding clock is not running. (Turn off by Clock gating cell)",
              "offset": 144,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "AD0_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "AD1_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "AD2_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "AD3_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "AD4_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "AD5_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "DMA_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For DMA Power Domain.",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  },
                  "I2S_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For I2S Power Domain. Note: It will only reset the AHB interface R01, but it will not reset R32 path. Suggest to power down, then power on I2S if Software Reset is needed",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AD0_SW_RESET"
                  }
                }
              }
            },
            "FB_MISC_SW_RST_CTL": {
              "description": "Not specified. FAFIFO1, AHBWB Software Reset control",
              "offset": 148,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "AHBWB_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For R40",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AHBWB_SW_RESET"
                  },
                  "PFAFIFO1_SW_RESET": {
                    "description": "1'b1 : Enable the Software Reset. FW need to disable it manually. ==> For R41",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.AHBWB_SW_RESET"
                  }
                }
              }
            },
            "CLK_CTRL_PMU": {
              "description": "This Clock is used to delay the Clock gating control signals from PMU. The PMU will monitor the feedback/delayed Clock Gating Control signals to ensure the clocks are OFF before jump to next state. The Firmware needs to Configure this divider to ensure there delay time is longer enough. C23 Clock needs to be 2/3 of the lowest clock frequency of other clocks. For Example, if the Lowest clock frequency of other clocks are 5, then C23 should be lower than 3.33MHz (Or the clock frequency of other clocks should be at least 1.5 times faster than C23.)",
              "offset": 256,
              "size": 32,
              "reset_value": 574,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Clock_Divider_Ratio": {
                    "description": "High Speed Clock Divider Ratio. Ratio is reg value + 2. default div is 64",
                    "offset": 0,
                    "size": 9
                  },
                  "Enable_Clock_Divider": {
                    "description": "1'b1 Clock Divider is ON. 1'b0 Clock Divider is OFF, Output the Source Clock Directly",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "CRU_GENERAL": {
              "description": "General reg and SPI ALWAYS ON control",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "SPICLK_ALWAYS_ON": {
                    "description": "Controls wether the SPI clock is always on or not",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.SPICLK_ALWAYS_ON"
                  },
                  "General": {
                    "description": "General purpose register",
                    "offset": 1,
                    "size": 7
                  }
                }
              }
            },
            "CRU_DEBUG": {
              "description": "CRU Debug registers",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "CRU_DEBUG_Select": {
                    "description": "Select the clock to be monitored",
                    "offset": 0,
                    "size": 4,
                    "enum": "types.peripherals.CRU.children.enums.CRU_DEBUG_Select"
                  }
                }
              }
            },
            "C01_CLK_DIV": {
              "description": "Source Clock is C10 (CLK to SDMA,I2S module Inside A1, AHB2APB Bridge /CFG DMA Bridge inside A1 , FFE, Packet FIFO,SDMA,A0 ) If Bit 4 is 0, any change on Bit 3:0 will not take effect. And bit 4 and bit 3:0 can not change at same time.",
              "offset": 272,
              "size": 32,
              "reset_value": 17,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "C01_CLK_DIV": {
                    "description": "The input clock frequency will be divided and generate the corresponding clock output. div is reg value + 1",
                    "offset": 0,
                    "size": 4
                  },
                  "C01_CLK_DIV_CG": {
                    "description": "This bit is used to turn off the clock for the SYNC down Divider",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C01_CLK_DIV_CG_ENUM"
                  }
                }
              }
            },
            "C09_CLK_DIV": {
              "description": "Source Clock is C10 (CLK to Voice APB interface, PIF, FB). If Bit 4 is 0, any change on Bit 3:0 will not take effect. And bit 4 and bit 3:0 can not change at same time.",
              "offset": 276,
              "size": 32,
              "reset_value": 17,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "C01_CLK_DIV": {
                    "description": "The input clock frequency will be divided and generate the corresponding clock output. div is reg value + 1",
                    "offset": 0,
                    "size": 4
                  },
                  "C01_CLK_DIV_CG": {
                    "description": "This bit is used to turn off the clock for the SYNC down Divider",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C01_CLK_DIV_CG_ENUM"
                  }
                }
              }
            },
            "C31_CLK_DIV": {
              "description": "Source Clock is C30 (LPSD CLK).If Bit 4 is 0, any change on Bit 3:0 will not take effect. And bit 4 and bit 3:0 can not change at same time.",
              "offset": 280,
              "size": 32,
              "reset_value": 19,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "C01_CLK_DIV": {
                    "description": "The input clock frequency will be divided and generate the corresponding clock output. div is reg value + 1",
                    "offset": 0,
                    "size": 4
                  },
                  "C01_CLK_DIV_CG": {
                    "description": "This bit is used to turn off the clock for the SYNC down Divider",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C01_CLK_DIV_CG_ENUM"
                  }
                }
              }
            },
            "C09_CLK_GATE": {
              "description": "Gating control for clock 09",
              "offset": 284,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "Path_0_Gating_Control": {
                    "description": "To voice APB interface",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_1_Gating_Control": {
                    "description": "To PIF",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  },
                  "Path_2_Gating_Control": {
                    "description": "To FB",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Path_0_Gating_Control"
                  }
                }
              }
            },
            "C30_C31_CLK_GATE": {
              "description": "Gating control for clocks 30-31",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "C30_Path_0_Gating_Control": {
                    "description": "To PDM LEFT CLK",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C30_Path_0_Gating_Control"
                  },
                  "C30_Path_1_Gating_Control": {
                    "description": "To PDM RIGHT CLK",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C30_Path_0_Gating_Control"
                  },
                  "C30_Path_2_Gating_Control": {
                    "description": "To I2S Master Clk",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C30_Path_0_Gating_Control"
                  },
                  "C31_Path_0_Gating_Control": {
                    "description": "To LPSD clk",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.C30_Path_0_Gating_Control"
                  }
                }
              }
            },
            "CLK_DIVIDER_CLK_GATING": {
              "description": "Control for divider gates in different clocks",
              "offset": 292,
              "size": 32,
              "reset_value": 1023,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "CLK_DIVIDER_A_CG": {
                    "description": "To C10,C01,C09 (SYNC Up on A0, AHB Interface of Batching Memory, AUDIO DMA, M4 SRAMs,M4 Bus Matrix , M4 Trace block, Debug controller, SDMA,I2S module Inside A1, AHB2APB Bridge /CFG DMA Bridge inside A1 , FFE, Packet FIFO,SDMA,A0, Voice APB interface, PIF, FB). Note: Firmware Should NOT program this bit to 0.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_B_CG": {
                    "description": "To C02 (FB, A1 (Including CFGSM))",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_C_CG": {
                    "description": "To C08 (FFE X4, X1)",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_D_CG": {
                    "description": "To C11 (M4 peripherals - AHB/APB bridge, UART, WDT and TIMER)",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_F_CG": {
                    "description": "To C16 (FB)",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_G_CG": {
                    "description": "To C30, C31 (PDM LEFT/RIGHT Clk, I2S_MASTER clk, LPSD CLK)",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_H_CG": {
                    "description": "To C19 (ADC)<F11>",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_I_CG": {
                    "description": "To C21 (FB)",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  },
                  "CLK_DIVIDER_J_CG": {
                    "description": "To C23 (PMU clk gating control)",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.CLK_DIVIDER_A_CG"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_B": {
              "description": "For Clock 2 (FB, A1 (Including CFGSM))",
              "offset": 304,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_C": {
              "description": "For Clock 8 X4 (FFE X4 clk)",
              "offset": 308,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_D": {
              "description": "For Clock 11 (To M4 peripherals - AHB/APB bridge, UART, WDT and TIMER)",
              "offset": 312,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_H": {
              "description": "For Clock 19 (ADC)",
              "offset": 316,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_J": {
              "description": "For CLK 23 (PMU clk gating control)",
              "offset": 320,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            },
            "CLK_SWITCH_FOR_G": {
              "description": "To C30(PDM LEFT/RIGHT Clk, I2S_MASTER)",
              "offset": 324,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Clock_Source_Selection": {
                    "description": "Choose between High Speed Clock or 32Khz oscillator",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.CRU.children.enums.Clock_Source_Selection_1bit"
                  }
                }
              }
            }
          },
          "enums": {
            "Clock_Source_Selection": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "with_hs_clk": {
                    "description": "Selects the High speed/Divided clock",
                    "value": 0
                  },
                  "with_32khz_clk": {
                    "description": "Selects the 32KHz oscillator",
                    "value": 1
                  }
                }
              }
            },
            "Path_0_Gating_Control": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "stop": {
                    "description": "Clock is stop",
                    "value": 0
                  },
                  "run": {
                    "description": "Clock is runnig",
                    "value": 1
                  }
                }
              }
            },
            "FB_C02_Domain_SW_Reset": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Enable the software reset. FW need to disable it manually",
                    "value": 1
                  }
                }
              }
            },
            "AD0_SW_RESET": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Enable the software reset. FW need to disable it manually",
                    "value": 1
                  }
                }
              }
            },
            "AHBWB_SW_RESET": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Enable the software reset. FW need to disable it manually",
                    "value": 1
                  }
                }
              }
            },
            "SPICLK_ALWAYS_ON": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "always_off": {
                    "description": "Internal SPI Clock (C00) will be gated off if SPI CS is de-asserted even SPI Clock on the PAD is still running.  ",
                    "value": 0
                  },
                  "always_on": {
                    "description": "Internal SPIC Clock (C00) is running if SPI Clock on the PAD is toggling regardless of SPI CS value.",
                    "value": 1
                  }
                }
              }
            },
            "CRU_DEBUG_Select": {
              "size": 4,
              "children": {
                "enum_fields": {
                  "monitor_C00_clock": {
                    "description": "Select clock C00 as the clock to debug",
                    "value": 1
                  },
                  "monitor_C01_clock": {
                    "description": "Select clock C01 as the clock to debug",
                    "value": 2
                  },
                  "monitor_C02_clock": {
                    "description": "Select clock C02 as the clock to debug",
                    "value": 3
                  },
                  "monitor_C08X4_clock": {
                    "description": "Select clock C08X4 as the clock to debug",
                    "value": 4
                  },
                  "monitor_C08X1_clock": {
                    "description": "Select clock C08X1 as the clock to debug",
                    "value": 5
                  },
                  "monitor_C09_clock": {
                    "description": "Select clock C09 as the clock to debug",
                    "value": 6
                  },
                  "monitor_C10_clock": {
                    "description": "Select clock C10 as the clock to debug",
                    "value": 7
                  },
                  "monitor_C11_clock": {
                    "description": "Select clock C11 as the clock to debug",
                    "value": 8
                  },
                  "monitor_CS_clock": {
                    "description": "Select clock CS as the clock to debug",
                    "value": 9
                  },
                  "monitor_C16_clock": {
                    "description": "Select clock C16 as the clock to debug",
                    "value": 10
                  },
                  "monitor_C19_clock": {
                    "description": "Select clock C19 as the clock to debug",
                    "value": 11
                  },
                  "monitor_C20_C32_clock": {
                    "description": "Select clock C20/C32 as the clock to debug",
                    "value": 12
                  },
                  "monitor_C21_clock": {
                    "description": "Select clock C21 as the clock to debug",
                    "value": 13
                  },
                  "monitor_C23_clock": {
                    "description": "Select clock C23 as the clock to debug",
                    "value": 14
                  },
                  "monitor_C30_C31_clock": {
                    "description": "Select clock C30/C31 as the clock to debug",
                    "value": 15
                  }
                }
              }
            },
            "C01_CLK_DIV_CG_ENUM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "stop": {
                    "description": "Clock is stop",
                    "value": 0
                  },
                  "run": {
                    "description": "Clock is runnig",
                    "value": 1
                  }
                }
              }
            },
            "C30_Path_0_Gating_Control": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "stop": {
                    "description": "Clock is stop",
                    "value": 0
                  },
                  "run": {
                    "description": "Clock is runnig",
                    "value": 1
                  }
                }
              }
            },
            "CLK_DIVIDER_A_CG": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "stop": {
                    "description": "Clock is stop",
                    "value": 0
                  },
                  "run": {
                    "description": "Clock is runnig",
                    "value": 1
                  }
                }
              }
            },
            "Clock_Source_Selection_1bit": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "with_hs_clk": {
                    "description": "Selects the High speed/Divided clock",
                    "value": 0
                  },
                  "with_32khz_clk": {
                    "description": "Selects the 32KHz oscillator",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "DMA": {
        "description": "Direct Memory Access peripheral",
        "children": {
          "registers": {
            "DMA_CTRL": {
              "description": "DMA Control : this register is only accessable when the dma or cfg_sm is not selecting the dmas_mux.",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "dma_start": {
                    "description": "write a 1: Enable, write a 0: no affect, reads dma_enb",
                    "offset": 0,
                    "size": 1
                  },
                  "dma_stop": {
                    "description": "write a 1: Stop DMA and disable, clears DMA_DONE, write a 0: no affect, reads dma_done",
                    "offset": 1,
                    "size": 1
                  },
                  "dma_ahb_sel": {
                    "description": "0: DMA to AHB, 1: DMA to header register",
                    "offset": 2,
                    "size": 1
                  },
                  "dma_hsel": {
                    "description": "1: AHB hsel is asserted, 0: not asserted",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "dma_htrans_0": {
                    "description": "1: AHB htrans[0] is asserted, 0: not asserted",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "dma_htrans_1": {
                    "description": "1: AHB htrans[1] is asserted, 0: not asserted",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "dma_hready": {
                    "description": "1: AHB hready is asserted, 0: not asserted",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "dma_xfr_pending": {
                    "description": "1: DMA transfer is pending, 0: nothing pending",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  },
                  "bridge_xfr_pending": {
                    "description": "1: AHB bridge transfer is pending, 0: nothing pending",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMA_DEST_ADDR": {
              "description": "DMA destination address : this register is only accessable when the dma or cfg_sm is not selecting the dmas_mux.",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_dest_addr": {
                    "description": "DMA output data address : this register is only accessable when the dma or cfg_sm is not selecting the dmas_mux.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DMA_XFER_CNT": {
              "description": "DMA transfer count in frames (8 bit) (minus 1) : this register is only accessable when the dma or cfg_sm is not selecting the dmas_mux.",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_xfr_cnt": {
                    "description": "number of frames for DMA to transfer (minus 1).  Max SPI transfer count is 2^16=64k frames",
                    "offset": 0,
                    "size": 26
                  }
                }
              }
            },
            "CFG_FLASH_HEADER": {
              "description": "Header values read from EEPROM : this register is only accessable when the dma or cfg_sm is not selecting the dmas_mux.",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_boot_xfr_size": {
                    "description": "number of double words (8 bytes) for the SPI to transfer (minus 1)",
                    "offset": 0,
                    "size": 16,
                    "access": "read-only"
                  },
                  "dma_spi_clik_divide": {
                    "description": "SPI data clock out divides the ssi_clk (value in bytes*2)",
                    "offset": 16,
                    "size": 8,
                    "access": "read-only"
                  },
                  "dma_device_id": {
                    "description": "Device ID",
                    "offset": 24,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMA_INTR": {
              "description": "DMA interrupts",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "dma_herror": {
                    "description": "1: hresp=1, 0: hresp didn't go to 1, write one to clr",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "rx_data_available": {
                    "description": "1: rx threshold was hit, 0:threshold was not hit.  This is before external mask bit.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "ahb_bridge_fifo_overflow": {
                    "description": "1: A ahb FIFO bridge overflow occurred, 0: no overflow occurred",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_txe_intr": {
                    "description": "SPIM Transmit FIFO empty",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_txo_intr": {
                    "description": "SPIM Transmit FIFO overflow",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_rxf_intr": {
                    "description": "SPIM Receive FIFO threshold",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_rxo_intr": {
                    "description": "SPIM Receive FIFO overflow",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_rxu_intr": {
                    "description": "SPIM Receive FIFO underflow",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  },
                  "spim_ssi_mst_intr": {
                    "description": "SPIM master interrupt",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMA_INTR_MASK": {
              "description": "DMA interrupt mask",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "dma_herror_mask": {
                    "description": "1: disable interrupt, 0:enable interrupt",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.DMA.children.enums.dma_herror_mask"
                  },
                  "rx_data_available_mask": {
                    "description": "1: mask rx data available, 0:don't mask",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.DMA.children.enums.dma_herror_mask"
                  },
                  "ahb_bridge_fifo_overflow_mask": {
                    "description": "1: Mask the ahb FIFO bridge overflow, 0: interrupts are enabled",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.DMA.children.enums.dma_herror_mask"
                  }
                }
              }
            },
            "CFG_MACHINE_ST_DELAY": {
              "description": "This is the delay value used in the config state machine.  It is used for both deep sleep wakeup delay and between retries.",
              "offset": 0,
              "size": 32,
              "reset_value": 500,
              "reset_mask": 4095,
              "children": {
                "fields": {
                  "delay_reg": {
                    "description": "Delay value used in the config SM state machine.  This is clocked at the APB pclk frequency. Default to decimal 500.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            }
          },
          "enums": {
            "dma_herror_mask": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "ExtRegsFFE": {
        "description": "Flexible Fusion Engine registers",
        "children": {
          "registers": {
            "ADDR": {
              "description": "Wishbone master address selection",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "Addr": {
                    "description": "Slave address register via Wishbone master",
                    "offset": 0,
                    "size": 3
                  },
                  "slave_sel": {
                    "description": "MSB to select which which slave accessed by WB master",
                    "offset": 6,
                    "size": 2,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.slave_sel"
                  }
                }
              }
            },
            "WDATA": {
              "description": "I2C slave data register via WishBone master",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDATA": {
                    "description": "I2C slave data via WB",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "CSR": {
              "description": "Control and status register",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "wb_ms_start": {
                    "description": "Wishbone master start transactions. This bit is self clearing.",
                    "offset": 0,
                    "size": 1
                  },
                  "wb_ms_wen": {
                    "description": "Wishbone master write enable.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.wb_ms_wen"
                  },
                  "mux_wb_sm": {
                    "description": "Mux select between SM and WB masters.",
                    "offset": 2,
                    "size": 1,
                    "access": "write-only",
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.mux_wb_sm"
                  },
                  "BUSY": {
                    "description": "Indicates if the Wishbone is busy",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "OVFL": {
                    "description": "Indicates if there's a FFE push operation overflow",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "i2c0_mux_sel": {
                    "description": "I2C_0 wishbone control mux select",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.i2c0_mux_sel"
                  },
                  "i2c1_mux_sel": {
                    "description": "I2C_1 wishbone control mux select",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.i2c0_mux_sel"
                  },
                  "spi0_mux_sel": {
                    "description": "spi_0 wishbone control mux select",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.i2c0_mux_sel"
                  }
                }
              }
            },
            "RDATA": {
              "description": "Read data from I2C to Wishbone master is registered",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "RDATA": {
                    "description": "Read data from I2C to Wishbone master is registered",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "SRAM_TEST_REG1": {
              "description": "SRAM Test control register 1",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SM1_TEST1": {
                    "description": "SM1_TEST1 control for FFE SRAM",
                    "offset": 0,
                    "size": 1
                  },
                  "SM1_RME": {
                    "description": "SM1_RME control for FFE SRAM",
                    "offset": 1,
                    "size": 1
                  },
                  "SM1_RM": {
                    "description": "SM1_RM control for FFE SRAM",
                    "offset": 2,
                    "size": 4
                  },
                  "SM0_TEST1": {
                    "description": "SM0_TEST1 control for FFE SRAM",
                    "offset": 6,
                    "size": 1
                  },
                  "SM0_RME": {
                    "description": "SM0_RME control for FFE SRAM",
                    "offset": 7,
                    "size": 1
                  },
                  "SM0_RM": {
                    "description": "SM0_RM control for FFE SRAM",
                    "offset": 8,
                    "size": 4
                  },
                  "CM8k_TEST1": {
                    "description": "CM8k_TEST1 control for FFE SRAM",
                    "offset": 12,
                    "size": 1
                  },
                  "CM8k_RME": {
                    "description": "CM8k_RME control for FFE SRAM",
                    "offset": 13,
                    "size": 1
                  },
                  "CM8k_RM": {
                    "description": "CM8k_RM control for FFE SRAM",
                    "offset": 14,
                    "size": 4
                  },
                  "CM2k_TEST1": {
                    "description": "CM2k_TEST1 control for FFE SRAM",
                    "offset": 18,
                    "size": 1
                  },
                  "CM2k_RME": {
                    "description": "CM2k_RME control for FFE SRAM",
                    "offset": 19,
                    "size": 1
                  },
                  "CM2k_RM": {
                    "description": "CM2k_RM control for FFE SRAM",
                    "offset": 20,
                    "size": 4
                  },
                  "DM0_TEST1": {
                    "description": "DM0_TEST1 control for FFE SRAM",
                    "offset": 24,
                    "size": 1
                  },
                  "DM0_RME": {
                    "description": "DM0_RME control for FFE SRAM",
                    "offset": 25,
                    "size": 1
                  },
                  "DM0_RM": {
                    "description": "DM0_RM control for FFE SRAM",
                    "offset": 26,
                    "size": 4
                  },
                  "DM1_TEST1": {
                    "description": "DM1_TEST1 control for FFE SRAM",
                    "offset": 30,
                    "size": 1
                  },
                  "DM1_RME": {
                    "description": "DM1_RME control for FFE SRAM",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "SRAM_TEST_REG2": {
              "description": "SRAM Test control register 2",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "DM1_RM": {
                    "description": "DM0_RM control for FFE SRAM",
                    "offset": 0,
                    "size": 4
                  },
                  "DM2_TEST1": {
                    "description": "DM2_TEST1 control for FFE SRAM",
                    "offset": 4,
                    "size": 1
                  },
                  "DM2_RME": {
                    "description": "DM2_RME control for FFE SRAM",
                    "offset": 5,
                    "size": 1
                  },
                  "DM2_RM": {
                    "description": "DM0_RM control for FFE SRAM",
                    "offset": 6,
                    "size": 4
                  },
                  "DM3_TEST1": {
                    "description": "DM3_TEST1 control for FFE SRAM",
                    "offset": 10,
                    "size": 1
                  },
                  "DM3_RME": {
                    "description": "DM3_RME control for FFE SRAM",
                    "offset": 11,
                    "size": 1
                  },
                  "DM3_RM": {
                    "description": "DM3_RM control for FFE SRAM",
                    "offset": 12,
                    "size": 4
                  }
                }
              }
            },
            "FFE_CSR": {
              "description": "Flexible Fusion Engine status and control register",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "i2c2_sel": {
                    "description": "Select wich i2c is taken as i2c",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.i2c2_sel"
                  },
                  "i2c0_dyn_pullup_en": {
                    "description": "i2c0 dynamic pull-up enable",
                    "offset": 1,
                    "size": 1
                  },
                  "i2c1_dyn_pullup_en": {
                    "description": "i2c1 dynamic pull-up enable",
                    "offset": 2,
                    "size": 1
                  },
                  "i2c2_dyn_pullup_en": {
                    "description": "i2c2 dynamic pull-up enable",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "FFE_DBG_COMBINED": {
              "description": "Combined Flexible Fusion Engine debug signals",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "sm0_SM_debug": {
                    "description": "Sensor memory 0 debug signals",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  },
                  "sm1_SM_debug": {
                    "description": "Sensor memory 1 debug signals",
                    "offset": 8,
                    "size": 8,
                    "access": "read-only"
                  },
                  "ffe0_debug": {
                    "description": "ffe0 debug signals",
                    "offset": 16,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "CMD": {
              "description": "Commands for the Flexible Fusion Engine",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "RUN_FFE0_ONCE": {
                    "description": "When a '1' is written to this location, causes the FFE to execute one complete run of its algorithm; reads as 0",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  },
                  "RUN_FFE1": {
                    "description": "When a '1' is written to this location, causes the FFE1 to start; reads as 0",
                    "offset": 1,
                    "size": 1,
                    "access": "write-only"
                  },
                  "RUN_SM0_ONCE": {
                    "description": "When a '1' is written to this location, causes the SM0 to run once; reads as 0",
                    "offset": 2,
                    "size": 1,
                    "access": "write-only"
                  },
                  "RUN_SM1_ONCE": {
                    "description": "When a '1' is written to this location, causes the SM1 to run once; reads as 0",
                    "offset": 3,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "INTERRUPT": {
              "description": "Varied interrupt configurations",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 8388595,
              "children": {
                "fields": {
                  "SM_MULT_WR_INTR": {
                    "description": "This bit is set when an FFE tries to write to more that one FIFO simultaneously.  The FIFO PUSH value must be one hot, with only one pushd asserted.",
                    "offset": 0,
                    "size": 1
                  },
                  "PFE0_OVERRUN": {
                    "description": "This bit is set when the FFE does not complete the algorithm by the time the next sample period begins. This bit can only be cleared by issuing a device reset (software reset, or global reset via the Reset pin).",
                    "offset": 1,
                    "size": 1
                  },
                  "FFE0_SM1_OBERRUN": {
                    "description": "This bit is set when the SM does not complete the algorithm by the time the next sample period begins. This bit can only be cleared by issuing a device reset (software reset, or global reset via the Reset pin).",
                    "offset": 4,
                    "size": 1
                  },
                  "FFE0_SM0_OBERRUN": {
                    "description": "This bit is set when the SM does not complete the algorithm by the time the next sample period begins. This bit can only be cleared by issuing a device reset (software reset, or global reset via the Reset pin).",
                    "offset": 5,
                    "size": 1
                  },
                  "I2C_MS_1_ERROR": {
                    "description": "This bit is set when the I2C Master receives a NACK when transmitting a device address. The I2C Master is used by the Sensor Manager to retrieve sensor data.",
                    "offset": 6,
                    "size": 1
                  },
                  "I2C_MS_0_ERROR": {
                    "description": "This bit is set when the I2C Master receives a NACK when transmitting a device address. The I2C Master is used by the Sensor Manager to retrieve sensor data.",
                    "offset": 7,
                    "size": 1
                  },
                  "CM_8k_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 8,
                    "size": 1
                  },
                  "DM0_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 9,
                    "size": 1
                  },
                  "DM1_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 10,
                    "size": 1
                  },
                  "SM0_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 11,
                    "size": 1
                  },
                  "SM1_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 12,
                    "size": 1
                  },
                  "FFE0_BP_MATCH_INTR": {
                    "description": "This bit is set when there is a break point match in FFE0",
                    "offset": 13,
                    "size": 1
                  },
                  "FFE1_OVERRUN": {
                    "description": "This bit is set when the FFE does not complete the algorithm by the time the next sample period begins. ",
                    "offset": 14,
                    "size": 1
                  },
                  "PKFB_OVF_INTR": {
                    "description": "This bit is set when the FFE pushes to the PKFB causing an overflow",
                    "offset": 15,
                    "size": 1
                  },
                  "SM0_BP_MATCH_INTR": {
                    "description": "This bit is set when there is a break point match in SM0",
                    "offset": 16,
                    "size": 1
                  },
                  "SM1_BP_MATCH_INTR": {
                    "description": "This bit is set when there is a break point match in SM1",
                    "offset": 17,
                    "size": 1
                  },
                  "SPI_MS_INTR": {
                    "description": "This bit is set when there is an interrupt request from SPI_MS for sensor",
                    "offset": 18,
                    "size": 1
                  },
                  "CM_2k_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 19,
                    "size": 1
                  },
                  "DM2_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 20,
                    "size": 1
                  },
                  "DM3_LP_INTR": {
                    "description": "This bit is set when there is an access to the memory while it is in low power (deep sleep or shut down)",
                    "offset": 21,
                    "size": 1
                  },
                  "ahbm_bus_error_INTR": {
                    "description": "This bit is set when there is a bus error on the AHB bus (HRESP=1).",
                    "offset": 22,
                    "size": 1
                  }
                }
              }
            },
            "INTERRUPT_EN": {
              "description": "Control the masking for different Flexible Fusion Engine interrupts",
              "offset": 268,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 8388595,
              "children": {
                "fields": {
                  "SM_MULT_WR_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "FFE0_OVERRUN_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "FFE0_SM1_OVERRUN_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "FFE0_SM0_OVERRUN_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "I2C_MS_1_ERROR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "I2C_MS_0_ERROR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "CM_8k_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "DM0_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "DM1_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "SM0_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "SM1_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "FFE0_BP_MATCH_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "FFE1_OVERRUN_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "PKFB_OVF_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "SM0_BP_MATCH_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 16,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "SM1_BP_MATCH_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 17,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "SPI_MS_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 18,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "CM_2k_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 19,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "DM2_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 20,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "DM3_LP_INTR_EN": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 21,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  },
                  "ahbm_bus_error_intr_en": {
                    "description": "Set to enable the interrupt, leave cleared to mask",
                    "offset": 22,
                    "size": 1,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.SM_MULT_WR_INTR_EN"
                  }
                }
              }
            },
            "STATUS": {
              "description": "FFE status register",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SM0_BUSY": {
                    "description": "This bit is set whenever the Sensor Manager is busy.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "SM1_BUSY": {
                    "description": "This bit is set whenever the Sensor Manager is busy.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FFE0_BUSY": {
                    "description": "This bit is set whenever the FFE0 is busy.",
                    "offset": 2,
                    "size": 1
                  },
                  "FFE1_BUSY": {
                    "description": "This bit is set whenever the FFE1 is busy.",
                    "offset": 3,
                    "size": 1
                  },
                  "FFE0_BG_FLAG": {
                    "description": "This is the ffe0 background thread status",
                    "offset": 4,
                    "size": 1
                  },
                  "FFE0_FG_FLAG": {
                    "description": "This is the ffe0 background thread status",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "MAILBOX_TO_FFE0": {
              "description": "Mailbox register to the FFE. This register can be set by system software to send a message or configuration information to the FFE as it runs its algorithm, thus affecting the algorithm while it is running. A special instruction may be used in the algorithm to read this mailbox register.",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "MAILBOX_TO_FFE0": {
                    "description": "Mailbox register to the FFE. This register can be set by system software to send a message or configuration information to the FFE as it runs its algorithm, thus affecting the algorithm while it is running. A special instruction may be used in the algorithm to read this mailbox register.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "SM_RUNTIME_ADDR": {
              "description": "SM0/SM1 run time address",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "SM_RUNTIME_ADDR": {
                    "description": "SM0/SM1 run time address",
                    "offset": 0,
                    "size": 10
                  }
                }
              }
            },
            "SM0_RUNTIME_ADDR_CTRL": {
              "description": "Used to toggle signal used to signal when a new value has been written.",
              "offset": 292,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SM0_RUNTIME_ADDR_CTRL": {
                    "description": "Write a '1' to Toggle signal used to signal when a new value has been written",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SM1_RUNTIME_ADDR_CTRL": {
              "description": "Used to toggle signal used to signal when a new value has been written.",
              "offset": 296,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SM1_RUNTIME_ADDR_CTRL": {
                    "description": "Write a '1' to Toggle signal used to signal when a new value has been written",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SM0_RUNTIME_ADDR_CUR": {
              "description": "SM current program counter",
              "offset": 300,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "SM0_RUNTIME_ADDR_CUR": {
                    "description": "SM current program counter",
                    "offset": 0,
                    "size": 10
                  }
                }
              }
            },
            "SM1_RUNTIME_ADDR_CUR": {
              "description": "SM current program counter",
              "offset": 304,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "SM1_RUNTIME_ADDR_CUR": {
                    "description": "SM current program counter",
                    "offset": 0,
                    "size": 10
                  }
                }
              }
            },
            "SM0_DEBUG_SEL": {
              "description": "SM Debug selection",
              "offset": 320,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "SM0_DEBUG_SEL": {
                    "description": "SM Debug selection",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "SM1_DEBUG_SEL": {
              "description": "SM Debug selection",
              "offset": 324,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "SM1_DEBUG_SEL": {
                    "description": "SM Debug selection",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "FFE_DEBUG_SEL": {
              "description": "Debug Selection",
              "offset": 328,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16777215,
              "children": {
                "fields": {
                  "FFE_DEBUG_SEL_SM0": {
                    "description": "SM0 LS debug slection",
                    "offset": 0,
                    "size": 8
                  },
                  "FFE_DEBUG_SEL_SM1": {
                    "description": "SM1 LS debug slection",
                    "offset": 8,
                    "size": 8
                  },
                  "FFE_DEBUG_SEL_FFE0": {
                    "description": "FFE0 LS debug slection",
                    "offset": 16,
                    "size": 8
                  },
                  "FFE_TOP_DEBUG_SEL": {
                    "description": "FFE_TOP_MS debug slection",
                    "offset": 24,
                    "size": 2,
                    "enum": "types.peripherals.ExtRegsFFE.children.enums.FFE_TOP_DEBUG_SEL"
                  }
                }
              }
            },
            "FFE0_BREAK_POINT_CFG": {
              "description": "Break point control",
              "offset": 336,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "FFE0_BP_EN": {
                    "description": "break point execution -- 0 : Disabled -- 1 : Enabled ",
                    "offset": 0,
                    "size": 1
                  },
                  "FFE0_FORCE_STOP": {
                    "description": "This causes the FFE to immediately halt execution.",
                    "offset": 1,
                    "size": 1
                  },
                  "FFE0_BreakPt_Sw-Brk": {
                    "description": "Causes the signal to toggle when written with a '1' in this bit position.",
                    "offset": 1,
                    "size": 1
                  }
                }
              }
            },
            "FFE0_BREAK_POINT_CONT": {
              "description": "Seems to be another breakpoint control register",
              "offset": 340,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "FFE0_BP_CONT": {
                    "description": "This restarts FFE code execution following a pause due to reaching a 'break point'.",
                    "offset": 0,
                    "size": 1
                  },
                  "SM0_BP_CONT": {
                    "description": "This is a single, host controlled input toggle signal, Break Point Match Continue. Software uses this toggle signal to resume code execution from the Break Point condition.",
                    "offset": 1,
                    "size": 1
                  },
                  "SM1_BP_CONT": {
                    "description": "This is a single, host controlled input toggle signal, Break Point Match Continue. Software uses this toggle signal to resume code execution from the Break Point condition.",
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "FFE0_BREAK_POINT_STAT": {
              "description": "FFE break point status register",
              "offset": 344,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "FFE0_BP_MATCH": {
                    "description": "This signals that a 'break point' has been reached and FFE execution is paused.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "SM0_BP_MATCH": {
                    "description": "SM Break Point Match signal output to the host that notifies the host that the break point condition has been detected.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "SM1_BP_MATCH": {
                    "description": "SM Break Point Match signal output to the host that notifies the host that the break point condition has been detected.",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "FFE0_BP_XPC_0": {
              "description": "These registers hold the xPC (program counter) address 'break points'.",
              "offset": 352,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16383,
              "children": {
                "fields": {
                  "FFE0_BP_XPC_0": {
                    "description": "These registers hold the xPC (program counter) address 'break points'.",
                    "offset": 0,
                    "size": 14
                  }
                }
              }
            },
            "FFE0_BP_XPC_1": {
              "description": "These registers hold the xPC (program counter) address 'break points'.",
              "offset": 356,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16383,
              "children": {
                "fields": {
                  "FFE0_BP_XPC_1": {
                    "description": "These registers hold the xPC (program counter) address 'break points'.",
                    "offset": 0,
                    "size": 14
                  }
                }
              }
            },
            "FFE0_BP_XPC_2": {
              "description": "These registers hold the xPC (program counter) address 'break points'.",
              "offset": 360,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16383,
              "children": {
                "fields": {
                  "FFE0_BP_XPC_2": {
                    "description": "These registers hold the xPC (program counter) address 'break points'.",
                    "offset": 0,
                    "size": 14
                  }
                }
              }
            },
            "FFE0_BP_XPC_3": {
              "description": "These registers hold the xPC (program counter) address 'break points'.",
              "offset": 364,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16383,
              "children": {
                "fields": {
                  "FFE0_BP_XPC_3": {
                    "description": "These registers hold the xPC (program counter) address 'break points'.",
                    "offset": 0,
                    "size": 14
                  }
                }
              }
            }
          },
          "enums": {
            "slave_sel": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "i2c_0": {
                    "description": "Select i2c_0 as the sensor that will be accessed by the Wishbone Master",
                    "value": 0
                  },
                  "i2c_1": {
                    "description": "Select i2c_1 as the sensor that will be accessed by the Wishbone Master",
                    "value": 1
                  },
                  "spi_0": {
                    "description": "Select spi_0 as the sensor that will be accessed by the Wishbone Master",
                    "value": 2
                  }
                }
              }
            },
            "wb_ms_wen": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "read": {
                    "description": "read",
                    "value": 0
                  },
                  "write": {
                    "description": "write",
                    "value": 1
                  }
                }
              }
            },
            "mux_wb_sm": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "sm_wishbone_master": {
                    "description": "Select SM WB Master.",
                    "value": 0
                  },
                  "wishbone_master": {
                    "description": "Select WB Master.",
                    "value": 1
                  }
                }
              }
            },
            "i2c0_mux_sel": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "sm1_as_controller": {
                    "description": "Let SM1 control the port.",
                    "value": 0
                  },
                  "wb_master_as_controller": {
                    "description": "Let Wishbone Master control the port",
                    "value": 1
                  }
                }
              }
            },
            "i2c2_sel": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "i2c1": {
                    "description": "Select i2c1 as i2c2",
                    "value": 0
                  },
                  "i2c2": {
                    "description": "Select i2c2 as i2c2",
                    "value": 1
                  }
                }
              }
            },
            "SM_MULT_WR_INTR_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "FFE_TOP_DEBUG_SEL": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "sm0": {
                    "description": "Select sm0",
                    "value": 0
                  },
                  "sm1": {
                    "description": "Select sm1",
                    "value": 1
                  },
                  "ffe0": {
                    "description": "Select ffe0",
                    "value": 2
                  }
                }
              }
            }
          }
        }
      },
      "I2S_Slave": {
        "description": "I2S Slave",
        "children": {
          "registers": {
            "IER": {
              "description": "I2S Enable Register",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "IEN": {
                    "description": "DW_apb_i2s_enable. A disable on this bit overrides any other block or channel enables and flushes all FIFOs.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.IEN"
                  }
                }
              }
            },
            "ITER": {
              "description": "I2S Transmitter Block Enable Register",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXEN": {
                    "description": "Transmitter block enable. A disable on this bit overrides any individual transmit channel enables.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.TXEN"
                  }
                }
              }
            },
            "TXFFR": {
              "description": "Transmitter Block FIFO Reset Register",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXFFR": {
                    "description": "Transmitter FIFO Reset. Writing a 1 to this register flushes all the TX FIFOs (this is a self clearing bit). The Transmitter Block must be disabled prior to writing this bit.",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "LTHR0": {
              "description": "Left Transmit Holding Register",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "LTHR0": {
                    "description": "The left stereo data to be transmitted serially through the transmit channel output (sdox) is written through this register. Writing is a two-stage process: (1) A write to this register passes the left stereo sample to the transmitter. (2) This MUST be followed by writing the right stereo sample to the RTHRx register. Data should only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.",
                    "offset": 0,
                    "size": 32,
                    "access": "write-only"
                  }
                }
              }
            },
            "RTHR0": {
              "description": "Right Transmit Holding Register ",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RTHR0": {
                    "description": "The right stereo data to be transmitted serially through the transmit channel output (sdox) is written through this register. Writing is a two-stage process: (1) A left stereo sample MUST first be written to the LTHRx register. (2) A write to this register passes the right stereo sample to the transmitter. Data should only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.",
                    "offset": 0,
                    "size": 32,
                    "access": "write-only"
                  }
                }
              }
            },
            "TER0": {
              "description": "Transmit Enable Register",
              "offset": 44,
              "size": 32,
              "reset_value": 1,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXCHEN0": {
                    "description": "Transmit channel enable. This bit enables/disables a transmit channel, independently of all other channels. On enable, the channel begins transmitting on the next left stereo cycle. A global disable of DW_apb_i2s (IER[0] = 0) or Transmitter block (ITER[0] =0) overrides this value.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.TXCHEN0"
                  }
                }
              }
            },
            "TCR0": {
              "description": "Transmit Configuration Register ",
              "offset": 52,
              "size": 32,
              "reset_value": 2,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "WLEN": {
                    "description": "These bits are used to program the data resolution of the transmitter and ensures the MSB of the data is transmitted first. Programmed resolution must be less than or equal to `I2S_TX_WORDSIZE_x`. If the selected resolution is greater than `I2S_TX_WORDSIZE_x`, the transmit channel defaults back to `I2S_TX_WORDSIZE_RESET_x` value. The channel must be disabled prior to any changes in this value (`TERx[0] = 0`).",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.I2S_Slave.children.enums.WLEN"
                  }
                }
              }
            },
            "ISR0": {
              "description": "Interrupt Status Register",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 48,
              "children": {
                "fields": {
                  "TXFE": {
                    "description": "Status of Transmit Empty Trigger interrupt. TX FIFO is empty.",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.TXFE"
                  },
                  "TXFO": {
                    "description": "Status of Data Overrun interrupt for the TX channel. Attempt to write to full TX FIFO. Dependencies: I2S_TX_CHANNELS > x, where x is the number of transmit channel.",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.TXFO"
                  }
                }
              }
            },
            "IMR0": {
              "description": "Interrupt Mask Register",
              "offset": 60,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 48,
              "children": {
                "fields": {
                  "RXFOM": {
                    "description": "Masks TX FIFO Overrun interrupt.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.RXFOM"
                  },
                  "TXFOM": {
                    "description": "Masks TX FIFO Empty interrupt.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.RXFOM"
                  }
                }
              }
            },
            "TOR0": {
              "description": "Transmit Overrun Register",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXCHO": {
                    "description": "Read this bit to clear the TX FIFO Data Overrun interrupt.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "TFCR0": {
              "description": "Transmit FIFO Configuration Register",
              "offset": 76,
              "size": 32,
              "reset_value": 4,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "TXCHET": {
                    "description": "Transmit Channel Empty Trigger. These bits program the trigger level in the TX FIFO at which the Empty Threshold Reached Interrupt is generated. Trigger Level = `TXCHET` `TXCHET` values: 0 to (`I2S_TX_FIFO_x  1`) If an illegal value is programmed, these bits saturate to `(I2S_TX_FIFO_x  1)`. The channel must be disabled prior to any changes in this value (that is, `TERx[0] = 0`).",
                    "offset": 0,
                    "size": 4
                  }
                }
              }
            },
            "TFF0": {
              "description": "Transmit FIFO Flush",
              "offset": 84,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TXCHFR": {
                    "description": "Transmit Channel FIFO Reset. Writing a 1 to this register flushes channels TX FIFO. (This is a self clearing bit.) TX channel or block must be disabled prior to writing to this bit.",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "TXDMA": {
              "description": "Transmitter Block DMA Register",
              "offset": 456,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TXDMA": {
                    "description": "Transmitter Block DMA Register. This register can be used to cycle repeatedly through the enabled Transmit channels (from lowest numbered to highest) to allow writing of stereo data pairs",
                    "offset": 0,
                    "size": 32,
                    "access": "write-only"
                  }
                }
              }
            },
            "RTXDMA": {
              "description": "Reset Transmitter Block DMA Register",
              "offset": 460,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "RTXDMA": {
                    "description": "Reset Transmitter Block DMA Register. Writing a 1 to this self-clearing register resets the TXDMA register mid-cycle to point to the lowest enabled Transmit channel. NOTE: This register has no effect in the middle of a stereo pair write (such as,when left stereo data has been written but not right stereo data)",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "I2S_COMP_PARAM_1": {
              "description": "Component Parameter Register 1",
              "offset": 500,
              "size": 32,
              "reset_value": 298,
              "reset_mask": 524287,
              "children": {
                "fields": {
                  "APB_DATA_WIDTH": {
                    "description": "Data width of the APB",
                    "offset": 0,
                    "size": 2,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.APB_DATA_WIDTH"
                  },
                  "I2S_FIFO_DEPTH_GLOBAL": {
                    "description": "Indicates the value of I2S_FIFO_DEPTH_GLOBAL",
                    "offset": 2,
                    "size": 2,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.I2S_FIFO_DEPTH_GLOBAL"
                  },
                  "I2S_MODE_EN": {
                    "description": "Enabled mode for the I2S peripheral",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.I2S_MODE_EN"
                  },
                  "I2S_TRANSMITTER_BLOCK": {
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "I2S_TX_CHANNELS": {
                    "description": "Indicates how many I2S TX channels are active",
                    "offset": 9,
                    "size": 2,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.I2S_TX_CHANNELS"
                  },
                  "I2S_TX_WORDSIZE_0": {
                    "description": "Indicates the wordsize of I2S TX packets",
                    "offset": 16,
                    "size": 3,
                    "access": "read-only",
                    "enum": "types.peripherals.I2S_Slave.children.enums.I2S_TX_WORDSIZE_0"
                  }
                }
              }
            },
            "I2S_COMP_VERSION": {
              "description": "Component version of the I2S peripheral.",
              "offset": 504,
              "size": 32,
              "reset_value": 825243690,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "I2S_COMP_VERSION": {
                    "description": "Component version of the I2S peripheral.",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "I2S_COMP_TYPE": {
              "description": "Component type of the I2S peripheral.",
              "offset": 508,
              "size": 32,
              "reset_value": 1146552736,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "I2S_COMP_TYPE": {
                    "description": "Component type of the I2S peripheral.",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "I2S_STEREO_EN": {
              "description": "Sound channel mode (mono or stereo)",
              "offset": 1016,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "I2S_STEREO_EN": {
                    "description": "Select between mono or stereo modes",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.I2S_Slave.children.enums.I2S_STEREO_EN"
                  }
                }
              }
            }
          },
          "enums": {
            "IEN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Enable DW_APB_I2S.",
                    "value": 0
                  },
                  "enable": {
                    "description": "Disable DW_APB_I2S.",
                    "value": 1
                  }
                }
              }
            },
            "TXEN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Disable the transmitter.",
                    "value": 0
                  },
                  "enable": {
                    "description": "Enable the transmitter.",
                    "value": 1
                  }
                }
              }
            },
            "TXCHEN0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Disable the transmit channel.",
                    "value": 0
                  },
                  "enable": {
                    "description": "Enable the transmit channel.",
                    "value": 1
                  }
                }
              }
            },
            "WLEN": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "ignore_word_len": {
                    "description": "Ignore word length.",
                    "value": 0
                  },
                  "word_12bit": {
                    "description": "12 bit resolution.",
                    "value": 1
                  },
                  "word_16bit": {
                    "description": "16 bit resolution.",
                    "value": 2
                  },
                  "word_20bit": {
                    "description": "20 bit resolution.",
                    "value": 3
                  },
                  "word_24bit": {
                    "description": "24 bit resolution.",
                    "value": 4
                  },
                  "word_32bit": {
                    "description": "32 bit resolution.",
                    "value": 5
                  }
                }
              }
            },
            "TXFE": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "write_valid": {
                    "description": "TX FIFO write valid.",
                    "value": 0
                  },
                  "write_overrun": {
                    "description": "TX FIFO write overrun.",
                    "value": 1
                  }
                }
              }
            },
            "TXFO": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "trigger_not_reached": {
                    "description": "Trigger level not reached.",
                    "value": 0
                  },
                  "trigger_reached": {
                    "description": "Trigger level reached.",
                    "value": 1
                  }
                }
              }
            },
            "RXFOM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "unmask": {
                    "description": "Unmask the interrupt",
                    "value": 0
                  },
                  "mask": {
                    "description": "Mask the interrupt",
                    "value": 1
                  }
                }
              }
            },
            "APB_DATA_WIDTH": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "x8bit": {
                    "description": "APB data width is 8 bit",
                    "value": 0
                  },
                  "x16bit": {
                    "description": "APB data width is 16 bit",
                    "value": 1
                  },
                  "x32bit": {
                    "description": "APB data width is 32 bit",
                    "value": 2
                  }
                }
              }
            },
            "I2S_FIFO_DEPTH_GLOBAL": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "depth_2": {
                    "description": "I2S_FIFO_DEPTH_GLOBAL equals 2",
                    "value": 0
                  },
                  "depth_4": {
                    "description": "I2S_FIFO_DEPTH_GLOBAL equals 4",
                    "value": 1
                  },
                  "depth_8": {
                    "description": "I2S_FIFO_DEPTH_GLOBAL equals 8",
                    "value": 2
                  },
                  "depth_16": {
                    "description": "I2S_FIFO_DEPTH_GLOBAL equals 16",
                    "value": 3
                  }
                }
              }
            },
            "I2S_MODE_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "slave": {
                    "description": "I2S operating in slave mode.",
                    "value": 0
                  },
                  "master": {
                    "description": "I2S operating in master mode",
                    "value": 1
                  }
                }
              }
            },
            "I2S_TX_CHANNELS": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "x1_channel": {
                    "description": "1 TX channel.",
                    "value": 0
                  },
                  "x2_channel": {
                    "description": "2 TX channel.",
                    "value": 1
                  },
                  "x3_channel": {
                    "description": "3 TX channel.",
                    "value": 2
                  },
                  "x4_channel": {
                    "description": "4 TX channel.",
                    "value": 3
                  }
                }
              }
            },
            "I2S_TX_WORDSIZE_0": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "x12bit": {
                    "description": "TX configured with 12bit wordsize",
                    "value": 0
                  },
                  "x16bit": {
                    "description": "TX configured with 16bit wordsize",
                    "value": 1
                  },
                  "x20bit": {
                    "description": "TX configured with 20bit wordsize",
                    "value": 2
                  },
                  "x24bit": {
                    "description": "TX configured with 24bit wordsize",
                    "value": 3
                  },
                  "x32bit": {
                    "description": "TX configured with 32bit wordsize",
                    "value": 4
                  }
                }
              }
            },
            "I2S_STEREO_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mono": {
                    "description": "Configure I2S for monoaural sound reproduction",
                    "value": 0
                  },
                  "stereo": {
                    "description": "Configure I2S for stereo sound reproduction",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "INTR_CTRL": {
        "description": "Interrupt Controller",
        "children": {
          "registers": {
            "GPIO_INTR": {
              "description": "Indicators of interrupt triggers detected",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_0. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 0,
                    "size": 1
                  },
                  "GPIO_1_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_1. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 1,
                    "size": 1
                  },
                  "GPIO_2_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_2. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 2,
                    "size": 1
                  },
                  "GPIO_3_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_3. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 3,
                    "size": 1
                  },
                  "GPIO_4_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_4. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 4,
                    "size": 1
                  },
                  "GPIO_5_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_5. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 5,
                    "size": 1
                  },
                  "GPIO_6_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_6. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 6,
                    "size": 1
                  },
                  "GPIO_7_INTR": {
                    "description": "Active high edge interrupt detected for GPIO_7. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 7,
                    "size": 1
                  }
                }
              }
            },
            "GPIO_INTR_RAW": {
              "description": "GPIO raw interrupt indicators",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_0. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_1_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_1. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_2_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_2. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_3_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_3. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_4_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_4. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_5_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_5. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_6_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_6. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "GPIO_7_INTR_RAW": {
                    "description": "Raw interrupt for GPIO_7. This register will reflect the value of the IO regardless of the type/polarity",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "GPIO_INTR_TYPE": {
              "description": "Indicators of interrupt trigger types",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_O_INTR_TYPE": {
                    "description": "GPIO_0 interrupt type {0: level, 1: edge}",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_1_INTR_TYPE": {
                    "description": "GPIO_1 interrupt type {0: level, 1: edge}",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_2_INTR_TYPE": {
                    "description": "GPIO_2 interrupt type {0: level, 1: edge}",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_3_INTR_TYPE": {
                    "description": "GPIO_3 interrupt type {0: level, 1: edge}",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_4_INTR_TYPE": {
                    "description": "GPIO_4 interrupt type {0: level, 1: edge}",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_5_INTR_TYPE": {
                    "description": "GPIO_5 interrupt type {0: level, 1: edge}",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_6_INTR_TYPE": {
                    "description": "GPIO_6 interrupt type {0: level, 1: edge}",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  },
                  "GPIO_7_INTR_TYPE": {
                    "description": "GPIO_7 interrupt type {0: level, 1: edge}",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_O_INTR_TYPE"
                  }
                }
              }
            },
            "GPIO_INTR_POL": {
              "description": "Indicators of interrupt trigger polarities (will depend on the type of interrupt)",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR_POL": {
                    "description": "GPIO_0 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_1_INTR_POL": {
                    "description": "GPIO_1 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_2_INTR_POL": {
                    "description": "GPIO_2 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_3_INTR_POL": {
                    "description": "GPIO_3 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_4_INTR_POL": {
                    "description": "GPIO_4 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_5_INTR_POL": {
                    "description": "GPIO_5 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_6_INTR_POL": {
                    "description": "GPIO_6 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  },
                  "GPIO_7_INTR_POL": {
                    "description": "GPIO_7 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_POL"
                  }
                }
              }
            },
            "GPIO_INTR_EN_AP": {
              "description": "GPIO interrupt enable for AP",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR_EN_AP": {
                    "description": "GPIO_0 interrupt enable for AP",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_1_INTR_EN_AP": {
                    "description": "GPIO_1 interrupt enable for AP",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_2_INTR_EN_AP": {
                    "description": "GPIO_2 interrupt enable for AP",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_3_INTR_EN_AP": {
                    "description": "GPIO_3 interrupt enable for AP",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_4_INTR_EN_AP": {
                    "description": "GPIO_4 interrupt enable for AP",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_5_INTR_EN_AP": {
                    "description": "GPIO_5 interrupt enable for AP",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_6_INTR_EN_AP": {
                    "description": "GPIO_6 interrupt enable for AP",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  },
                  "GPIO_7_INTR_EN_AP": {
                    "description": "GPIO_7 interrupt enable for AP",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_AP"
                  }
                }
              }
            },
            "GPIO_INTR_EN_M4": {
              "description": "GPIO interrupt enable for M4",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_1_INTR_EN_M4": {
                    "description": "GPIO_0 interrupt enable for M4",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_2_INTR_EN_M4": {
                    "description": "GPIO_1 interrupt enable for M4",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_3_INTR_EN_M4": {
                    "description": "GPIO_3 interrupt enable for M4",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_4_INTR_EN_M4": {
                    "description": "GPIO_4 interrupt enable for M4",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_5_INTR_EN_M4": {
                    "description": "GPIO_5 interrupt enable for M4",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_6_INTR_EN_M4": {
                    "description": "GPIO_6 interrupt enable for M4",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  },
                  "GPIO_7_INTR_EN_M4": {
                    "description": "GPIO_7 interrupt enable for M4",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_1_INTR_EN_M4"
                  }
                }
              }
            },
            "GPIO_INTR_EN_FFE0": {
              "description": "GPIO interrupt enable for FFE0",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR_EN_FFE0": {
                    "description": "GPIO_0 interrupt enable for FFE0",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_1_INTR_EN_FFE0": {
                    "description": "GPIO_1 interrupt enable for FFE0",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_2_INTR_EN_FFE0": {
                    "description": "GPIO_2 interrupt enable for FFE0",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_3_INTR_EN_FFE0": {
                    "description": "GPIO_3 interrupt enable for FFE0",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_4_INTR_EN_FFE0": {
                    "description": "GPIO_4 interrupt enable for FFE0",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_5_INTR_EN_FFE0": {
                    "description": "GPIO_5 interrupt enable for FFE0",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_6_INTR_EN_FFE0": {
                    "description": "GPIO_6 interrupt enable for FFE0",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  },
                  "GPIO_7_INTR_EN_FFE0": {
                    "description": "GPIO_7 interrupt enable for FFE0",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE0"
                  }
                }
              }
            },
            "GPIO_INTR_EN_FFE1": {
              "description": "GPIO interrupt enable for FFE1",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "GPIO_0_INTR_EN_FFE1": {
                    "description": "GPIO_0 interrupt enable for FFE1",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_1_INTR_EN_FFE1": {
                    "description": "GPIO_1 interrupt enable for FFE1",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_2_INTR_EN_FFE1": {
                    "description": "GPIO_2 interrupt enable for FFE1",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_3_INTR_EN_FFE1": {
                    "description": "GPIO_3 interrupt enable for FFE1",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_4_INTR_EN_FFE1": {
                    "description": "GPIO_4 interrupt enable for FFE1",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_5_INTR_EN_FFE1": {
                    "description": "GPIO_5 interrupt enable for FFE1",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_6_INTR_EN_FFE1": {
                    "description": "GPIO_6 interrupt enable for FFE1",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  },
                  "GPIO_7_INTR_EN_FFE1": {
                    "description": "GPIO_7 interrupt enable for FFE1",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.GPIO_0_INTR_EN_FFE1"
                  }
                }
              }
            },
            "OTHER_INTR": {
              "description": "Indicators of interrupt triggers detected",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "M4_SRAM_INTR": {
                    "description": "Interrupt detected for M4 SRAM (access during low power)",
                    "offset": 0,
                    "size": 1
                  },
                  "UART_INTR": {
                    "description": "Interrupt detected for UART",
                    "offset": 1,
                    "size": 1
                  },
                  "TIMER_INTR": {
                    "description": "Interrupt detected for timer",
                    "offset": 2,
                    "size": 1
                  },
                  "WDOG_INTR": {
                    "description": "Interrupt detected for WDT M4",
                    "offset": 3,
                    "size": 1
                  },
                  "WDOG_RST": {
                    "description": "Interrupt detected for WDT M4 Reset",
                    "offset": 4,
                    "size": 1
                  },
                  "TIMEOUT_INTR": {
                    "description": "Interrupt detected for bus timeout",
                    "offset": 5,
                    "size": 1
                  },
                  "FPU_INTR": {
                    "description": "Interrupt detected for M4 FPU",
                    "offset": 6,
                    "size": 1
                  },
                  "PKFB_INTR": {
                    "description": "Interrupt detected for Packet FIFO Bank",
                    "offset": 7,
                    "size": 1
                  },
                  "SPI_MS_INTR": {
                    "description": "Interrupt detected for SPI Master",
                    "offset": 10,
                    "size": 1
                  },
                  "CFG_DMA_INTR": {
                    "description": "Interrupt detected for Config DMA",
                    "offset": 11,
                    "size": 1
                  },
                  "PMU_TMR_INTR": {
                    "description": "Interrupt detected for PMU Timer",
                    "offset": 12,
                    "size": 1
                  },
                  "ADC_INTR": {
                    "description": "Interrupt detected for ADC",
                    "offset": 13,
                    "size": 1
                  },
                  "RTC_INTR": {
                    "description": "Interrupt detected for RTC",
                    "offset": 14,
                    "size": 1
                  },
                  "RST_INTR": {
                    "description": "Interrupt detected for Reset",
                    "offset": 15,
                    "size": 1
                  },
                  "FFE0_INTR_OTHERS": {
                    "description": "Interrupt detected for FFE0 other interrupts",
                    "offset": 16,
                    "size": 1
                  },
                  "APBOOT_EN_INTR": {
                    "description": "Interrupt detected for AP boot",
                    "offset": 18,
                    "size": 1
                  },
                  "LDO30_PG_INTR": {
                    "description": "Interrupt detected for absence of LDO30 power good",
                    "offset": 19,
                    "size": 1
                  },
                  "LDO50_PG_INTR": {
                    "description": "Interrupt detected for absence of LDO30 power good",
                    "offset": 20,
                    "size": 1
                  },
                  "LPSD_VOICE_DET": {
                    "description": "Interrupt detected for LPSD Voice",
                    "offset": 22,
                    "size": 1
                  },
                  "DMIC_VOICE_DET": {
                    "description": "Interrupt detected for Digital MIC",
                    "offset": 23,
                    "size": 1
                  }
                }
              }
            },
            "OTHER_INTR_EN_AP": {
              "description": "Various interrupt enable for AP",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "M4_SRAM_INTR_EN_AP": {
                    "description": "M4 SRAM (access during low power)  interrupt enable for AP",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "UART_INTR_EN_AP": {
                    "description": "UART interrupt enable for AP",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "TIMER_INTR_EN_AP": {
                    "description": "Timer interrupt enable for AP",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "WDOG_INTR_EN_AP": {
                    "description": "WDT M4 interrupt enable for AP",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "WDOG_RST_EN_AP": {
                    "description": "WDT M4 Reset interrupt enable for AP",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "TIMEOUT_INTR_EN_AP": {
                    "description": "Bus Timeout interrupt enable for AP",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "FPU_INTR_EN_AP": {
                    "description": "M4 FPU interrupt enable for AP",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "PKFB_INTR_EN_AP": {
                    "description": "Packet FIFO Bank interrupt enable for AP",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "SPI_MS_INTR_EN_AP": {
                    "description": "SPI Master interrupt enable for AP",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "CFG_DMA_DONE_INTR_EN_AP": {
                    "description": "Config DMA interrupt enable for AP",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "PMU_TMR_INTR_EN_AP": {
                    "description": "PMU Timer interrupt enable for AP",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "ADC_INTR_EN_AP": {
                    "description": "ADC interrupt enable for AP",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "RTC_INTR_EN_AP": {
                    "description": "RTC interrupt enable for AP",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "RST_INTR_EN_AP": {
                    "description": "Reset interrupt enable for AP",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "FFE0_INTR_OTHERS_EN_AP": {
                    "description": "FFE0 Other interrupt enable for AP",
                    "offset": 16,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "APBOOT_EN_AP": {
                    "description": "AP Boot interrupt enable for AP",
                    "offset": 18,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "LDO30_PG_INTR_EN_AP": {
                    "description": "LDO30 absence of power good interrupt enable for AP",
                    "offset": 19,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "LDO50_PG_INTR_EN_AP": {
                    "description": "LDO50 absence of power good interrupt enable for AP",
                    "offset": 20,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "SRAM_128KB_TIMEOUT_INTR_EN_AP": {
                    "description": "SRAM_128KB_TIMEOUT interrupt enable for AP",
                    "offset": 21,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "LPSD_VOICE_DET_EN_AP": {
                    "description": "LPSD Voice detected interrupt enable for AP",
                    "offset": 22,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  },
                  "DMIC_VOICE_DET_EN_AP": {
                    "description": "Digital Mic interrupt enable for AP",
                    "offset": 23,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_AP"
                  }
                }
              }
            },
            "OTHER_INTR_EN_M4": {
              "description": "Various interrupt enable for M4",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "M4_SRAM_INTR_EN_M4": {
                    "description": "M4 SRAM (access during low power) interrupt enable for M4",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "UART_INTR_EN_M4": {
                    "description": "UART interrupt enable for M4",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "TIMER_INTR_EN_M4": {
                    "description": "Timer interrupt enable for M4",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "WDOG_INTR_EN_M4": {
                    "description": "WDOG M4 interrupt enable for M4",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "WDOG_RST_EN_M4": {
                    "description": "WDOG M4 Reset interrupt enable for M4",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "TIMEOUT_INTR_EN_M4": {
                    "description": "bus timeout interrupt enable for M4",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "FPU_INTR_EN_M4": {
                    "description": "M4 FPU interrupt enable for M4",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "PKFB_INTR_EN_M4": {
                    "description": "Packet FIFO Bank interrupt enable for M4",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "SPI_MS_INTR_EN_M4": {
                    "description": "SPI Master interrupt enable for M4",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "CFG_DMA_INTR_EN_M4": {
                    "description": "Config DMA interrupt enable for M4",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "PMU_TMR_INTR_EN_M4": {
                    "description": "PMU Timer interrupt enable for M4",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "ADC_INTR_EN_M4": {
                    "description": "ADC interrupt enable for M4",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "RTC_INTR_EN_M4": {
                    "description": "RTC interrupt enable for M4",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "RST_INTR_EN_M4": {
                    "description": "Reset interrupt enable for M4",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "FFE0_INTR_OTHERS_EN_M4": {
                    "description": "FFE0 other interrupts enable for M4",
                    "offset": 16,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "APBOOT_INTR_EN_M4": {
                    "description": "AP Boot interrupt enable for M4",
                    "offset": 18,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "LDO30_PG_INTR_EN_M4": {
                    "description": "Absence of LDO30 power good interrupt enable for M4",
                    "offset": 19,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "LDO50_PG_INTR_EN_M4": {
                    "description": "Absence of LDO50 power good interrupt enable for M4",
                    "offset": 20,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "LPSD_VOICE_DET_EN_M4": {
                    "description": "LPSD Voice detected interrupt enable for M4",
                    "offset": 22,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  },
                  "DMIC_VOICE_DET_EN_M4": {
                    "description": "Digital Mic Voice detected interrupt enable for M4",
                    "offset": 23,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.M4_SRAM_INTR_EN_M4"
                  }
                }
              }
            },
            "SOFTWARE_INTR_1": {
              "description": " Indicators of General purpose software interrupt 1 triggers detected",
              "offset": 64,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SW_INTR_1": {
                    "description": "Active high edge interrupt detected for Software Interrupt 1. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SOFTWARE_INTR_1_EN_AP": {
              "description": "General purpose Software interrupt 1 enable for AP",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SW_INTR_1_EN_AP": {
                    "description": "Software interrupt 1 enable for AP",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SOFTWARE_INTR_2": {
              "description": "Indicators of General purpose software interrupt 2 triggers detected",
              "offset": 80,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SW_INTR_2": {
                    "description": "Active high edge interrupt detected for Software Interrupt 2. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SOFTWARE_INTR_2_EN_AP": {
              "description": "General purpose Software interrupt 2 enable for AP",
              "offset": 84,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SW_INTR_2_EN_AP": {
                    "description": "Software interrupt 2 enable for AP",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SOFTWARE_INTR_EN_M4": {
              "description": "General purpose Software interrupt 2 enable for M4",
              "offset": 88,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SW_INTR_2_EN_M4": {
                    "description": "Software interrupt 2 enable for M4",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.SW_INTR_2_EN_M4"
                  }
                }
              }
            },
            "FFE_INTR": {
              "description": "Indicators of FFE0 interrupt triggers detected",
              "offset": 96,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "FFE0_0_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_0. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 0,
                    "size": 1
                  },
                  "FFE0_1_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_1. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 1,
                    "size": 1
                  },
                  "FFE0_2_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_2. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 2,
                    "size": 1
                  },
                  "FFE0_3_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_3. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 3,
                    "size": 1
                  },
                  "FFE0_4_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_4. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 4,
                    "size": 1
                  },
                  "FFE0_5_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_5. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 5,
                    "size": 1
                  },
                  "FFE0_6_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_6. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 6,
                    "size": 1
                  },
                  "FFE0_7_INTR": {
                    "description": "Active high edge interrupt detected for FFE0_7. When  interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 7,
                    "size": 1
                  }
                }
              }
            },
            "FFE_INTR_EN_AP": {
              "description": "FFE0 interrupt enable for AP",
              "offset": 100,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "FFE0_0_INTR_EN_AP": {
                    "description": "FFE0_0 interrupt enable for AP",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_1_INTR_EN_AP": {
                    "description": "FFE0_1 interrupt enable for AP",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_2_INTR_EN_AP": {
                    "description": "FFE0_2 interrupt enable for AP",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_3_INTR_EN_AP": {
                    "description": "FFE0_3 interrupt enable for AP",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_4_INTR_EN_AP": {
                    "description": "FFE0_4 interrupt enable for AP",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_5_INTR_EN_AP": {
                    "description": "FFE0_5 interrupt enable for AP",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_6_INTR_EN_AP": {
                    "description": "FFE0_6 interrupt enable for AP",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  },
                  "FFE0_7_INTR_EN_AP": {
                    "description": "FFE0_7 interrupt enable for AP",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_AP"
                  }
                }
              }
            },
            "FFE_INTR_EN_M4": {
              "description": "FFE0 interrupt enable for M4",
              "offset": 104,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "FFE0_0_INTR_EN_M4": {
                    "description": "FFE0_0 interrupt enable for M4",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_1_INTR_EN_M4": {
                    "description": "FFE0_1 interrupt enable for M4",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_2_INTR_EN_M4": {
                    "description": "FFE0_2 interrupt enable for M4",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_3_INTR_EN_M4": {
                    "description": "FFE0_3 interrupt enable for M4",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_4_INTR_EN_M4": {
                    "description": "FFE0_4 interrupt enable for M4",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_5_INTR_EN_M4": {
                    "description": "FFE0_5 interrupt enable for M4",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_6_INTR_EN_M4": {
                    "description": "FFE0_6 interrupt enable for M4",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  },
                  "FFE0_7_INTR_EN_M4": {
                    "description": "FFE0_7 interrupt enable for M4",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FFE0_0_INTR_EN_M4"
                  }
                }
              }
            },
            "FB_INTR": {
              "description": "Indicators of interrupt triggers detected",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "FB_0_INTR": {
                    "description": "Active high edge interrupt detected for Fabric. When interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 0,
                    "size": 1
                  },
                  "FB_1_INTR": {
                    "description": "Active high edge interrupt detected for Fabric. When interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 1,
                    "size": 1
                  },
                  "FB_2_INTR": {
                    "description": "Active high edge interrupt detected for Fabric. When interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 2,
                    "size": 1
                  },
                  "FB_3_INTR": {
                    "description": "Active high edge interrupt detected for Fabric. When interrupt type is selected as edge detect, this register will return high when triggered, write 1 to clear.",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "FB_INTR_RAW": {
              "description": "FB raw interrupt indicators",
              "offset": 132,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "FB_0_INTR_RAW": {
                    "description": "Raw interrupt for Fabric. This register will reflect the value of the Fabric regardless of the type/polarity",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FB_1_INTR_RAW": {
                    "description": "Raw interrupt for Fabric. This register will reflect the value of the Fabric regardless of the type/polarity",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FB_2_INTR_RAW": {
                    "description": "Raw interrupt for Fabric. This register will reflect the value of the Fabric regardless of the type/polarity",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FB_3_INTR_RAW": {
                    "description": "Raw interrupt for Fabric. This register will reflect the value of the Fabric regardless of the type/polarity",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "FB_INTR_TYPE": {
              "description": "Indicators of interrupt trigger types",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "FB_0_INTR_TYPE": {
                    "description": "FB_0 interrupt type {0: level, 1: edge}",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_TYPE"
                  },
                  "FB_1_INTR_TYPE": {
                    "description": "FB_1 interrupt type {0: level, 1: edge}",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_TYPE"
                  },
                  "FB_2_INTR_TYPE": {
                    "description": "FB_2 interrupt type {0: level, 1: edge}",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_TYPE"
                  },
                  "FB_3_INTR_TYPE": {
                    "description": "FB_3 interrupt type {0: level, 1: edge}",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_TYPE"
                  }
                }
              }
            },
            "FB_INTR_POL": {
              "description": "Indicators of interrupt trigger polarities (will depend on the type of interrupt)",
              "offset": 140,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "FB_0_INTR_POL": {
                    "description": "FB_0 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_POL"
                  },
                  "FB_1_INTR_POL": {
                    "description": "FB_1 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_POL"
                  },
                  "FB_2_INTR_POL": {
                    "description": "FB_2 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_POL"
                  },
                  "FB_3_INTR_POL": {
                    "description": "FB_3 interrupt polarity (depends on interrupt type): type = level => {0:low, 1:hi}  --- type = edge => {0:fall, 1:rise}",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_POL"
                  }
                }
              }
            },
            "FB_INTR_EN_AP": {
              "description": "FB interrupt enable for AP",
              "offset": 144,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "FB_0_INTR_EN_AP": {
                    "description": "FB_0 interrupt enable for AP",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_AP"
                  },
                  "FB_1_INTR_EN_AP": {
                    "description": "FB_1 interrupt enable for AP",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_AP"
                  },
                  "FB_2_INTR_EN_AP": {
                    "description": "FB_2 interrupt enable for AP",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_AP"
                  },
                  "FB_3_INTR_EN_AP": {
                    "description": "FB_3 interrupt enable for AP",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_AP"
                  }
                }
              }
            },
            "FB_INTR_EN_M4": {
              "description": "FB interrupt enable for M4",
              "offset": 148,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "FB_0_INTR_EN_M4": {
                    "description": "FB_0 interrupt enable for M4",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_M4"
                  },
                  "FB_1_INTR_EN_M4": {
                    "description": "FB_1 interrupt enable for M4",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_M4"
                  },
                  "FB_2_INTR_EN_M4": {
                    "description": "FB_2 interrupt enable for M4",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_M4"
                  },
                  "FB_3_INTR_EN_M4": {
                    "description": "FB_3 interrupt enable for M4",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.INTR_CTRL.children.enums.FB_0_INTR_EN_M4"
                  }
                }
              }
            },
            "M4_MEM_AON_INTR": {
              "description": "Indicator of detected SRAM access while shut down or sleep mode interrupts ",
              "offset": 160,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "MEM3_AON_INTR0": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 0 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 0,
                    "size": 1
                  },
                  "MEM3_AON_INTR1": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 1 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 1,
                    "size": 1
                  },
                  "MEM3_AON_INTR2": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 2 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 2,
                    "size": 1
                  },
                  "MEM3_AON_INTR3": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 3 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "M4_MEM_AON_INTR_EN": {
              "description": "Interrupt enable for SRAM access while in shut down or deep sleep modes",
              "offset": 164,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "MEM3_AON_INTR0_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 0 32KB_0) ",
                    "offset": 0,
                    "size": 1
                  },
                  "MEM3_AON_INTR1_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 1 32KB_0) ",
                    "offset": 1,
                    "size": 1
                  },
                  "MEM3_AON_INTR2_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 2 32KB_0) ",
                    "offset": 2,
                    "size": 1
                  },
                  "MEM3_AON_INTR3_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 3 32KB_0) ",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            }
          },
          "enums": {
            "GPIO_O_INTR_TYPE": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "level": {
                    "description": "Interrupt is triggered by a certain level (High or Low)",
                    "value": 0
                  },
                  "edge": {
                    "description": "Interrupt is triggered by a signal edge (Falling or Rising)",
                    "value": 1
                  }
                }
              }
            },
            "GPIO_0_INTR_POL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "low_fall": {
                    "description": "Depending on the type, if the interrupt is triggered by level, this indicates the interrupt is triggered by a reading low value, if it is an edge trigger, this value indicates that the interrupt polarity is falling edge",
                    "value": 0
                  },
                  "high_rise": {
                    "description": "Depending on the type, if the interrupt is triggered by level, this indicates the interrupt is triggered by a reading high value, if it is an edge trigger, this value indicates that the interrupt polarity is rising edge",
                    "value": 1
                  }
                }
              }
            },
            "GPIO_0_INTR_EN_AP": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "GPIO_1_INTR_EN_M4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "GPIO_0_INTR_EN_FFE0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "GPIO_0_INTR_EN_FFE1": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "M4_SRAM_INTR_EN_AP": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "M4_SRAM_INTR_EN_M4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "SW_INTR_2_EN_M4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "FFE0_0_INTR_EN_AP": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "FFE0_0_INTR_EN_M4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "FB_0_INTR_TYPE": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "level": {
                    "description": "Interrupt is triggered by a certain level (High or Low)",
                    "value": 0
                  },
                  "edge": {
                    "description": "Interrupt is triggered by a signal edge (Falling or Rising)",
                    "value": 1
                  }
                }
              }
            },
            "FB_0_INTR_POL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "low_fall": {
                    "description": "Depending on the type, if the interrupt is triggered by level, this indicates the interrupt is triggered by a reading low value, if it is an edge trigger, this value indicates that the interrupt polarity is falling edge",
                    "value": 0
                  },
                  "high_rise": {
                    "description": "Depending on the type, if the interrupt is triggered by level, this indicates the interrupt is triggered by a reading high value, if it is an edge trigger, this value indicates that the interrupt polarity is rising edge",
                    "value": 1
                  }
                }
              }
            },
            "FB_0_INTR_EN_AP": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            },
            "FB_0_INTR_EN_M4": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "enable": {
                    "description": "Disable the interrupt for the power domain",
                    "value": 0
                  },
                  "disable": {
                    "description": "Enable the interrupt for the power domain",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "MISC": {
        "description": "MISC registers",
        "children": {
          "registers": {
            "DBG_MON": {
              "description": "Debug Monitor information",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "access": "read-only",
              "children": {
                "fields": {
                  "DEBUG_MON": {
                    "description": "Reads the debug status/information",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "SUBSYS_DBG_MON_SEL": {
              "description": "Register for selecting the subsystem routed to the debug monitor",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "SUBSYS_DEBUG_MON_SEL": {
                    "description": "Select which subsystem the debug monitors are routed from",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.MISC.children.enums.SUBSYS_DEBUG_MON_SEL"
                  }
                }
              }
            },
            "A0_DBG_MON_SEL": {
              "description": "Select A0 debug monitors",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "A0_DEBUG_MON_SEL": {
                    "description": "Select debug monitors",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.MISC.children.enums.A0_DEBUG_MON_SEL"
                  }
                }
              }
            },
            "A0_PMU_DBG_MON_SEL": {
              "description": "Selects the data present in the PMU debug monitor. The output will be (Except 0 and 10), {Status0, Status1, ISO, RET, GateCLK_N, Mem_DS, MP_Gate, RP_Gate)",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "A0_PMU_DEBUG_MON_SEL": {
                    "description": "Select data to be shown in the PMU debug monitor",
                    "offset": 0,
                    "size": 6,
                    "enum": "types.peripherals.MISC.children.enums.A0_PMU_DEBUG_MON_SEL"
                  }
                }
              }
            },
            "IO_INPUT": {
              "description": "Reads the value of the IO pins",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "IO_0": {
                    "description": "Read digital value of pin mapped to IO bit 0",
                    "offset": 0,
                    "size": 1
                  },
                  "IO_1": {
                    "description": "Read digital value of pin mapped to IO bit 1",
                    "offset": 1,
                    "size": 1
                  },
                  "IO_2": {
                    "description": "Read digital value of pin mapped to IO bit 2",
                    "offset": 2,
                    "size": 1
                  },
                  "IO_3": {
                    "description": "Read digital value of pin mapped to IO bit 3",
                    "offset": 3,
                    "size": 1
                  },
                  "IO_4": {
                    "description": "Read digital value of pin mapped to IO bit 4",
                    "offset": 4,
                    "size": 1
                  },
                  "IO_5": {
                    "description": "Read digital value of pin mapped to IO bit 5",
                    "offset": 5,
                    "size": 1
                  },
                  "IO_6": {
                    "description": "Read digital value of pin mapped to IO bit 6",
                    "offset": 6,
                    "size": 1
                  },
                  "IO_7": {
                    "description": "Read digital value of pin mapped to IO bit 7",
                    "offset": 7,
                    "size": 1
                  }
                }
              }
            },
            "IO_OUTPUT": {
              "description": "Allows FW to drive the IO with the values specified in this register",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "IO_0": {
                    "description": "Write digital value of pin mapped to IO bit 0",
                    "offset": 0,
                    "size": 1
                  },
                  "IO_1": {
                    "description": "Write digital value of pin mapped to IO bit 1",
                    "offset": 1,
                    "size": 1
                  },
                  "IO_2": {
                    "description": "Write digital value of pin mapped to IO bit 2",
                    "offset": 2,
                    "size": 1
                  },
                  "IO_3": {
                    "description": "Write digital value of pin mapped to IO bit 3",
                    "offset": 3,
                    "size": 1
                  },
                  "IO_4": {
                    "description": "Write digital value of pin mapped to IO bit 4",
                    "offset": 4,
                    "size": 1
                  },
                  "IO_5": {
                    "description": "Write digital value of pin mapped to IO bit 5",
                    "offset": 5,
                    "size": 1
                  },
                  "IO_6": {
                    "description": "Write digital value of pin mapped to IO bit 6",
                    "offset": 6,
                    "size": 1
                  },
                  "IO_7": {
                    "description": "Write digital value of pin mapped to IO bit 7",
                    "offset": 7,
                    "size": 1
                  }
                }
              }
            },
            "SW_MB_1": {
              "description": "Software Mailbox (can be used for communication between M4 and AP)",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295
            },
            "SW_MB_2": {
              "description": "Software Mailbox (can be used for communication between M4 and AP)",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295
            },
            "PAD_SEL18": {
              "description": "Select 1.8V for VCCIO for up to 4 banks. Write a 1 to a bank field to make the IO VCC = 1.8V",
              "offset": 512,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "TOP_BANK_0": {
                    "description": "bit for top bank 0",
                    "offset": 0,
                    "size": 1
                  },
                  "TOP_BANK_1": {
                    "description": "bit for top bank 1",
                    "offset": 1,
                    "size": 1
                  },
                  "BOTTOM_BANK_2": {
                    "description": "bit for bottom bank 0",
                    "offset": 2,
                    "size": 1
                  },
                  "BOTTOM_BANK_3": {
                    "description": "bit for bottom bank 1",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_MEM128_AON": {
              "description": "Memory Configuration",
              "offset": 528,
              "size": 32,
              "reset_value": 67650,
              "reset_mask": 1048575,
              "children": {
                "fields": {
                  "MEM0_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2'b10. 2'b00 provides the most margin (slowest speed). 2'b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 0,
                    "size": 2
                  },
                  "MEM0_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2'b00. This pin is intended for debug/FA purposes only.",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2'b10. 2'b00 provides the most margin (slowest speed). 2'b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 5,
                    "size": 2
                  },
                  "MEM1_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2'b00. This pin is intended for debug/FA purposes only.",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2'b10. 2'b00 provides the most margin (slowest speed). 2'b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 10,
                    "size": 2
                  },
                  "MEM2_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2'b00. This pin is intended for debug/FA purposes only.",
                    "offset": 14,
                    "size": 1
                  },
                  "MEM3_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2'b10. 2'b00 provides the most margin (slowest speed). 2'b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 15,
                    "size": 2
                  },
                  "MEM3_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2'b00. This pin is intended for debug/FA purposes only.",
                    "offset": 19,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "LOCK_KEY_CTRL": {
              "description": "Control value and status of LOCK_KEY",
              "offset": 784,
              "size": 32,
              "reset_value": 449635665,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "LOCK_KEY_EN": {
                    "description": "0: lock disabled, write to register enabled, 1: lock enable, write to register disabled",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.MISC.children.enums.LOCK_KEY_EN"
                  },
                  "LOCK_KEY": {
                    "description": "Enable write access to all below registers by writing 0x1ACCE551. Disable write access by writing any other value. M4 WDT Intr/reset clear - 0x4000_4830[4:3], M4 WDT Intr/reset enable AP - 0x4000_4834[4:3], Pad #43 (AP_INTR) - 0x40004CAC[12:0], M4 Low Power Configuration - 0x40004484[1:0], M4 WDT Clock Gate - 0x40004054[0]",
                    "offset": 1,
                    "size": 31,
                    "access": "write-only"
                  }
                }
              }
            },
            "FB_DEVICE_ID": {
              "description": "Fabric device ID",
              "offset": 1020,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "ID": {
                    "description": "Fabric device ID",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            }
          },
          "enums": {
            "SUBSYS_DEBUG_MON_SEL": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "monitor_a0": {
                    "description": "Monitor A0 subsystem",
                    "value": 0
                  },
                  "monitor_cpu": {
                    "description": "Monitor the CPU subsystem",
                    "value": 1
                  },
                  "monitor_ffe": {
                    "description": "Monitor the FPGA Fabric subsystem",
                    "value": 3
                  },
                  "monitor_audio": {
                    "description": "Monitor the audio subsystem",
                    "value": 4
                  }
                }
              }
            },
            "A0_DEBUG_MON_SEL": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "use_pmu_monitor": {
                    "description": "Selects the PMU monitor as the monitor for the A0 subsystem",
                    "value": 0
                  },
                  "use_cru_monitor": {
                    "description": "Selects the CRU monitor as the monitor for the A0 subsystem",
                    "value": 1
                  }
                }
              }
            },
            "A0_PMU_DEBUG_MON_SEL": {
              "size": 6,
              "children": {
                "enum_fields": {
                  "show_m4stm_kickoff_and_busy_plus_0x000000": {
                    "description": "{M4STM_KickOff, M4STM_BUSY, 6'h0}",
                    "value": 0
                  },
                  "show_a1": {
                    "value": 1
                  },
                  "show_m4": {
                    "value": 2
                  },
                  "show_m4s0": {
                    "value": 3
                  },
                  "show_ad5": {
                    "value": 4
                  },
                  "show_ad4": {
                    "value": 5
                  },
                  "show_ad3": {
                    "value": 6
                  },
                  "show_ad2": {
                    "value": 7
                  },
                  "show_ad1": {
                    "value": 8
                  },
                  "show_ad0": {
                    "value": 9
                  },
                  "show_fbst_kickoff_and_busy_plus_0x000000": {
                    "description": "{FBSTM_KickOff, FBSTM_BUSY,6'h0}",
                    "value": 10
                  },
                  "show_i2s": {
                    "value": 11
                  },
                  "show_m4s15": {
                    "value": 13
                  },
                  "show_m4s11": {
                    "value": 14
                  },
                  "show_m4s7": {
                    "value": 15
                  },
                  "show_m4s3": {
                    "value": 16
                  },
                  "show_pf": {
                    "value": 17
                  },
                  "show_sdma": {
                    "value": 18
                  },
                  "show_ffe": {
                    "value": 19
                  },
                  "show_fb": {
                    "value": 20
                  }
                }
              }
            },
            "LOCK_KEY_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "lock_disable": {
                    "description": "Disable lock to allow writing the lock_key field",
                    "value": 0
                  },
                  "lock_enable": {
                    "description": "Enable lock to prevent writing the lock_key field",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "PKFB": {
        "description": "Packet FFO Bank control",
        "children": {
          "registers": {
            "PKFB_FIFOCTRL": {
              "description": "Packet FIFO Bank control",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf0_en": {
                    "description": "Set to enable the Packet FIFO",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_en"
                  },
                  "pf0_push_mux": {
                    "description": "Select which subsystem controls the push operation",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_mux"
                  },
                  "pf0_pop_mux": {
                    "description": "Select which subsystem controls the pop operation",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_mux"
                  },
                  "pf0_push_int_mux": {
                    "description": "Select which subsystem manages the push interrupt",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_mux"
                  },
                  "pf0_pop_int_mux": {
                    "description": "Select which subsystem manages the pop interrupt",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_mux"
                  },
                  "pf0_ffe_sel": {
                    "description": "If FFE is the controller, select which instance of FFE will be used for control",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_ffe_sel"
                  },
                  "pf1_en": {
                    "description": "Set to enable the Packet FIFO",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_en"
                  },
                  "pf1_push_mux": {
                    "description": "Select which subsystem controls the push operation",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_mux"
                  },
                  "pf1_pop_mux": {
                    "description": "Select which subsystem controls the pop operation",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_mux"
                  },
                  "pf1_push_int_mux": {
                    "description": "Select which subsystem manages the push interrupt",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_mux"
                  },
                  "pf1_pop_int_mux": {
                    "description": "Select which subsystem manages the pop interrupt",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_mux"
                  },
                  "pf1_ffe_sel": {
                    "description": "If FFE is the controller, select which instance of FFE will be used for control",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_ffe_sel"
                  },
                  "pf2_en": {
                    "description": "Set to enable the Packet FIFO",
                    "offset": 16,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_en"
                  },
                  "pf2_push_mux": {
                    "description": "Select which subsystem controls the push operation",
                    "offset": 17,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_mux"
                  },
                  "pf2_pop_mux": {
                    "description": "Select which subsystem controls the pop operation",
                    "offset": 18,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_mux"
                  },
                  "pf2_push_int_mux": {
                    "description": "Select which subsystem manages the push interrupt",
                    "offset": 19,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_mux"
                  },
                  "pf2_pop_int_mux": {
                    "description": "Select which subsystem manages the pop interrupt",
                    "offset": 20,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_mux"
                  },
                  "pf2_ffe_sel": {
                    "description": "If FFE is the controller, select which instance of FFE will be used for control",
                    "offset": 21,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_ffe_sel"
                  },
                  "pf8k_en": {
                    "description": "Set to enable the Packet FIFO",
                    "offset": 24,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_en"
                  },
                  "pf8k_push_mux": {
                    "description": "Select which subsystem controls the push operation",
                    "offset": 25,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_mux"
                  },
                  "pf8k_pop_mux": {
                    "description": "Select which subsystem controls the pop operation",
                    "offset": 26,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_mux"
                  },
                  "pf8k_push_int_mux": {
                    "description": "Select which subsystem manages the push interrupt",
                    "offset": 27,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_mux"
                  },
                  "pf8k_pop_int_mux": {
                    "description": "Select which subsystem manages the pop interrupt",
                    "offset": 28,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_mux"
                  },
                  "pf8k_ffe_sel": {
                    "description": "If FFE is the controller, select which instance of FFE will be used for control",
                    "offset": 29,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_ffe_sel"
                  }
                }
              }
            },
            "PKFB_FIFOSRAMCTRL0": {
              "description": "SRAM Test Control 0",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf0_test1a": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 0,
                    "size": 1
                  },
                  "pf0_rmea": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 1,
                    "size": 1
                  },
                  "pf0_rma": {
                    "description": "SRAM Adjust timing value",
                    "offset": 2,
                    "size": 4
                  },
                  "pf0_test1b": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 8,
                    "size": 1
                  },
                  "pf0_rmeb": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 9,
                    "size": 1
                  },
                  "pf0_rmb": {
                    "description": "SRAM Adjust timing value",
                    "offset": 10,
                    "size": 4
                  },
                  "pf1_test1a": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 16,
                    "size": 1
                  },
                  "pf1_rmea": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 17,
                    "size": 1
                  },
                  "pf1_rma": {
                    "description": "SRAM Adjust timing value",
                    "offset": 18,
                    "size": 4
                  },
                  "pf1_test1b": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 24,
                    "size": 1
                  },
                  "pf1_rmeb": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 25,
                    "size": 1
                  },
                  "pf1_rmb": {
                    "description": "SRAM Adjust timing value",
                    "offset": 26,
                    "size": 4
                  }
                }
              }
            },
            "PKFB_FIFOSRAMCTRL1": {
              "description": "SRAM Test Control 1",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf2_test1a": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 0,
                    "size": 1
                  },
                  "pf2_rmea": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 1,
                    "size": 1
                  },
                  "pf2_rma": {
                    "description": "SRAM Adjust timing value",
                    "offset": 2,
                    "size": 4
                  },
                  "pf2_test1b": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 8,
                    "size": 1
                  },
                  "pf2_rmeb": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 9,
                    "size": 1
                  },
                  "pf2_rmb": {
                    "description": "SRAM Adjust timing value",
                    "offset": 10,
                    "size": 4
                  },
                  "pf8k_test1a": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 16,
                    "size": 1
                  },
                  "pf8k_rmea": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 17,
                    "size": 1
                  },
                  "pf8k_rma": {
                    "description": "SRAM Adjust timing value",
                    "offset": 18,
                    "size": 4
                  },
                  "pf8k_test1b": {
                    "description": "Set this bit to disable Test capabilities",
                    "offset": 24,
                    "size": 1
                  },
                  "pf8k_rmeb": {
                    "description": "Set this bit to disable SRAM timing adjust",
                    "offset": 25,
                    "size": 1
                  },
                  "pf8k_rmb": {
                    "description": "SRAM Adjust timing value",
                    "offset": 26,
                    "size": 4
                  }
                }
              }
            },
            "PKFB_FIFOSTATUS": {
              "description": "Packet FIFO Status register",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf0_sram_sleep": {
                    "description": "SRAM Sleep Status",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_sram_sleep"
                  },
                  "pf0_push_int_over": {
                    "description": "Bit is set if there's an interrupt set for overflow (pktFIFO or FFE FIFO)",
                    "offset": 2,
                    "size": 1
                  },
                  "pf0_push_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for push threshold",
                    "offset": 3,
                    "size": 1
                  },
                  "pf0_push_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for push on SRAM sleep",
                    "offset": 4,
                    "size": 1
                  },
                  "pf0_pop_int_under": {
                    "description": "Bit is set if there's an interrupt set for underflow",
                    "offset": 5,
                    "size": 1
                  },
                  "pf0_pop_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for pop threshold",
                    "offset": 6,
                    "size": 1
                  },
                  "pf0_pop_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for pop on SRAM sleep",
                    "offset": 7,
                    "size": 1
                  },
                  "pf1_sram_sleep": {
                    "description": "SRAM Sleep Status",
                    "offset": 8,
                    "size": 2,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_sram_sleep"
                  },
                  "pf1_push_int_over": {
                    "description": "Bit is set if there's an interrupt set for overflow (pktFIFO or FFE FIFO)",
                    "offset": 10,
                    "size": 1
                  },
                  "pf1_push_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for push threshold",
                    "offset": 11,
                    "size": 1
                  },
                  "pf1_push_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for push on SRAM sleep",
                    "offset": 12,
                    "size": 1
                  },
                  "pf1_pop_int_under": {
                    "description": "Bit is set if there's an interrupt set for underflow",
                    "offset": 13,
                    "size": 1
                  },
                  "pf1_pop_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for pop threshold",
                    "offset": 14,
                    "size": 1
                  },
                  "pf1_pop_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for pop on SRAM sleep",
                    "offset": 15,
                    "size": 1
                  },
                  "pf2_sram_sleep": {
                    "description": "SRAM Sleep Status",
                    "offset": 16,
                    "size": 2,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_sram_sleep"
                  },
                  "pf2_push_int_over": {
                    "description": "Bit is set if there's an interrupt set for overflow (pktFIFO or FFE FIFO)",
                    "offset": 18,
                    "size": 1
                  },
                  "pf2_push_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for push threshold",
                    "offset": 19,
                    "size": 1
                  },
                  "pf2_push_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for push on SRAM sleep",
                    "offset": 20,
                    "size": 1
                  },
                  "pf2_pop_int_under": {
                    "description": "Bit is set if there's an interrupt set for underflow",
                    "offset": 21,
                    "size": 1
                  },
                  "pf2_pop_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for pop threshold",
                    "offset": 22,
                    "size": 1
                  },
                  "pf2_pop_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for pop on SRAM sleep",
                    "offset": 23,
                    "size": 1
                  },
                  "pf8k_sram_sleep": {
                    "description": "SRAM Sleep Status",
                    "offset": 24,
                    "size": 2,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_sram_sleep"
                  },
                  "pf8k_push_int_over": {
                    "description": "Bit is set if there's an interrupt set for overflow (pktFIFO or FFE FIFO)",
                    "offset": 26,
                    "size": 1
                  },
                  "pf8k_push_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for push threshold",
                    "offset": 27,
                    "size": 1
                  },
                  "pf8k_push_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for push on SRAM sleep",
                    "offset": 28,
                    "size": 1
                  },
                  "pf8k_pop_int_under": {
                    "description": "Bit is set if there's an interrupt set for underflow",
                    "offset": 29,
                    "size": 1
                  },
                  "pf8k_pop_int_thresh": {
                    "description": "Bit is set if there's an interrupt set for pop threshold",
                    "offset": 30,
                    "size": 1
                  },
                  "pf8k_pop_int_sleep": {
                    "description": "Bit is set if there's an interrupt set for pop on SRAM sleep",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "PKFB_PF0PUSHCTL": {
              "description": "FIFO 0 Push Control",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 33488927,
              "children": {
                "fields": {
                  "pf0_push_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf0_push_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_sleep_type"
                  },
                  "pf0_push_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_en_ov"
                  },
                  "pf0_push_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_en_ov"
                  },
                  "pf0_push_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for push on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_push_int_en_ov"
                  },
                  "pf0_push_thresh": {
                    "description": "PUSH counter threshold (x32 count)",
                    "offset": 16,
                    "size": 9
                  }
                }
              }
            },
            "PKFB_PF0POPCTL": {
              "description": "FIFO 0 Pop Control",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 33488927,
              "children": {
                "fields": {
                  "pf0_pop_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf0_pop_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_sleep_type"
                  },
                  "pf0_pop_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_en_ov"
                  },
                  "pf0_pop_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_en_ov"
                  },
                  "pf0_pop_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for pop on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_pop_int_en_ov"
                  },
                  "pf0_pop_thresh": {
                    "description": "POP counter threshold (x32 count)",
                    "offset": 16,
                    "size": 9
                  }
                }
              }
            },
            "PKFB_PF0CNT": {
              "description": "FIFO 0 Count",
              "offset": 24,
              "size": 32,
              "reset_value": 16809984,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf0_pop_cnt": {
                    "description": "FIFO 0 Pop Count (x32 count) Number of available entries for pop",
                    "offset": 0,
                    "size": 9,
                    "access": "read-only"
                  },
                  "pf0_empty": {
                    "description": "FIFO 0 Empty",
                    "offset": 15,
                    "size": 1,
                    "access": "read-only"
                  },
                  "pf0_push_cnt": {
                    "description": "FIFO 0 Push Count (x32 count) Number of available entries for push",
                    "offset": 16,
                    "size": 9,
                    "access": "read-only"
                  },
                  "pf0_full": {
                    "description": "FIFO 0 Full",
                    "offset": 31,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "PKFB_PF0DATA": {
              "description": "FIFO 0 Push/POP Data Register",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf0_data_reg": {
                    "description": "FIFO 0 Push/POP Data Register",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "PKFB_PF1PUSHCTL": {
              "description": "FIFO 1 Push Control",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16711711,
              "children": {
                "fields": {
                  "pf1_push_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf1_push_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_push_sleep_type"
                  },
                  "pf1_push_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_push_int_en_ov"
                  },
                  "pf1_push_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_push_int_en_ov"
                  },
                  "pf1_push_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for push on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_push_int_en_ov"
                  },
                  "pf1_push_thresh": {
                    "description": "PUSH counter threshold (x32 count)",
                    "offset": 16,
                    "size": 8
                  }
                }
              }
            },
            "PKFB_PF1POPCTL": {
              "description": "FIFO 1 Pop Control",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16711711,
              "children": {
                "fields": {
                  "pf1_pop_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf1_pop_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_pop_sleep_type"
                  },
                  "pf1_pop_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_pop_int_en_ov"
                  },
                  "pf1_pop_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_pop_int_en_ov"
                  },
                  "pf1_pop_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for pop on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf1_pop_int_en_ov"
                  },
                  "pf1_pop_thresh": {
                    "description": "POP counter threshold (x32 count)",
                    "offset": 16,
                    "size": 8
                  }
                }
              }
            },
            "PKFB_PF1CNT": {
              "description": "FIFO 1 Count",
              "offset": 40,
              "size": 32,
              "reset_value": 8421376,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf1_pop_cnt": {
                    "description": "FIFO 1 Pop Count (x32 count) Number of available entries for pop",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  },
                  "pf1_empty": {
                    "description": "FIFO 1 Empty",
                    "offset": 15,
                    "size": 1,
                    "access": "read-only"
                  },
                  "pf1_push_cnt": {
                    "description": "FIFO 1 Push Count (x32 count) Number of available entries for push",
                    "offset": 16,
                    "size": 8,
                    "access": "read-only"
                  },
                  "pf1_full": {
                    "description": "FIFO 1 Full",
                    "offset": 31,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "PKFB_PF1DATA": {
              "description": "FIFO 1 Push/POP Data Register",
              "offset": 44,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf1_data_reg": {
                    "description": "FIFO 1 Push/POP Data Register",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "PKFB_PF2PUSHCTL": {
              "description": "FIFO 2 Push Control",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16711711,
              "children": {
                "fields": {
                  "pf2_push_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf2_push_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_push_sleep_type"
                  },
                  "pf2_push_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_push_int_en_ov"
                  },
                  "pf2_push_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_push_int_en_ov"
                  },
                  "pf2_push_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for push on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_push_int_en_ov"
                  },
                  "pf2_push_thresh": {
                    "description": "PUSH counter threshold (x32 count)",
                    "offset": 16,
                    "size": 8
                  }
                }
              }
            },
            "PKFB_PF2POPCTL": {
              "description": "FIFO 2 Pop Control",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 16711711,
              "children": {
                "fields": {
                  "pf2_pop_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf2_pop_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_pop_sleep_type"
                  },
                  "pf2_pop_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_pop_int_en_ov"
                  },
                  "pf2_pop_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_pop_int_en_ov"
                  },
                  "pf2_pop_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for pop on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf2_pop_int_en_ov"
                  },
                  "pf2_pop_thresh": {
                    "description": "POP counter threshold (x32 count)",
                    "offset": 16,
                    "size": 8
                  }
                }
              }
            },
            "PKFB_PF2CNT": {
              "description": "FIFO 2 Count",
              "offset": 56,
              "size": 32,
              "reset_value": 8421376,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf2_pop_cnt": {
                    "description": "FIFO 2 Pop Count (x32 count) Number of available entries for pop",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  },
                  "pf2_empty": {
                    "description": "FIFO 2 Empty",
                    "offset": 15,
                    "size": 1,
                    "access": "read-only"
                  },
                  "pf2_push_cnt": {
                    "description": "FIFO 2 Push Count (x32 count) Number of available entries for push",
                    "offset": 16,
                    "size": 8,
                    "access": "read-only"
                  },
                  "pf2_full": {
                    "description": "FIFO 2 Full",
                    "offset": 31,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "PKFB_PF2DATA": {
              "description": "FIFO 2 Push/POP Data Register",
              "offset": 60,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf2_data_reg": {
                    "description": "FIFO 2 Push/POP Data Register",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "PKFB_PF8KPUSHCTL": {
              "description": "FIFO 8k Push Control",
              "offset": 64,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 33488927,
              "children": {
                "fields": {
                  "pf8k_push_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf8k_push_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_push_sleep_type"
                  },
                  "pf8k_push_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_push_int_en_ov"
                  },
                  "pf8k_push_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_push_int_en_ov"
                  },
                  "pf8k_push_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for push on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_push_int_en_ov"
                  },
                  "pf8k_push_thresh": {
                    "description": "PUSH counter threshold (x16 count)",
                    "offset": 16,
                    "size": 13
                  }
                }
              }
            },
            "PKFB_PF8KPOPCTL": {
              "description": "FIFO 8k Pop Control",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 536805503,
              "children": {
                "fields": {
                  "pf8k_pop_sleep_en": {
                    "description": "Set this bit to enable sleep",
                    "offset": 0,
                    "size": 1
                  },
                  "pf8k_pop_sleep_type": {
                    "description": "Select the type of sleep mode",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_pop_sleep_type"
                  },
                  "pf8k_pop_int_en_ov": {
                    "description": "Control whether the push interrupt for FIFO overflow is enabled or masked",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_pop_int_en_ov"
                  },
                  "pf8k_pop_int_en_thresh": {
                    "description": "Control whether the push interrupt for FIFO threshold is enabled or masked",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_pop_int_en_ov"
                  },
                  "pf8k_pop_int_en_sram_sleep": {
                    "description": "Control whether the push interrupt for pop on SRAM sleep is enabled or masked",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf8k_pop_int_en_ov"
                  },
                  "pf8k_fifo_pkt_mode": {
                    "description": "FIFO Packet Mode",
                    "offset": 5,
                    "size": 1
                  },
                  "pf8k_fifo_ring_buff_mode": {
                    "description": "Ring buffer mode",
                    "offset": 6,
                    "size": 1
                  },
                  "pf8k_pop_thresh": {
                    "description": "POP counter threshold (x16 count)",
                    "offset": 16,
                    "size": 8
                  }
                }
              }
            },
            "PKFB_PF8KCNT": {
              "description": "FIFO 8k Count",
              "offset": 72,
              "size": 32,
              "reset_value": 16809984,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf8k_pop_cnt": {
                    "description": "FIFO 8k Pop Count (x16 count) Number of available entries for pop",
                    "offset": 0,
                    "size": 13,
                    "access": "read-only"
                  },
                  "pf8k_empty": {
                    "description": "FIFO 8k Empty",
                    "offset": 15,
                    "size": 1,
                    "access": "read-only"
                  },
                  "pf8k_push_cnt": {
                    "description": "FIFO 8k Push Count (x32 count) Number of available entries for push",
                    "offset": 16,
                    "size": 13,
                    "access": "read-only"
                  },
                  "pf8k_full": {
                    "description": "FIFO 8k Full",
                    "offset": 31,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "PKFB_PF8kDATA": {
              "description": "FIFO 8k Push/POP Data Register",
              "offset": 76,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pf8k_data_reg": {
                    "description": "FIFO 8k Push/POP Data Register. In ringbuffer mode, [16] is treated as SOP (start-of-packet) by autodrain logic",
                    "offset": 0,
                    "size": 17
                  },
                  "pf8k_push_eop": {
                    "description": "FIFO 8k Push EOP (end of packet)",
                    "offset": 17,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "PKFB_FIFO_COLL_INTR": {
              "description": "Control for collision interrupts",
              "offset": 80,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "pf0_coll_intr": {
                    "description": "Interrupt is triggered when bot FFE0 and FFE1 try to push into packet FIFO 0",
                    "offset": 0,
                    "size": 1
                  },
                  "pf1_coll_intr": {
                    "description": "Interrupt is triggered when bot FFE0 and FFE1 try to push into packet FIFO 1",
                    "offset": 1,
                    "size": 1
                  },
                  "pf2_coll_intr": {
                    "description": "Interrupt is triggered when bot FFE0 and FFE1 try to push into packet FIFO 0",
                    "offset": 2,
                    "size": 1
                  },
                  "pf8k_coll_intr": {
                    "description": "Interrupt is triggered when bot FFE0 and FFE1 try to push into packet FIFO 8k",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "PKFB_FIFO_COLL_INTR_EN": {
              "description": "Control register for enabling or masking the collisione interrupts",
              "offset": 84,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "pf0_coll_intr_en": {
                    "description": "Set bit to enable interrupt",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_coll_intr_en"
                  },
                  "pf1_coll_intr_en": {
                    "description": "Set bit to enable interrupt",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_coll_intr_en"
                  },
                  "pf2_coll_intr_en": {
                    "description": "Set bit to enable interrupt",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_coll_intr_en"
                  },
                  "pf8k_coll_intr_en": {
                    "description": "Set bit to enable interrupt",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PKFB.children.enums.pf0_coll_intr_en"
                  }
                }
              }
            }
          },
          "enums": {
            "pf0_en": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Disable the packet FIFO",
                    "value": 0
                  },
                  "enable": {
                    "description": "Enable the packet FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_push_mux": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "m4": {
                    "description": "Select the M4 subsystem to control the FIFO",
                    "value": 0
                  },
                  "ffe": {
                    "description": "Select the FFE subsystem to control the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_pop_mux": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "m4": {
                    "description": "Select the M4 subsystem to control the FIFO",
                    "value": 0
                  },
                  "ap": {
                    "description": "Select the AP subsystem to control the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_push_int_mux": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "m4": {
                    "description": "Select the M4 subsystem to control the FIFO",
                    "value": 0
                  },
                  "ap": {
                    "description": "Select the AP subsystem to control the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_pop_int_mux": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "m4": {
                    "description": "Select the M4 subsystem to control the FIFO",
                    "value": 0
                  },
                  "ap": {
                    "description": "Select the AP subsystem to control the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_ffe_sel": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "ffe0": {
                    "description": "when FFE is the controller of the FIFO, select FFE0 as the controller",
                    "value": 0
                  },
                  "ffe1": {
                    "description": "when FFE is the controller of the FIFO, select FFE1 as the controller",
                    "value": 1
                  }
                }
              }
            },
            "pf0_sram_sleep": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "active": {
                    "description": "SRAM is in active mode",
                    "value": 0
                  },
                  "light_sleep": {
                    "description": "SRAM is in Light Sleep mode",
                    "value": 1
                  },
                  "deep_sleep": {
                    "description": "SRAM is in Deep Sleep mode",
                    "value": 2
                  },
                  "shutdown": {
                    "description": "SRAM is in Shutdown mode",
                    "value": 3
                  }
                }
              }
            },
            "pf0_push_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_push_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf0_pop_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf0_pop_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf1_push_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf1_push_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf1_pop_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf1_pop_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf2_push_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf2_push_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf2_pop_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf2_pop_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf8k_push_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf8k_push_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf8k_pop_sleep_type": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "deep_sleep": {
                    "description": "Select deep sleep as sleep type for the FIFO",
                    "value": 0
                  },
                  "shut_down": {
                    "description": "Select shutdown as the sleep type for the FIFO",
                    "value": 1
                  }
                }
              }
            },
            "pf8k_pop_int_en_ov": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            },
            "pf0_coll_intr_en": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt event",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt event",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "PMU": {
        "description": "Power Management Unit",
        "children": {
          "registers": {
            "MISC_POR_0": {
              "description": "On POR Reset Domain",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "M4_Rst_Release": {
                    "description": "RWHC: In AP mode, (SPIS_SS is High by default) ( In Wearable Mode, it has NO effect). The Hardware will clear this bit if `AP_Reboot_enable_N` is programmed and M4 is waking up from Mode 1 (SD) to ensure the M4 is kept on Reset once waking up.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4_Rst_Release"
                  }
                }
              }
            },
            "MISC_POR_1": {
              "description": "On POR Reset Domain",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "Cfg_fpd_on": {
                    "description": "The FW need to program this bit if FW put the SPI flash to Power Down Mode. The CfgSM will wake up the Flash before reloading the boot code if this bit is 1. FW need to ensure this bit is clear after boot code reloading.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Cfg_fpd_on"
                  },
                  "Sys_rst_as_int": {
                    "description": "RWHC: Interrupt pin. This bit will be clear if System Reset Trigger when this bit is one",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sys_rst_as_int"
                  },
                  "Sys_rst_as_int_pw": {
                    "description": "If Sys_rst_as_int bit is programmed, then this system Reset INT will trigger if the reset pin is low and the pulse width greater than the configuration value.",
                    "offset": 2,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.Sys_rst_as_int_pw"
                  },
                  "Sys_rst_pulse_ext": {
                    "description": "If reset pin is still ketp low after the system reset INT is triggered, then the Chip will be reset if its pulse width is greater than configuration value",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sys_rst_pulse_ext"
                  }
                }
              }
            },
            "MISC_POR_2": {
              "description": "On POR Reset Domain",
              "offset": 8,
              "size": 32,
              "reset_value": 3,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SPI_Reboot_enable_N": {
                    "description": "If 1'b0, Need cfgSM to reload the code when M4 waking up from SD (Mode1). FW needs to clear this bit if needs code reloading from SPI flash once waking up from SD mdoe (MODE1). CfgSM will be kick off if code reloading from SPI flash needed. This is for code reloading ONLY.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SPI_Reboot_enable_N"
                  },
                  "AP_Reboot_enable_N": {
                    "description": "If 1'b0, Need cfgSM to reload the code when M4 waking up from SD (Mode1) FW needs to clear this bit if needs code reloading from SPI flash once waking up from SD mdoe (MODE1). CfgSM will be kick off if code reloading from SPI flash needed. This is for code reloading ONLY.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AP_Reboot_enable_N"
                  }
                }
              }
            },
            "MISC_POR_3": {
              "description": "On POR Reset Domain",
              "offset": 12,
              "size": 32,
              "reset_value": 65280,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "Scratch_byte_0": {
                    "description": "Scratch Bytes, General Purpose Registers",
                    "offset": 0,
                    "size": 8
                  },
                  "Scratch_byte_1": {
                    "description": "Scratch Bytes, General Purpose Registers",
                    "offset": 8,
                    "size": 8
                  }
                }
              }
            },
            "RST_CTRL_0": {
              "description": "Reserved",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "RST_CTRL_1": {
              "description": "Reserved",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "CHIP_STA_0": {
              "description": "Reserved",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "CHIP_STA_1": {
              "description": "Chip Status register",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "FFE0_BUSY": {
                    "description": "Indicates if FFE0 is busy",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE0_BUSY"
                  },
                  "Code_Source_Cfg": {
                    "description": "This reflects the value of boot strap bit. Pad[19]",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Code_Source_Cfg"
                  },
                  "Debug_Port_Cfg": {
                    "description": "This reflects the value of boot strap bit. Pad[8]",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Debug_Port_Cfg"
                  },
                  "FB_0": {
                    "description": "FB Stasus Siganl 0 (Its definition is depending on the implementation of FB)",
                    "offset": 6,
                    "size": 1
                  },
                  "FB_1": {
                    "description": "FB Stasus Siganl 1 (Its definition is depending on the implementation of FB)",
                    "offset": 7,
                    "size": 1
                  },
                  "FB_2": {
                    "description": "FB Stasus Siganl 2 (Its definition is depending on the implementation of FB)",
                    "offset": 8,
                    "size": 1
                  },
                  "FB_3": {
                    "description": "FB Stasus Siganl 3 (Its definition is depending on the implementation of FB)",
                    "offset": 9,
                    "size": 1
                  },
                  "SWD_Mode_Cfg": {
                    "description": "This reflects the value of boot strap bit. Pad[20]",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SWD_Mode_Cfg"
                  },
                  "CLOCK_BYPASS_Cfg": {
                    "description": "This reflects the value of boot strap bit. Pad[9]",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CLOCK_BYPASS_Cfg"
                  }
                }
              }
            },
            "WIC_CTRL": {
              "description": "Wake-up Interrupt Controller control register",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "WIC_Enable": {
                    "description": "RWHC: This bit will be clear once M4 is in Mode 1 (SD mode) by HW.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "WIC_STATUS": {
              "description": "Wake-up Interrupt Controller Status register",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "WIC_Ready": {
                    "description": "This bit is indicates that M4 Power Saving is enabled. This bit is based on the WIC/M4 interface signal.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PWR_DWN_SCH": {
              "description": "Power Down Scheme configuration",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "FFEFB_WU": {
                    "description": "FFE and FB simultaneous wakeup-event behaviour",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFEFB_WU"
                  },
                  "SRAM_WU": {
                    "description": "SRAM simultaneous wakeup-event behaviour",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SRAM_WU"
                  },
                  "AUDIO_WU": {
                    "description": "Audio simultaneous wakeup-event behaviour",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_WU"
                  },
                  "M4M4S0_WU": {
                    "description": "M4 and M4S0 simultaneous wakeup-event behaviour",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4M4S0_WU"
                  },
                  "FFEFB_PD": {
                    "description": "FFE and FB simultaneous power-down behaviour",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFEFB_PD"
                  },
                  "SRAM_PD": {
                    "description": "SRAM simultaneous power-down behaviour",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SRAM_PD"
                  },
                  "AUDIO_PD": {
                    "description": "AUDIO simultaneous power-down behaviour",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_PD"
                  },
                  "M4M4S0_PD": {
                    "description": "M4 and M4S0 simultaneous power-down behaviour",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4M4S0_PD"
                  }
                }
              }
            },
            "PWR_OFF_OSC": {
              "description": "Control the power state of Oscillator once the M4 is in Power Saving Mode",
              "offset": 64,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Power_Off_OSC": {
                    "description": "1'b1 : Turn Off OSC once the M4 is in Power Saving Mode",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "EXT_WAKING_UP_SRC": {
              "description": "Configure the external wakeup event source. Turn on the OSC once PMUT is time out or GPIO INT is triggering. ",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "Ext_WU_Source_Mask_N_0_GPIO_INT": {
                    "description": "Bit 7:0 GPIO/Sensor INT, level only, (Raw information from PAD direclty) (Turn on OSC)",
                    "offset": 0,
                    "size": 8
                  },
                  "Ext_WU_Source_Mask_N_0_PMU_Timer": {
                    "description": "Bit 8 : PMU Timer",
                    "offset": 8,
                    "size": 1
                  },
                  "Ext_WU_Source_Mask_N_0_Reset_Interrupt": {
                    "description": "Bit 9 : Reset Interrupt INT (Always Mask).",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "SDMA_STATUS": {
              "description": "SDMA status register",
              "offset": 112,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "SDMA_Active": {
                    "description": "SDMA power domain is active",
                    "offset": 0,
                    "size": 1
                  },
                  "SDMA_Deep_Sleep": {
                    "description": "SDMA power domain is in Deep Sleep Mode",
                    "offset": 1,
                    "size": 1
                  },
                  "SDMA_Shut_Down": {
                    "description": "SDMA power domain is in Shut Down mode",
                    "offset": 2,
                    "size": 1
                  },
                  "SDMA_Clock_Gating": {
                    "description": "Reserved",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "SDMA_POWER_MODE_CFG": {
              "description": "Register for SDMA Power Mode configuration",
              "offset": 116,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "SDMA_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before kicking off the power down event.",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Power_Mode_Cfg"
                  }
                }
              }
            },
            "SDMA_PD_SRC_MASK_N": {
              "description": "Register for controlling if power down event will be masked",
              "offset": 120,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SDMA_PD_EVENT": {
                    "description": "1'b0 : SDMA HW Power Down Event will be masked.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_PD_EVENT"
                  }
                }
              }
            },
            "SDMA_WU_SRC_MASK_N": {
              "description": "Reserved",
              "offset": 124,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4_STATUS": {
              "description": "Status of the M4 Power Domain",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "M4_Active": {
                    "description": "M4 Power Domain is active",
                    "offset": 0,
                    "size": 1
                  },
                  "M4_Deep_Sleep": {
                    "description": "Reserved",
                    "offset": 1,
                    "size": 1
                  },
                  "M4_Shut_Down": {
                    "description": "M4 Power Domain is in Shut Down mode",
                    "offset": 2,
                    "size": 1
                  },
                  "M4_Clock_Gating": {
                    "description": "Reserved",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "M4_PWR_MODE_CFG": {
              "description": "Configuration for the M4 power domain",
              "offset": 132,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "M4_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before clocking off the power down event",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.M4_Power_Mode_Cfg"
                  }
                }
              }
            },
            "M4_PD_SRC_MASKk_N": {
              "description": "Reserved",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4_WU": {
              "description": "Reserved",
              "offset": 140,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "FFE_STATUS": {
              "description": "Status of the Flexible Fusion Engine",
              "offset": 144,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "FFE_Active": {
                    "description": "FFE Power Domain is active",
                    "offset": 0,
                    "size": 1
                  },
                  "FFE_Deep_Sleep": {
                    "description": "FFE Power Domain is in Deep Sleep mode",
                    "offset": 1,
                    "size": 1
                  },
                  "FFE_Shut_Down": {
                    "description": "FFE Power Domain is in Shut_Down mode",
                    "offset": 2,
                    "size": 1
                  },
                  "FFE_Clock_Gating": {
                    "description": "Power Domain is alive, Onlt related clock is gated off -- This mode is for debugging only",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "FFE_PWR_MODE_CFG": {
              "description": "Power Mode configuration for the Flexible Fusion Engine Power Domain",
              "offset": 148,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "FFE_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before kicking off the power down event.",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Power_Mode_Cfg"
                  }
                }
              }
            },
            "FFE_PD_SRC_MASK_N": {
              "description": "Control masking of busy signal. The falling edge of any of the above signals (non-mask) will put the FFE into Power saving mode base on the Power Mode Cfg. Note: These signals used to indicate the BUSY status, so they must be level signals.",
              "offset": 152,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "FFE_PD_Event_Mask": {
                    "description": "FFEs Busy Signal (FFE 0, SM 0 and SM1 Busy Signals ) Mask_N",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_PD_Event_Mask"
                  }
                }
              }
            },
            "FFE_WU_SRC_MASK_N": {
              "description": "Control the masking of the Flexible Fusion Engine wake-up event triggers",
              "offset": 156,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 511,
              "children": {
                "fields": {
                  "KickOff_Timer_Time_Out": {
                    "description": "If unmasked, kick off timer time-out event will wake up FFE.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_0_INT": {
                    "description": "If unmasked, GPIO0 interrupt will wake up FFE.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_1_INT": {
                    "description": "If unmasked, GPIO1 interrupt will wake up FFE.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_2_INT": {
                    "description": "If unmasked, GPIO2 interrupt will wake up FFE.",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_3_INT": {
                    "description": "If unmasked, GPIO3 interrupt will wake up FFE.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_4_INT": {
                    "description": "If unmasked, GPIO4 interrupt will wake up FFE.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_5_INT": {
                    "description": "If unmasked, GPIO5 interrupt will wake up FFE.",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_6_INT": {
                    "description": "If unmasked, GPIO6 interrupt will wake up FFE.",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  },
                  "Sensor_GPIO_7_INT": {
                    "description": "If unmasked, GPIO7 interrupt will wake up FFE.",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.KickOff_Timer_Time_Out"
                  }
                }
              }
            },
            "FB_STATUS": {
              "description": "FPGA Fabric Power domain status",
              "offset": 160,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "FB_Active": {
                    "description": "FPGA Fabric Power domain is active",
                    "offset": 0,
                    "size": 1
                  },
                  "FB_Deep_Sleep": {
                    "description": "FPGA Fabric Power domain is in mode",
                    "offset": 1,
                    "size": 1
                  },
                  "FB_Shut_Down": {
                    "description": "FPGA Fabric Power domain is in mode",
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "FB_PWR_MODE_CFG": {
              "description": "Power mode configuration for the FPGA Fabric Power domain",
              "offset": 164,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "FB_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before kicking off the power down event.",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.FB_Power_Mode_Cfg"
                  }
                }
              }
            },
            "FB_PD_SRC_MASK_N": {
              "description": "Control masking of power down event signals for the FPGA Fabric power domain. The falling edge of any of the listed signals (non-mask) will put the FB into Power saving mode base on the Power Mode Cfg. Note: These signals used to indicate the BUSY status, so they must be level signals.",
              "offset": 168,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "Interface_Signal_0": {
                    "description": "Control the mask for the Interface Signal 0",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Interface_Signal_0"
                  },
                  "Interface_Signal_1": {
                    "description": "Control the mask for the Interface Signal 1",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Interface_Signal_0"
                  },
                  "Interface_Signal_2": {
                    "description": "Control the mask for the Interface Signal 2",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Interface_Signal_0"
                  },
                  "Interface_Signal_3": {
                    "description": "Control the mask for the Interface Signal 3",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Interface_Signal_0"
                  }
                }
              }
            },
            "FB_WU_SRC_MASK_N": {
              "description": "Control the masking of the FPGA FAbric wake-up event triggers",
              "offset": 172,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 511,
              "children": {
                "fields": {
                  "Sensor_GPIO_0_INT": {
                    "description": "If unmasked, GPIO0 interrupt will wake up FB.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_1_INT": {
                    "description": "If unmasked, GPIO1 interrupt will wake up FB.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_2_INT": {
                    "description": "If unmasked, GPIO2 interrupt will wake up FB.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_3_INT": {
                    "description": "If unmasked, GPIO3 interrupt will wake up FB.",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_4_INT": {
                    "description": "If unmasked, GPIO4 interrupt will wake up FB.",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_5_INT": {
                    "description": "If unmasked, GPIO5 interrupt will wake up FB.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_6_INT": {
                    "description": "If unmasked, GPIO6 interrupt will wake up FB.",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "Sensor_GPIO_7_INT": {
                    "description": "If unmasked, GPIO7 interrupt will wake up FB.",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  },
                  "KickOff_Timer_Time_Out": {
                    "description": "If unmasked, kick off timer time-out event will wake up FB.",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Sensor_GPIO_0_INT"
                  }
                }
              }
            },
            "PF_STATUS": {
              "description": "PF SRAM Power Domain status",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "FB_Active": {
                    "description": "PF SRAM Power domain is active",
                    "offset": 0,
                    "size": 1
                  },
                  "FB_Deep_Sleep": {
                    "description": "PF SRAM Fabric Power domain is in mode",
                    "offset": 1,
                    "size": 1
                  },
                  "FB_Shut_Down": {
                    "description": "PF SRAM Fabric Power domain is in mode",
                    "offset": 2,
                    "size": 1
                  },
                  "FB_Clock_Gating": {
                    "description": "Reserved",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "PF_PWR_MODE_CFG": {
              "description": "Power mode configuration for the PF SRAM Power domain",
              "offset": 180,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "PF_Power_Mode_Cfg": {
                    "description": "DW need to configure the registers before kicking off the power down event",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.PF_Power_Mode_Cfg"
                  }
                }
              }
            },
            "PF_PD_SRC_MASK_N": {
              "description": "Reserved",
              "offset": 184,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "PF_WU_SRC_MASK_N": {
              "description": "Reserved",
              "offset": 188,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4S0_SRAM_STATUS": {
              "description": "M4S0 SRAM Power Domain status",
              "offset": 192,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "M4S0_Active": {
                    "description": "PF SRAM Power domain is active.",
                    "offset": 0,
                    "size": 1
                  },
                  "M4S0_Deep_Sleep": {
                    "description": "Reserved. Deep Sleep not supported for this power domain.",
                    "offset": 1,
                    "size": 1
                  },
                  "M4S0_Shut_Down": {
                    "description": "PF SRAM Fabric Power domain is in mode.",
                    "offset": 2,
                    "size": 1
                  },
                  "M4S0_Clock_Gating": {
                    "description": "Reserved",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "M4S0_PWR_MODE_CFG": {
              "description": "Power mode configuration for the M4S0 SRAM power domain",
              "offset": 196,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "M4S0_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before kicking off the power down event",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Power_Mode_Cfg"
                  }
                }
              }
            },
            "M4S0_PD_SRC_MASK_N": {
              "description": "Control masking of power-down event triggers for the M4S0 SRAM domain",
              "offset": 200,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "M4S0_PD_Event_Mask": {
                    "description": "If not mask, The M4S0 power domain will put into Power Saving Mode base on Power_Mode_cfg once M4 is entering Shut Down mode and M4S0 power domain is NOT in power saving mode.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_PD_Event_Mask"
                  }
                }
              }
            },
            "M4S0_WU_SRC_MASK_N": {
              "description": "Control masking of wake-up event triggers for the M4S0 SRAM domain",
              "offset": 204,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "M4S0_PD_Event_Mask": {
                    "description": "If not mask, The M4S0 power domain will wake up once M4 is waking up from Power Saving and M4S0 power domain is NOT in active mode.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "A1_STATUS": {
              "description": "Status of the A1 power domain",
              "offset": 208,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "M4S0_Active": {
                    "description": "A1 Power domain is active.",
                    "offset": 0,
                    "size": 1
                  },
                  "M4S0_Deep_Sleep": {
                    "description": "A1 Power domain is in retention mode",
                    "offset": 1,
                    "size": 1
                  },
                  "M4S0_Shut_Down": {
                    "description": "A1 Power domain is in mode.",
                    "offset": 2,
                    "size": 1
                  },
                  "M4S0_Clock_Gating": {
                    "description": "Reserved",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "A1_PWR_MODE_CFG": {
              "description": "Power mode configuration for the A1 power domain",
              "offset": 212,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "A1_Power_Mode_Cfg": {
                    "description": "FW need to configure the registers before kicking off the power down event",
                    "offset": 0,
                    "size": 2,
                    "enum": "types.peripherals.PMU.children.enums.A1_Power_Mode_Cfg"
                  }
                }
              }
            },
            "A1_PD_SRC_MASK_N": {
              "description": "Reserved",
              "offset": 216,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "A1_WU_SRC_MASK_N": {
              "description": "Control masking of wake-up event triggers for the A1 domain",
              "offset": 220,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "A1_WU_EVENT_MASK_M": {
                    "description": "If Boot Code Reloading after M4 wake up is needed, this bit should be set to 1.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.A1_WU_EVENT_MASK_M"
                  }
                }
              }
            },
            "MISC_STATUS": {
              "description": "I2S Power info",
              "offset": 224,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "I2S": {
                    "description": "Bit will be set if the I2S is powered on",
                    "offset": 4,
                    "size": 1
                  }
                }
              }
            },
            "AUDIO_STATUS": {
              "description": "Audio power domain status",
              "offset": 228,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "AD0": {
                    "description": "Bit is set if AD0 is on",
                    "offset": 0,
                    "size": 1
                  },
                  "AD1": {
                    "description": "Bit is set if AD1 power domain is on",
                    "offset": 1,
                    "size": 1
                  },
                  "AD2": {
                    "description": "Bit is set if AD2 power domain is on",
                    "offset": 2,
                    "size": 1
                  },
                  "AD3": {
                    "description": "Bit is set if AD3 power domain is on",
                    "offset": 3,
                    "size": 1
                  },
                  "AD4": {
                    "description": "Bit is set if AD4 power domain is on",
                    "offset": 4,
                    "size": 1
                  },
                  "AD5": {
                    "description": "Bit is set if AD5 power domain is on",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "M4_SRAM_STATUS": {
              "description": "M4 SRAM Power domain status",
              "offset": 232,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "M4S0": {
                    "description": "Bit is set if M4S0 SRAM power domain is on. Same as M4S0_SRAM_STATUS[0:0]",
                    "offset": 0,
                    "size": 1
                  },
                  "M4S1": {
                    "description": "Bit is set if M4S1 SRAM power domain is on",
                    "offset": 1,
                    "size": 1
                  },
                  "M4S2": {
                    "description": "Bit is set if M4S2 SRAM power domain is on",
                    "offset": 2,
                    "size": 1
                  },
                  "M4S3": {
                    "description": "Bit is set if M4S3 SRAM power domain is on",
                    "offset": 3,
                    "size": 1
                  },
                  "M4S4": {
                    "description": "Bit is set if M4S4 SRAM power domain is on",
                    "offset": 4,
                    "size": 1
                  },
                  "M4S5": {
                    "description": "Bit is set if M4S5 SRAM power domain is on",
                    "offset": 5,
                    "size": 1
                  },
                  "M4S6": {
                    "description": "Bit is set if M4S6 SRAM power domain is on",
                    "offset": 6,
                    "size": 1
                  },
                  "M4S7": {
                    "description": "Bit is set if M4S7 SRAM power domain is on",
                    "offset": 7,
                    "size": 1
                  },
                  "M4S8": {
                    "description": "Bit is set if M4S8 SRAM power domain is on",
                    "offset": 8,
                    "size": 1
                  },
                  "M4S9": {
                    "description": "Bit is set if M4S9 SRAM power domain is on",
                    "offset": 9,
                    "size": 1
                  },
                  "M4S10": {
                    "description": "Bit is set if M4S10 SRAM  power domain is on",
                    "offset": 10,
                    "size": 1
                  },
                  "M4S11": {
                    "description": "Bit is set if M4S11 SRAM  power domain is on",
                    "offset": 11,
                    "size": 1
                  },
                  "M4S12": {
                    "description": "Bit is set if M4S12 SRAM  power domain is on",
                    "offset": 12,
                    "size": 1
                  },
                  "M4S13": {
                    "description": "Bit is set if M4S13 SRAM  power domain is on",
                    "offset": 13,
                    "size": 1
                  },
                  "M4S14": {
                    "description": "Bit is set if M4S14 SRAM power domain is on",
                    "offset": 14,
                    "size": 1
                  },
                  "M4S15": {
                    "description": "Bit is set if M4S15 SRAM power domain is on",
                    "offset": 15,
                    "size": 1
                  }
                }
              }
            },
            "AUDIO_WU_SRC_MASK_N": {
              "description": "Control masking of wake-up event triggers for the Audio domains",
              "offset": 236,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 127,
              "children": {
                "fields": {
                  "AD0_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  },
                  "AD1_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  },
                  "AD2_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  },
                  "AD3_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  },
                  "AD4_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  },
                  "AD5_WU_Event_Mask_N": {
                    "description": "Allow external interrupt coming from pads 9 or 30 to serve as wake-up event trigger",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AD0_WU_Event_Mask_N"
                  }
                }
              }
            },
            "M4_MEM_CTRL_0": {
              "description": "Control DS pins for different SRAM instances on the M4 subsystem. For each instance: 1'b1 : Enable the Deep Sleep funciton of SRAM Macro, Memory content will be kept. While M4 access the memory in Deep Sleep mode, the HW will clear the corresponding bit.",
              "offset": 256,
              "size": 32,
              "reset_value": 65534,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "CTRL_M4_SRAM_DS_0": {
                    "description": "Control DS pin of 32KB SRAM Instance 0 on M4 subsystem",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_1": {
                    "description": "Control DS pin of 32KB SRAM Instance 1 on M4 subsystem",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_2": {
                    "description": "Control DS pin of 32KB SRAM Instance 2 on M4 subsystem",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_3": {
                    "description": "Control DS pin of 32KB SRAM Instance 3 on M4 subsystem",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_4": {
                    "description": "Control DS pin of 32KB SRAM Instance 4 on M4 subsystem",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_5": {
                    "description": "Control DS pin of 32KB SRAM Instance 5 on M4 subsystem",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_6": {
                    "description": "Control DS pin of 32KB SRAM Instance 6 on M4 subsystem",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_7": {
                    "description": "Control DS pin of 32KB SRAM Instance 7 on M4 subsystem",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_8": {
                    "description": "Control DS pin of 32KB SRAM Instance 8 on M4 subsystem",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_9": {
                    "description": "Control DS pin of 32KB SRAM Instance 9 on M4 subsystem",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_10": {
                    "description": "Control DS pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_11": {
                    "description": "Control DS pin of 32KB SRAM Instance 11 on M4 subsystem",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_12": {
                    "description": "Control DS pin of 32KB SRAM Instance 12 on M4 subsystem",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_13": {
                    "description": "Control DS pin of 32KB SRAM Instance 13 on M4 subsystem",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_14": {
                    "description": "Control DS pin of 32KB SRAM Instance 14 on M4 subsystem",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  },
                  "CTRL_M4_SRAM_DS_15": {
                    "description": "Control DS pin of 32KB SRAM Instance 15 on M4 subsystem",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_DS_0"
                  }
                }
              }
            },
            "M4_MEM_CTRL_1": {
              "description": "Control Shutdown pin for various instances of SRAM on the M4 subsystem. For each instance: 1'b1 : Enable the Shutdown funciton of SRAM Macro, Memory content will be lost. While M4 access the memory in Shutdown mode, the HW will clear the corresponding bit.",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "CTRL_M4_SRAM_SD_0": {
                    "description": "Control SD pin of 32KB SRAM Instance 0 on M4 subsystem",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_1": {
                    "description": "Control SD pin of 32KB SRAM Instance 1 on M4 subsystem",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_2": {
                    "description": "Control SD pin of 32KB SRAM Instance 2 on M4 subsystem",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_3": {
                    "description": "Control SD pin of 32KB SRAM Instance 3 on M4 subsystem",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_4": {
                    "description": "Control SD pin of 32KB SRAM Instance 4 on M4 subsystem",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_5": {
                    "description": "Control SD pin of 32KB SRAM Instance 5 on M4 subsystem",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_6": {
                    "description": "Control SD pin of 32KB SRAM Instance 6 on M4 subsystem",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_7": {
                    "description": "Control SD pin of 32KB SRAM Instance 7 on M4 subsystem",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_8": {
                    "description": "Control SD pin of 32KB SRAM Instance 8 on M4 subsystem",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_9": {
                    "description": "Control SD pin of 32KB SRAM Instance 9 on M4 subsystem",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_10": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_11": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_12": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_13": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_14": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  },
                  "CTRL_M4_SRAM_SD_15": {
                    "description": "Control SD pin of 32KB SRAM Instance 10 on M4 subsystem",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_M4_SRAM_SD_0"
                  }
                }
              }
            },
            "PF_MEM_CTRL_0": {
              "description": "RESERVED",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "PF_MEM_CTRL_1": {
              "description": "Control Shut Down pin of various FIFOs intances in the PF subsystem. For each one: 1'b1 : Enable the Shut Down function of SRAM Macro, Memory content will be lost",
              "offset": 268,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "CTRL_PF_SRAM_SD_0": {
                    "description": "Control SD Pin of FIFO_2  instances on PF subsystem",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_PF_SRAM_SD_0"
                  },
                  "CTRL_PF_SRAM_SD_8k": {
                    "description": "Control SD Pin of FIFO_8k  instances on PF subsystem",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_PF_SRAM_SD_0"
                  }
                }
              }
            },
            "FFE_MEM_CTRL_0": {
              "description": "Control the Deep Sleep pin of various elements in the Flexible Fusion Engine power domain. For each: 1'b1 : Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "CTRL_FFE_SRAM_DS_CM0": {
                    "description": "Control DS pin of CM0 8Kx40",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_DM0": {
                    "description": "Control DS pin of DM0 1Kx32",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_DM1": {
                    "description": "Control DS pin of DM1 1Kx32",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_SM0": {
                    "description": "Control DS pin of SM0 1Kx18",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_SM1": {
                    "description": "Control DS pin of SM1 0.5Kx18",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_CM1": {
                    "description": "Control DS pin of CM1 2Kx40",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_DM2": {
                    "description": "Control DS pin of CM0 1Kx32",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  },
                  "CTRL_FFE_SRAM_DS_DM3": {
                    "description": "Control DS pin of CM0 1Kx32",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_DS_CM0"
                  }
                }
              }
            },
            "FFE_MEM_CTRL_1": {
              "description": "Control the Shut Down pin of various elements in the Flexible Fusion Engine power domain. For each: 1'b1 : Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "CTRL_FFE_SRAM_SD_CM0": {
                    "description": "Control SD pin of CM0 8Kx40",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_DM0": {
                    "description": "Control SD pin of DM0 1Kx32",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_DM1": {
                    "description": "Control SD pin of DM1 1Kx32",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_SM0": {
                    "description": "Control SD pin of SM0 1Kx18",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_SM1": {
                    "description": "Control SD pin of SM1 0.5Kx18",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_CM1": {
                    "description": "Control SD pin of CM1 2Kx40",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_DM2": {
                    "description": "Control SD pin of CM0 1Kx32",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  },
                  "CTRL_FFE_SRAM_SD_DM3": {
                    "description": "Control SD pin of CM0 1Kx32",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CTRL_FFE_SRAM_SD_CM0"
                  }
                }
              }
            },
            "AUDIO_MEM_CTRL_0": {
              "description": "Control the Deep Sleep pin of Audio channels. For each: 1'b1 : Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
              "offset": 280,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "AUDIO_SRAM_LC_DS_0": {
                    "description": "Used to control DS pin of the Left Channel R0 2Kx32",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  },
                  "AUDIO_SRAM_LC_DS_1": {
                    "description": "Used to control DS pin of the Left Channel R1 128Kx32",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  },
                  "AUDIO_SRAM_LC_DS_2": {
                    "description": "Used to control DS pin of the Left Channel R2 256Kx15",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  },
                  "AUDIO_SRAM_RC_DS_0": {
                    "description": "Used to control DS pin of the Right Channel R0 2Kx32",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  },
                  "AUDIO_SRAM_RC_DS_1": {
                    "description": "Used to control DS pin of the Right Channel R1 128Kx32",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  },
                  "AUDIO_SRAM_RC_DS_2": {
                    "description": "Used to control DS pin of the Right Channel R2 256Kx15",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_DS_0"
                  }
                }
              }
            },
            "AUDIO_MEM_CTRL_1": {
              "description": "Control the shut down pin of Audio channels. For each: 1'b1 : Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
              "offset": 284,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "AUDIO_SRAM_LC_SD_0": {
                    "description": "Used to control SD pin of the Left Channel R0 2Kx32",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  },
                  "AUDIO_SRAM_LC_SD_1": {
                    "description": "Used to control SD pin of the Left Channel R1 128Kx32",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  },
                  "AUDIO_SRAM_LC_SD_2": {
                    "description": "Used to control SD pin of the Left Channel R2 256Kx15",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  },
                  "AUDIO_SRAM_RC_SD_0": {
                    "description": "Used to control SD pin of the Right Channel R0 2Kx32",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  },
                  "AUDIO_SRAM_RC_SD_1": {
                    "description": "Used to control SD pin of the Right Channel R1 128Kx32",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  },
                  "AUDIO_SRAM_RC_SD_2": {
                    "description": "Used to control SD pin of the Right Channel R2 256Kx15",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.AUDIO_SRAM_LC_SD_0"
                  }
                }
              }
            },
            "M4_MEM_CFG": {
              "description": "Reserved",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "PF_MEM_CFG": {
              "description": "Reserved",
              "offset": 292,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "FFE_MEM_CFG": {
              "description": "Control Light Sleep pin of different FFE SRAM power domains",
              "offset": 296,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "CFG_FFE_SRAM_LS_0": {
                    "description": "Control LS pin of CM",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CFG_FFE_SRAM_LS_0"
                  },
                  "CFG_FFE_SRAM_LS_1": {
                    "description": "Control LS pin of DM",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CFG_FFE_SRAM_LS_0"
                  },
                  "CFG_FFE_SRAM_LS_2": {
                    "description": "Control LS pin of SM0",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CFG_FFE_SRAM_LS_0"
                  },
                  "CFG_FFE_SRAM_LS_3": {
                    "description": "Control LS pin of SM1",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.CFG_FFE_SRAM_LS_0"
                  },
                  "General_Purpose_SFR": {
                    "description": "Reseverd.",
                    "offset": 4,
                    "size": 4
                  }
                }
              }
            },
            "AUDIO_MEM_CFG": {
              "description": "Reserved",
              "offset": 300,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4_MEM_CTRL_PWR_0": {
              "description": "Reserved",
              "offset": 304,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4_MEM_CTRL_PWR_1": {
              "description": "Reserved",
              "offset": 308,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "M4_MEM_CTRL_PWR_2": {
              "description": "Reserved",
              "offset": 312,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only"
            },
            "SDMA_MEM_CTRL_0": {
              "description": "Control the Deep Sleep function of SRAM Macro for the SDMA power domain",
              "offset": 320,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SDMA_SRAM_DS": {
                    "description": "Used to control the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_SRAM_DS"
                  }
                }
              }
            },
            "SDMA_MEM_CTRL_1": {
              "description": "Control the Shut Down function of SRAM Macro for the SDMA power domain",
              "offset": 324,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SDMA_SRAM_SD": {
                    "description": "Used to control the Shut Down function of SRAM Macro, Memory content will be lost",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_SRAM_SD"
                  }
                }
              }
            },
            "MEM_PWR_DWN_CTRL": {
              "description": "Memory Power Down Control",
              "offset": 384,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 262143,
              "children": {
                "fields": {
                  "M4_SRAM_PD_Cfg_0_M4S0": {
                    "description": "Set to put M4S0 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 0,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S1": {
                    "description": "Set to put M4S1 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 1,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S2": {
                    "description": "Set to put M4S2 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 2,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S3": {
                    "description": "Set to put M4S3 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 3,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S4": {
                    "description": "Set to put M4S4 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 4,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S5": {
                    "description": "Set to put M4S5 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 5,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S6": {
                    "description": "Set to put M4S6 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 6,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S7": {
                    "description": "Set to put M4S7 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 7,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S8": {
                    "description": "Set to put M4S8 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 8,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S9": {
                    "description": "Set to put M4S9 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 9,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S10": {
                    "description": "Set tout M4S10 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 10,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_0_M4S11": {
                    "description": "Set to put M4S11 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 11,
                    "size": 1
                  },
                  "M4_SRAM_PD_Cfg_1_M4S12": {
                    "description": "Set to put M4S12 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 12,
                    "size": 1,
                    "access": "read-only"
                  },
                  "M4_SRAM_PD_Cfg_1_M4S13": {
                    "description": "Set to put M4S13 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 13,
                    "size": 1,
                    "access": "read-only"
                  },
                  "M4_SRAM_PD_Cfg_1_M4S14": {
                    "description": "Set to put M4S14 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 14,
                    "size": 1,
                    "access": "read-only"
                  },
                  "M4_SRAM_PD_Cfg_1_M4S15": {
                    "description": "Set to put M4S15 to Deep Sleep mode if M4 is in Shut Down Mode",
                    "offset": 15,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FFE_SRAM_PD_Cfg": {
                    "description": "Set to assert the DS pin of the SRAM Macro inside FFE power domain if FFE power domain is in Deep Sleep ",
                    "offset": 16,
                    "size": 1
                  },
                  "PF_SRAM_PD_Cfg": {
                    "description": "Set to assert the DS pin of the SRAM Macro inside PF power domain if PF power domain is in Deep Sleep ",
                    "offset": 17,
                    "size": 1
                  },
                  "SDMA_SRAM_PD_Cfg": {
                    "description": "Set to assert the DS pin of the SRAM Macro inside SDMA power domain if SDMA power domain is in Deep Sleep or Shut Down Mode.",
                    "offset": 18,
                    "size": 1
                  }
                }
              }
            },
            "PMU_TIMER_CFG_0": {
              "description": "Configuration for the PMU timer time-out period",
              "offset": 388,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 2047,
              "children": {
                "fields": {
                  "PMU_Time_Out_period": {
                    "description": "PMU timer is 16 bits running at 32KHZ. Once PMU timer bit 15:6 match the value of this register, PMUT INT will trigger and Timer will stop.  0 is a reserved value, min must be load value is 1.",
                    "offset": 0,
                    "size": 10
                  }
                }
              }
            },
            "PMU_TIMER_CFG_1": {
              "description": "Control wether the PMU timer is enabled or disabled",
              "offset": 392,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "PMU_Timer_Enable": {
                    "description": "Set to enable PMU timer.  Once disable, the PMU timer will be reset to all 0. FW need to disable the PMU timer once PMUT INT trigger. Please Note: It may take Up to 64uS to disable the time since this enable signal needs to sync to 32KHz clock domain from C10/C01 clock domain",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PDWU_Timer_CFG": {
              "description": "Control the delay for power-on after wake-up event. Applies to all power domains",
              "offset": 396,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "PDWU_Timer_period": {
                    "description": "This is to define the additional IDLE cycles after Power Gating cell is off (Power is ON). This configuration applied to all power domain. Waits for reg value + 1 cycles, i.e. 0 - 1 cycle, 2 - 3 cycles, etc.",
                    "offset": 0,
                    "size": 3
                  }
                }
              }
            },
            "FFE_FB_PF_SW_PD": {
              "description": "Registers for triggering power-down events in the FFE, FB and PF power domains.",
              "offset": 512,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "FFE_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_PD"
                  },
                  "FB_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_PD"
                  },
                  "PF_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_PD"
                  }
                }
              }
            },
            "M4_SRAM_SW_PD": {
              "description": "Register for triggering power-down events in M4 SRAM power domains. (RWHC)",
              "offset": 516,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "M4S0_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S1_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S2_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S3_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S4_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S5_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S6_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S7_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S8_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S9_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S10_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S11_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S12_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S13_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S14_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  },
                  "M4S15_Software_PD": {
                    "description": "Set to trigger a power down event. Bit is cleared after power down sequence finishes",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_PD"
                  }
                }
              }
            },
            "MISC_SW_PD": {
              "description": "Register for triggering power down events in MISC power domains + some general purpose SFR's (RWHC)",
              "offset": 520,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "SDMA_Software_PD": {
                    "description": "System DMA Power Domain. Set to put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_PD"
                  },
                  "General_Purpose_1": {
                    "description": "General purpose SFR",
                    "offset": 1,
                    "size": 1
                  },
                  "General_Purpose_2": {
                    "description": "General purpose SFR",
                    "offset": 2,
                    "size": 1
                  },
                  "General_Purpose_3": {
                    "description": "General purpose SFR",
                    "offset": 3,
                    "size": 1
                  },
                  "I2S_Software_PD": {
                    "description": "Reserved for Future Use -- Power Domain. Set to put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_PD"
                  },
                  "A1_Software_PD": {
                    "description": "Reserved for Future Use -- Power Domain. Set to put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_PD"
                  }
                }
              }
            },
            "AUDIO_SW_PD": {
              "description": "Register for triggering power-down events in Audio power domains. (RWHC)",
              "offset": 524,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 0,
              "children": {
                "fields": {
                  "Audio_AD0_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  },
                  "Audio_AD1_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  },
                  "Audio_AD2_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  },
                  "Audio_AD3_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  },
                  "Audio_AD4_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  },
                  "Audio_AD5_PD": {
                    "description": "Set to trigger a power down event. Bit will be cleared once power down sequence is finished",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_PD"
                  }
                }
              }
            },
            "FFE_FB_PF_SW_WU": {
              "description": "Registers for triggering wake-up events in the FFE, FB and PF power domains.",
              "offset": 528,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "FFE_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_WU"
                  },
                  "FB_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_WU"
                  },
                  "PF_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.FFE_Software_WU"
                  }
                }
              }
            },
            "M4_SRAM_SW_WU": {
              "description": "Register for triggering wake-up events in M4 SRAM power domains. (RWHC)",
              "offset": 532,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "M4S0_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S1_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S2_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S3_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S4_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S5_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S6_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S7_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S8_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S9_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S10_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 10,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S11_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S12_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 12,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S13_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 13,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S14_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 14,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  },
                  "M4S15_Software_WU": {
                    "description": "Set to trigger a wake up event. Bit is cleared after wake up sequence finishes",
                    "offset": 15,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.M4S0_Software_WU"
                  }
                }
              }
            },
            "MISC_SW_WU": {
              "description": "Register for triggering wake up events in MISC power domains + some general purpose SFR's (RWHC)",
              "offset": 536,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "SDMA_Software_WU": {
                    "description": "SDMA Power Domain. Set to wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_WU"
                  },
                  "General_Purpose_1": {
                    "description": "General purpose SFR",
                    "offset": 1,
                    "size": 1
                  },
                  "General_Purpose_2": {
                    "description": "General purpose SFR",
                    "offset": 2,
                    "size": 1
                  },
                  "General_Purpose_3": {
                    "description": "General purpose SFR",
                    "offset": 3,
                    "size": 1
                  },
                  "I2S_Software_WU": {
                    "description": "Reserved Logic Power Domain. Set to wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_WU"
                  },
                  "A1_Software_WU": {
                    "description": "Reserved Logic Power Domain. Set to wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.SDMA_Software_WU"
                  }
                }
              }
            },
            "AUDIO_SRAM_SW_WU": {
              "description": "Register for triggering wake-up events in Audio power domains. (RWHC)",
              "offset": 540,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 0,
              "children": {
                "fields": {
                  "Audio_AD0_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  },
                  "Audio_AD1_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  },
                  "Audio_AD2_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  },
                  "Audio_AD3_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  },
                  "Audio_AD4_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  },
                  "Audio_AD5_WU": {
                    "description": "Set to trigger a wake up event. Bit will be cleared once wake up sequence is finished",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.Audio_AD0_WU"
                  }
                }
              }
            },
            "PMU_STM_PRIORITY": {
              "description": "Power Management Unit Software Test Mode priority control",
              "offset": 544,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "PMU_STM_PRIORITY": {
                    "description": "Controls how PMU STM and M4/FFE STM will be arbitrated. ",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.PMU.children.enums.PMU_STM_PRIORITY"
                  }
                }
              }
            },
            "M4SRAM_SSW_LPMF": {
              "description": "Control for M4SRAM power domain light sleep mode",
              "offset": 560,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "M4SRAM_LPMF": {
                    "description": "Enable or disable Light Sleep Mode. If M4 SRAM power is removing, the corresponding bit will be clear.",
                    "offset": 0,
                    "size": 16,
                    "enum": "types.peripherals.PMU.children.enums.M4SRAM_LPMF"
                  }
                }
              }
            },
            "M4SRAM_SSW_LPMH_MASK_N": {
              "description": "Control masking for the LPMH (Low Power Mode header - deep sleep circuit)",
              "offset": 564,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "M4SRAM_LPMH_MASK_N": {
                    "description": "if M4 SRAM power is removing Or SRAM is auto waking up from Deep Sleep Mode, the corresponding bit will be clear.",
                    "offset": 0,
                    "size": 16,
                    "enum": "types.peripherals.PMU.children.enums.M4SRAM_LPMH_MASK_N"
                  }
                }
              }
            },
            "FBVLPMinWidth": {
              "description": "Configuration for the amount of IDLE cycles before powering on the FB domain",
              "offset": 1000,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 73300775185,
              "children": {
                "fields": {
                  "FBVLPMinWidth": {
                    "description": "For FB, it required additional IDLE Cylcle from turning off power gates (Power is ON) to ready for normal operation. This is used to defined the # of the IDLE cycles (base on C01 Clock). According to FB spec, it will require 10uS. But for final spec, it should be from FB design team.",
                    "offset": 0,
                    "size": 10
                  }
                }
              }
            },
            "APRebootStatus": {
              "description": "Indicates if AP nees to reload the code to SRAM",
              "offset": 1004,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "APRebootStatus": {
                    "description": "Set to indicate the AP need to reload the code to SRAM HW set to 1 and FW can clear it. This is allowed FW@AP to read this status.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "GEN_PURPOSE_0": {
              "description": "Configure FB config enable and wether Audio SRAM can be put into Deep Sleep by the Audio hardware",
              "offset": 1008,
              "size": 32,
              "reset_value": 512,
              "reset_mask": 1023,
              "children": {
                "fields": {
                  "General_Purpose": {
                    "description": "General purpose SFR",
                    "offset": 0,
                    "size": 8
                  },
                  "Audio_SRAM_HW_DS_Cfg": {
                    "description": "Set to allow audio HW to put the Audio SRAM into Deep Sleep mode. Please see Audio Spec for detail",
                    "offset": 8,
                    "size": 1
                  },
                  "FB_Cfg_Enable": {
                    "description": "Set to enable FB configuration. Hardware will set once entering FB shutdown mode",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            },
            "FB_ISOLATION": {
              "description": "Control the FB Isolation",
              "offset": 1012,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "Enable_the_FB_Isolation": {
                    "description": "This bit will be set to 1 if FB is waking up from shut down mode. The FB interface wil be kept in isolation the domain, except for the FB configuration interface itself",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "GEN_PURPOSE_1": {
              "description": "Control for: Wether ext-interrupt can be used to wake up FFE, and clock switching for FFE/M4 power domains",
              "offset": 1016,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "LOW_POWER_Mode": {
                    "description": "Set to enable the low power mdoe",
                    "offset": 0,
                    "size": 1
                  },
                  "LOW_POWER_MODE_M4": {
                    "description": "Set to use M4 Power State to Turn on/off OSC and switching the Clock between OSC and RTC if Bit 0 is 1",
                    "offset": 1,
                    "size": 1
                  },
                  "LOW_POWER_MODE_FFE": {
                    "description": "Set to use FFE Power State to Turn on/off OSC and switching the Clock between OSC and RTC if Bit 0 is 1.",
                    "offset": 2,
                    "size": 1
                  },
                  "Kickoff_FFE_use_INT": {
                    "description": "Set to use external INT to wake up FFE.",
                    "offset": 3,
                    "size": 1
                  },
                  "General_Purpose": {
                    "description": "General purpose SFR",
                    "offset": 4,
                    "size": 4
                  }
                }
              }
            }
          },
          "enums": {
            "M4_Rst_Release": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "keep_on_reset": {
                    "description": "Keep M4 Core on Reset",
                    "value": 0
                  },
                  "release_from_reset": {
                    "description": "Release M4 Core Reset",
                    "value": 1
                  }
                }
              }
            },
            "Cfg_fpd_on": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "wakeup_flash": {
                    "description": "The SPI is in Power Down Mode. If set, flash will be woken up",
                    "value": 1
                  }
                }
              }
            },
            "Sys_rst_as_int": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "sys_rst_as_chip_rst": {
                    "description": "Treat SYSTEM Reset as Chip Reset",
                    "value": 0
                  },
                  "sys_rst_pin_as_exti": {
                    "description": "Reconfigure the SYSTEM Reset pin as the external interrupt pin",
                    "value": 1
                  }
                }
              }
            },
            "Sys_rst_as_int_pw": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "pulse_1S_2S": {
                    "description": "PWM must be 1S ~ 2S  for Reset INT",
                    "value": 0
                  },
                  "pulse_2S_3S": {
                    "description": "PWM must be 2S ~ 3S  for Reset INT",
                    "value": 1
                  },
                  "pulse_3S_4S": {
                    "description": "PWM must be 3S ~ 4S  for Reset INT",
                    "value": 2
                  },
                  "pulse_4S_5S": {
                    "description": "PWM must be 4S ~ 5S  for Reset INT",
                    "value": 3
                  }
                }
              }
            },
            "Sys_rst_pulse_ext": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "after_4s": {
                    "description": "4S after INT trigger",
                    "value": 0
                  },
                  "after_8s": {
                    "description": "8S after INT trigger",
                    "value": 1
                  }
                }
              }
            },
            "SPI_Reboot_enable_N": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "spi_flash_code_reload": {
                    "description": "Need cfgSM to reload the code when M4 waking up from SD (Mode1)",
                    "value": 0
                  }
                }
              }
            },
            "AP_Reboot_enable_N": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "ap_code_reload": {
                    "description": "Need AP to reload the code when M4 waking up from SD (Mode1)",
                    "value": 0
                  }
                }
              }
            },
            "FFE0_BUSY": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "not_busy": {
                    "description": "FFE0 is not busy",
                    "value": 0
                  },
                  "busy": {
                    "description": "FFE0 is busy",
                    "value": 1
                  }
                }
              }
            },
            "Code_Source_Cfg": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "spi_flash": {
                    "description": "From SPI Flash, if SWD_Mode_Cfg is 1, CfgSM will not be kicked off.",
                    "value": 0
                  },
                  "ap": {
                    "description": "From AP",
                    "value": 1
                  }
                }
              }
            },
            "Debug_Port_Cfg": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "swd_pads_5_6": {
                    "description": "SW_CLK @pad[5], SW_IO @pad[6] ",
                    "value": 0
                  },
                  "swd_pads_27_26": {
                    "description": "SW_CLK @pad[27], SW_IO @pad[26]",
                    "value": 1
                  }
                }
              }
            },
            "SWD_Mode_Cfg": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "if_swd_release_m4_on_rest": {
                    "description": "SWD debugger is attached. Release the M4 Core reset once System Reset released.",
                    "value": 1
                  }
                }
              }
            },
            "CLOCK_BYPASS_Cfg": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "external_clock_configured": {
                    "description": "The System Clock Source is from the I/O PAD instead of OSC if Debug_port_cfg is 1 as well.",
                    "value": 1
                  }
                }
              }
            },
            "FFEFB_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If FFE and FB WU event happen at same time, FB will wake up first, then FFE. ",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If FFE and FB WU event happen at same time, FFE and FB will wake up in parallel",
                    "value": 1
                  }
                }
              }
            },
            "SRAM_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If more than one SRAM (M4S1 ~ M4S15) WU event happen at same time, these SRAMs will wake up in the following priority.  M4S1->M4S2->.->M4S14-> M4S15 (M4S1 has the highest priority and M4S15 has the lowest priority)",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If more than one SRAM(M4S1 ~ M4S15, NOT include M4S0) WU event happen at same time, these SRAMs will wake up in parallel. ",
                    "value": 1
                  }
                }
              }
            },
            "AUDIO_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If more than one AUDIO Blocks (AD0 ~ AD5) WU event happen at same time,  these Blocks will wake up in the following priority. AD5->AD1->AD2->AD0->AD3->AD4. (AD5 has the highest priority and AD4 has the lowest priority)",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If more than one AUDIO Blocks (AD0 ~ AD5) WU event happen at same time, these AUDIO power domain will wake up in parallel",
                    "value": 1
                  }
                }
              }
            },
            "M4M4S0_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "Not defined. guess: First M4 then M4S0",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If M4 and M4S0 WU event happen at same time, then M4 and M4S0 will wake up at same time",
                    "value": 1
                  }
                }
              }
            },
            "FFEFB_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If FFE and FB PD event happen at same time, FB will power down first, then FFE. ",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If FFE and FB PD event happen at same time, FFE and FB will power down in parallel",
                    "value": 1
                  }
                }
              }
            },
            "SRAM_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If more than one SRAM (M4S1 ~ M4S15) PD event happen at same time, these SRAMs will power down in the following priority.  M4S1->M4S2->.->M4S14-> M4S15 (M4S1 has the highest priority and M4S15 has the lowest priority)",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If more than one SRAM (M4S1 ~ M4S15, NOT include M4S0) PD event happen at same time, these SRAMs will power down in parallel. ",
                    "value": 1
                  }
                }
              }
            },
            "AUDIO_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "If more than one AUDIO Blocks (AD0 ~ AD5) PD event happen at same time,  these Blocks will power down in the following priority. AD5->AD1->AD2->AD0->AD3->AD4. (AD5 has the highest priority and AD4 has the lowest priority)",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If more than one AUDIO Blocks (AD0 ~ AD5) PD event happen at same time, these AUDIO power domain will power down in parallel",
                    "value": 1
                  }
                }
              }
            },
            "M4M4S0_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "secuential": {
                    "description": "Not defined. guess: First M4 then M4S0",
                    "value": 0
                  },
                  "parallel": {
                    "description": "If M4 and M4S0 PD event happen at same time, then M4 and M4S0 will put into power saving mode at same time",
                    "value": 1
                  }
                }
              }
            },
            "SDMA_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "retention_mode": {
                    "description": "Retention Mode",
                    "value": 1
                  },
                  "shut_down_mode": {
                    "description": "Shut Down Mode ",
                    "value": 2
                  }
                }
              }
            },
            "SDMA_PD_EVENT": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "SDMA HW Power Down Event will be masked.",
                    "value": 0
                  },
                  "undefined": {
                    "description": "Undefined Behaviour. Probably unmasks the Power Down event.",
                    "value": 1
                  }
                }
              }
            },
            "M4_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "shut_down_mode": {
                    "description": "Configure power down event for shut down mode",
                    "value": 2
                  }
                }
              }
            },
            "FFE_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "deep_sleep_mode": {
                    "description": "Configure power down event for deep sleep mode",
                    "value": 1
                  },
                  "shut_down_mode": {
                    "description": "Configure power down event for shut down mode",
                    "value": 2
                  }
                }
              }
            },
            "FFE_PD_Event_Mask": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Masks the busy signal sources",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Will unmask the busy signal sources",
                    "value": 1
                  }
                }
              }
            },
            "KickOff_Timer_Time_Out": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt as a wake-up event source",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt as a wake-up event source",
                    "value": 1
                  }
                }
              }
            },
            "FB_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "deep_sleep_mode": {
                    "description": "Configure power down event for deep sleep mode",
                    "value": 1
                  },
                  "shut_down_mode": {
                    "description": "Configure power down event for shut down mode",
                    "value": 2
                  }
                }
              }
            },
            "Interface_Signal_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the signal as a power-down event source",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the signal as a power-down event source",
                    "value": 1
                  }
                }
              }
            },
            "Sensor_GPIO_0_INT": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt as a wake-up event source",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt as a wake-up event source",
                    "value": 1
                  }
                }
              }
            },
            "PF_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "deep_sleep_mode": {
                    "description": "Configure power down event for deep sleep mode",
                    "value": 1
                  },
                  "shut_down_mode": {
                    "description": "Configure power down event for shut down mode",
                    "value": 2
                  }
                }
              }
            },
            "M4S0_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "shut_down_mode": {
                    "description": "Configure power down event for shut down mode",
                    "value": 2
                  }
                }
              }
            },
            "M4S0_PD_Event_Mask": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "M4S0 SRAM Power Down Event will be masked.",
                    "value": 0
                  },
                  "undefined": {
                    "description": "Undefined Behaviour. Probably unmasks the Power Down event.",
                    "value": 1
                  }
                }
              }
            },
            "A1_Power_Mode_Cfg": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "retention_mode": {
                    "description": "Retention Mode",
                    "value": 1
                  },
                  "shut_down_mode": {
                    "description": "Shut Down Mode ",
                    "value": 2
                  }
                }
              }
            },
            "A1_WU_EVENT_MASK_M": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the M4 Wakeup event as the trigger for the A1 wake-up event ",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask M4 wake-up event as the trigger for the A1 wake-up",
                    "value": 1
                  }
                }
              }
            },
            "AD0_WU_Event_Mask_N": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the external interrupts from pads 9 or 30 as wake-up event triggers",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the external interrupts from pads 9 or 30 as wake-up event triggers",
                    "value": 1
                  }
                }
              }
            },
            "CTRL_M4_SRAM_DS_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_deep_sleep": {
                    "description": "Disable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 0
                  },
                  "enable_deep_sleep": {
                    "description": "Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 1
                  }
                }
              }
            },
            "CTRL_M4_SRAM_SD_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_shut_down": {
                    "description": "Disable the shut down function of SRAM Macro. ",
                    "value": 0
                  },
                  "enable_shut_down": {
                    "description": "Enable the shut down function of SRAM Macro, Memory content will be lost. ",
                    "value": 1
                  }
                }
              }
            },
            "CTRL_PF_SRAM_SD_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_shut_down": {
                    "description": "Disable the shut down function of SRAM Macro.",
                    "value": 0
                  },
                  "enable_shut_down": {
                    "description": "Enable the shut down function of SRAM Macro, Memory content will be lost. ",
                    "value": 1
                  }
                }
              }
            },
            "CTRL_FFE_SRAM_DS_CM0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_deep_sleep": {
                    "description": "Disable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 0
                  },
                  "enable_deep_sleep": {
                    "description": "Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 1
                  }
                }
              }
            },
            "CTRL_FFE_SRAM_SD_CM0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_shut_down": {
                    "description": "Disable the shut down function of SRAM Macro. ",
                    "value": 0
                  },
                  "enable_shut_down": {
                    "description": "Enable the shut down function of SRAM Macro, Memory content will be lost. ",
                    "value": 1
                  }
                }
              }
            },
            "AUDIO_SRAM_LC_DS_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_deep_sleep": {
                    "description": "Disable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 0
                  },
                  "enable_deep_sleep": {
                    "description": "Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 1
                  }
                }
              }
            },
            "AUDIO_SRAM_LC_SD_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_shut_down": {
                    "description": "Disable the shut down function of SRAM Macro. ",
                    "value": 0
                  },
                  "enable_shut_down": {
                    "description": "Enable the shut down function of SRAM Macro, Memory content will be lost. ",
                    "value": 1
                  }
                }
              }
            },
            "CFG_FFE_SRAM_LS_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_light_sleep": {
                    "description": "Disable, never put SRAM into Light Sleep mode.",
                    "value": 0
                  },
                  "enable_light_sleep": {
                    "description": "Enable, Allow the Hardware control Light Speed pin of SRAM macro directly.",
                    "value": 1
                  }
                }
              }
            },
            "SDMA_SRAM_DS": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_deep_sleep": {
                    "description": "Disable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 0
                  },
                  "enable_deep_sleep": {
                    "description": "Enable the Deep Sleep function of SRAM Macro, Memory content will be kept. ",
                    "value": 1
                  }
                }
              }
            },
            "SDMA_SRAM_SD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_shut_down": {
                    "description": "Disable the shut down function of SRAM Macro. ",
                    "value": 0
                  },
                  "enable_shut_down": {
                    "description": "Enable the shut down function of SRAM Macro, Memory content will be lost. ",
                    "value": 1
                  }
                }
              }
            },
            "FFE_Software_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "power_down": {
                    "description": " Put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "M4S0_Software_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "power_down": {
                    "description": " Put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "SDMA_Software_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "power_down": {
                    "description": " Put the power domain to power saving mode according to configuration setting, HW will clear it once power down sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "Audio_AD0_PD": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "power_down": {
                    "description": "Put the power domain to shut down, HW will clear it once power down sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "FFE_Software_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "wake_up": {
                    "description": "wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "M4S0_Software_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "wake_up": {
                    "description": "wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "SDMA_Software_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "wake_up": {
                    "description": "wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "Audio_AD0_WU": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "wake_up": {
                    "description": "wake up power domain,  HW will clear it once power up  sequence is finished.",
                    "value": 1
                  }
                }
              }
            },
            "PMU_STM_PRIORITY": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "simultaneous": {
                    "description": "Audio/SRAM PMU STM (State Machine) and M4/FFE PMU STM could run at same time.",
                    "value": 0
                  },
                  "round_robin": {
                    "description": "Audio/SRAM PMU STM and M4/FFE PMU STM will be arbitrate in Round Robin Scheme ",
                    "value": 1
                  }
                }
              }
            },
            "M4SRAM_LPMF": {
              "size": 16,
              "children": {
                "enum_fields": {
                  "enable_light_sleep": {
                    "description": " Enable M4 SRAM Light Sleep Mode.",
                    "value": 1
                  }
                }
              }
            },
            "M4SRAM_LPMH_MASK_N": {
              "size": 16,
              "children": {
                "enum_fields": {
                  "lpmh_de_assert": {
                    "description": "M4 SRAM's LPMH will be de-asserted ",
                    "value": 0
                  },
                  "let_m4_mem_ctrl_0_control": {
                    "description": "M4_MEM_CTRL_0 will control the corresponding M4 SRAM's LPMH",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "SDMA_Bridge": {
        "description": "System Direct Memory Access Bridge",
        "children": {
          "registers": {
            "DMA_REQ": {
              "description": "DMA request",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_req": {
                    "description": "Burst DMA request send to System DMA",
                    "offset": 0,
                    "size": 11,
                    "access": "write-only"
                  },
                  "dma_sreq": {
                    "description": "Single DMA request send to System DMA",
                    "offset": 16,
                    "size": 11,
                    "access": "write-only"
                  }
                }
              }
            },
            "DMA_WAITONREQ_REG": {
              "description": "DMA wait on request register",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_waitonreq": {
                    "description": "waitonreq signal send to System DMA",
                    "offset": 0,
                    "size": 11
                  }
                }
              }
            },
            "DMA_ACTIVE_REG": {
              "description": "dma_active signal status from System DMA",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_active": {
                    "description": "dma_active signal status from System DMA",
                    "offset": 0,
                    "size": 11,
                    "access": "read-only"
                  }
                }
              }
            },
            "SDMA_PWRD_CNT": {
              "description": "sdma power down event threshold. If sdma stays in idle cycles longer than the threshold, sdma will be automaticlly put into power down to save power.",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "sdma_pwrdn_cnt": {
                    "description": "sdma power down event threshold. If sdma stays in idle cycles longer than the threshold, sdma will be automaticlly put into power down to save power.",
                    "offset": 0,
                    "size": 14
                  }
                }
              }
            },
            "SDMA_SRAM_CTL": {
              "description": "Control register for System DMA SRAM",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "sdma_sram_test1": {
                    "description": "Set this bit to enable Test mode",
                    "offset": 0,
                    "size": 1
                  },
                  "sdma_sram_rme": {
                    "description": "Set to enable SRAM timing adjust enable",
                    "offset": 1,
                    "size": 1
                  },
                  "sdma_sram_rm": {
                    "description": "SRAM adjust timing value",
                    "offset": 2,
                    "size": 4
                  }
                }
              }
            }
          }
        }
      },
      "SDMA_SRAM": {
        "description": "System DMA SRAM",
        "children": {
          "registers": {
            "SRC_DATA_END_PTR_CH0": {
              "description": "Primary pointer to the end address of the source data of channel 0",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH0": {
                    "description": "Primary pointer to the end address of the source data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH0": {
              "description": "Primary pointer to the end address of the destination data of channel 0",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH0": {
                    "description": "Primary pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH0": {
              "description": "Primary configuration for channel 0",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH1": {
              "description": "Primary pointer to the end address of the source data of channel 1",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH1": {
                    "description": "Primary pointer to the end address of the source data of channel 1",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH1": {
              "description": "Primary pointer to the end address of the destination data of channel 1",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH1": {
                    "description": "Primary pointer to the end address of the destination data of channel 1",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH1": {
              "description": "Primary configuration for channel 1",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH2": {
              "description": "Primary pointer to the end address of the source data of channel 2",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH0": {
                    "description": "Primary pointer to the end address of the source data of channel 2",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH2": {
              "description": "Primary pointer to the end address of the destination data of channel 2",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH2": {
                    "description": "Primary pointer to the end address of the destination data of channel 2",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH2": {
              "description": "Primary configuration for channel 2",
              "offset": 40,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH3": {
              "description": "Primary pointer to the end address of the source data of channel 3",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH3": {
                    "description": "Primary pointer to the end address of the source data of channel 3",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH3": {
              "description": "Primary pointer to the end address of the destination data of channel 3",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH3": {
                    "description": "Primary pointer to the end address of the destination data of channel 3",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH3": {
              "description": "Primary configuration for channel 3",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH4": {
              "description": "Primary pointer to the end address of the source data of channel 4",
              "offset": 64,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH4": {
                    "description": "Primary pointer to the end address of the source data of channel 4",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH4": {
              "description": "Primary pointer to the end address of the destination data of channel 4",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH4": {
                    "description": "Primary pointer to the end address of the destination data of channel 4",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH4": {
              "description": "Primary configuration for channel 4",
              "offset": 72,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH5": {
              "description": "Primary pointer to the end address of the source data of channel 5",
              "offset": 80,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH5": {
                    "description": "Primary pointer to the end address of the source data of channel 5",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH5": {
              "description": "Primary pointer to the end address of the destination data of channel 5",
              "offset": 84,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH5": {
                    "description": "Primary pointer to the end address of the destination data of channel 5",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH5": {
              "description": "Primary configuration for channel 5",
              "offset": 88,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH6": {
              "description": "Primary pointer to the end address of the source data of channel 6",
              "offset": 96,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH6": {
                    "description": "Primary pointer to the end address of the source data of channel 6",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH6": {
              "description": "Primary pointer to the end address of the destination data of channel 6",
              "offset": 100,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH6": {
                    "description": "Primary pointer to the end address of the destination data of channel 6",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH6": {
              "description": "Primary configuration for channel 6",
              "offset": 104,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH7": {
              "description": "Primary pointer to the end address of the source data of channel 7",
              "offset": 112,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH7": {
                    "description": "Primary pointer to the end address of the source data of channel 7",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH7": {
              "description": "Primary pointer to the end address of the destination data of channel 7",
              "offset": 116,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH7": {
                    "description": "Primary pointer to the end address of the destination data of channel 7",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH7": {
              "description": "Primary configuration for channel 7",
              "offset": 120,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH8": {
              "description": "Primary pointer to the end address of the source data of channel 8",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH8": {
                    "description": "Primary pointer to the end address of the source data of channel 8",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH8": {
              "description": "Primary pointer to the end address of the destination data of channel 8",
              "offset": 132,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH8": {
                    "description": "Primary pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH8": {
              "description": "Primary configuration for channel 8",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH9": {
              "description": "Primary pointer to the end address of the source data of channel 9",
              "offset": 144,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH9": {
                    "description": "Primary pointer to the end address of the source data of channel 9",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH9": {
              "description": "Primary pointer to the end address of the destination data of channel 9",
              "offset": 148,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH9": {
                    "description": "Primary pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH9": {
              "description": "Primary configuration for channel 9",
              "offset": 152,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH10": {
              "description": "Primary pointer to the end address of the source data of channel 10",
              "offset": 160,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH10": {
                    "description": "Primary pointer to the end address of the source data of channel 10",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH10": {
              "description": "Primary pointer to the end address of the destination data of channel 10",
              "offset": 164,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH10": {
                    "description": "Primary pointer to the end address of the destination data of channel 10",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH10": {
              "description": "Primary configuration for channel 10",
              "offset": 168,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH11": {
              "description": "Primary pointer to the end address of the source data of channel 11",
              "offset": 176,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH11": {
                    "description": "Primary pointer to the end address of the source data of channel 11",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH11": {
              "description": "Primary pointer to the end address of the destination data of channel 11",
              "offset": 180,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH11": {
                    "description": "Primary pointer to the end address of the destination data of channel 11",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH11": {
              "description": "Primary configuration for channel 11",
              "offset": 184,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH12": {
              "description": "Primary pointer to the end address of the source data of channel 12",
              "offset": 192,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH12": {
                    "description": "Primary pointer to the end address of the source data of channel 12",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH12": {
              "description": "Primary pointer to the end address of the destination data of channel 12",
              "offset": 196,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH12": {
                    "description": "Primary pointer to the end address of the destination data of channel 12",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH12": {
              "description": "Primary configuration for channel 12",
              "offset": 200,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH13": {
              "description": "Primary pointer to the end address of the source data of channel 13",
              "offset": 208,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH13": {
                    "description": "Primary pointer to the end address of the source data of channel 13",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH13": {
              "description": "Primary pointer to the end address of the destination data of channel 13",
              "offset": 212,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH13": {
                    "description": "Primary pointer to the end address of the destination data of channel 13",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH13": {
              "description": "Primary configuration for channel 13",
              "offset": 216,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH14": {
              "description": "Primary pointer to the end address of the source data of channel 14",
              "offset": 224,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH14": {
                    "description": "Primary pointer to the end address of the source data of channel 14",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH14": {
              "description": "Primary pointer to the end address of the destination data of channel 14",
              "offset": 228,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH14": {
                    "description": "Primary pointer to the end address of the destination data of channel 14",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH14": {
              "description": "Primary configuration for channel 14",
              "offset": 232,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "SRC_DATA_END_PTR_CH15": {
              "description": "Primary pointer to the end address of the source data of channel 15",
              "offset": 240,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SRC_DATA_END_PTR_CH15": {
                    "description": "Primary pointer to the end address of the source data of channel 15",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DST_DATA_END_PTR_CH15": {
              "description": "Primary pointer to the end address of the destination data of channel 15",
              "offset": 244,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DST_DATA_END_PTR_CH15": {
                    "description": "Primary pointer to the end address of the destination data of channel 15",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "CH_CFG_CH15": {
              "description": "Primary configuration for channel 15",
              "offset": 248,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH0": {
              "description": "Alternate pointer to the end address of the source data of channel 0",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH0": {
                    "description": "Alternate pointer to the end address of the source data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH0": {
              "description": "Alternate pointer to the end address of the destination data of channel 0",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH0": {
                    "description": "Alternate pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH0": {
              "description": "Primary configuration for channel 0",
              "offset": 264,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH1": {
              "description": "Alternate pointer to the end address of the source data of channel 1",
              "offset": 272,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH1": {
                    "description": "Alternate pointer to the end address of the source data of channel 1",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH1": {
              "description": "Alternate pointer to the end address of the destination data of channel 1",
              "offset": 276,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH1": {
                    "description": "Alternate pointer to the end address of the destination data of channel 1",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH1": {
              "description": "Primary configuration for channel 1",
              "offset": 280,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH2": {
              "description": "Alternate pointer to the end address of the source data of channel 2",
              "offset": 288,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH0": {
                    "description": "Alternate pointer to the end address of the source data of channel 2",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH2": {
              "description": "Alternate pointer to the end address of the destination data of channel 2",
              "offset": 292,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH2": {
                    "description": "Alternate pointer to the end address of the destination data of channel 2",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH2": {
              "description": "Primary configuration for channel 2",
              "offset": 296,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH3": {
              "description": "Alternate pointer to the end address of the source data of channel 3",
              "offset": 304,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH3": {
                    "description": "Alternate pointer to the end address of the source data of channel 3",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH3": {
              "description": "Alternate pointer to the end address of the destination data of channel 3",
              "offset": 308,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH3": {
                    "description": "Alternate pointer to the end address of the destination data of channel 3",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH3": {
              "description": "Primary configuration for channel 3",
              "offset": 312,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH4": {
              "description": "Alternate pointer to the end address of the source data of channel 4",
              "offset": 320,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH4": {
                    "description": "Alternate pointer to the end address of the source data of channel 4",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH4": {
              "description": "Alternate pointer to the end address of the destination data of channel 4",
              "offset": 324,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH4": {
                    "description": "Alternate pointer to the end address of the destination data of channel 4",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH4": {
              "description": "Primary configuration for channel 4",
              "offset": 328,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH5": {
              "description": "Alternate pointer to the end address of the source data of channel 5",
              "offset": 336,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH5": {
                    "description": "Alternate pointer to the end address of the source data of channel 5",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH5": {
              "description": "Alternate pointer to the end address of the destination data of channel 5",
              "offset": 340,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH5": {
                    "description": "Alternate pointer to the end address of the destination data of channel 5",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH5": {
              "description": "Primary configuration for channel 5",
              "offset": 344,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH6": {
              "description": "Alternate pointer to the end address of the source data of channel 6",
              "offset": 352,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH6": {
                    "description": "Alternate pointer to the end address of the source data of channel 6",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH6": {
              "description": "Alternate pointer to the end address of the destination data of channel 6",
              "offset": 356,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH6": {
                    "description": "Alternate pointer to the end address of the destination data of channel 6",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH6": {
              "description": "Primary configuration for channel 6",
              "offset": 360,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH7": {
              "description": "Alternate pointer to the end address of the source data of channel 7",
              "offset": 368,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH7": {
                    "description": "Alternate pointer to the end address of the source data of channel 7",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH7": {
              "description": "Alternate pointer to the end address of the destination data of channel 7",
              "offset": 372,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH7": {
                    "description": "Alternate pointer to the end address of the destination data of channel 7",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH7": {
              "description": "Primary configuration for channel 7",
              "offset": 376,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH8": {
              "description": "Alternate pointer to the end address of the source data of channel 8",
              "offset": 384,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH8": {
                    "description": "Alternate pointer to the end address of the source data of channel 8",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH8": {
              "description": "Alternate pointer to the end address of the destination data of channel 8",
              "offset": 388,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH8": {
                    "description": "Alternate pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH8": {
              "description": "Primary configuration for channel 8",
              "offset": 392,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH9": {
              "description": "Alternate pointer to the end address of the source data of channel 9",
              "offset": 400,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH9": {
                    "description": "Alternate pointer to the end address of the source data of channel 9",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH9": {
              "description": "Alternate pointer to the end address of the destination data of channel 9",
              "offset": 404,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH9": {
                    "description": "Alternate pointer to the end address of the destination data of channel 0",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH9": {
              "description": "Primary configuration for channel 9",
              "offset": 408,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH10": {
              "description": "Alternate pointer to the end address of the source data of channel 10",
              "offset": 416,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH10": {
                    "description": "Alternate pointer to the end address of the source data of channel 10",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH10": {
              "description": "Alternate pointer to the end address of the destination data of channel 10",
              "offset": 420,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH10": {
                    "description": "Alternate pointer to the end address of the destination data of channel 10",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH10": {
              "description": "Primary configuration for channel 10",
              "offset": 424,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH11": {
              "description": "Alternate pointer to the end address of the source data of channel 11",
              "offset": 432,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH11": {
                    "description": "Alternate pointer to the end address of the source data of channel 11",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH11": {
              "description": "Alternate pointer to the end address of the destination data of channel 11",
              "offset": 436,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH11": {
                    "description": "Alternate pointer to the end address of the destination data of channel 11",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH11": {
              "description": "Primary configuration for channel 11",
              "offset": 440,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH12": {
              "description": "Alternate pointer to the end address of the source data of channel 12",
              "offset": 448,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH12": {
                    "description": "Alternate pointer to the end address of the source data of channel 12",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH12": {
              "description": "Alternate pointer to the end address of the destination data of channel 12",
              "offset": 452,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH12": {
                    "description": "Alternate pointer to the end address of the destination data of channel 12",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH12": {
              "description": "Primary configuration for channel 12",
              "offset": 456,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH13": {
              "description": "Alternate pointer to the end address of the source data of channel 13",
              "offset": 464,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH13": {
                    "description": "Alternate pointer to the end address of the source data of channel 13",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH13": {
              "description": "Alternate pointer to the end address of the destination data of channel 13",
              "offset": 468,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH13": {
                    "description": "Alternate pointer to the end address of the destination data of channel 13",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH13": {
              "description": "Primary configuration for channel 13",
              "offset": 472,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH14": {
              "description": "Alternate pointer to the end address of the source data of channel 14",
              "offset": 480,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH14": {
                    "description": "Alternate pointer to the end address of the source data of channel 14",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH14": {
              "description": "Alternate pointer to the end address of the destination data of channel 14",
              "offset": 484,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH14": {
                    "description": "Alternate pointer to the end address of the destination data of channel 14",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH14": {
              "description": "Primary configuration for channel 14",
              "offset": 488,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            },
            "ALT_SRC_DATA_END_PTR_CH15": {
              "description": "Alternate pointer to the end address of the source data of channel 15",
              "offset": 496,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_SRC_DATA_END_PTR_CH15": {
                    "description": "Alternate pointer to the end address of the source data of channel 15",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_DST_DATA_END_PTR_CH15": {
              "description": "Alternate pointer to the end address of the destination data of channel 15",
              "offset": 500,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ALT_DST_DATA_END_PTR_CH15": {
                    "description": "Alternate pointer to the end address of the destination data of channel 15",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ALT_CHN_CFG_CH15": {
              "description": "Primary configuration for channel 15",
              "offset": 504,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "cycle_ctrl": {
                    "description": "The operating mode of the DMA cycle",
                    "offset": 0,
                    "size": 3
                  },
                  "next_useburst": {
                    "description": "Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller is performing a peripheral scatter-gather and is completing a DMA cycle that uses the alternate data structure",
                    "offset": 3,
                    "size": 1
                  },
                  "n_minus_1": {
                    "description": "Prior to the DMA cycle commencing, these bits represent the total number of DMA transfers that the DMA cycle contains. You must set these bits according to the size of DMA cycle that you require.",
                    "offset": 4,
                    "size": 10
                  },
                  "R_power": {
                    "description": "Set these bits to control how many DMA transfers can occur before the controller rearbitrates",
                    "offset": 14,
                    "size": 4
                  },
                  "src_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller reads the source data",
                    "offset": 18,
                    "size": 3
                  },
                  "dst_prot_ctrl": {
                    "description": "Set the bits to control the state of HPROT[3:1] when the controller writes the destination data",
                    "offset": 21,
                    "size": 3
                  },
                  "src_size": {
                    "description": "Source data size",
                    "offset": 24,
                    "size": 2
                  },
                  "src_inc": {
                    "description": "Source address increment",
                    "offset": 26,
                    "size": 2
                  },
                  "dst_size": {
                    "description": "Destination data size",
                    "offset": 28,
                    "size": 2
                  },
                  "dst_inc": {
                    "description": "Destination address increment",
                    "offset": 30,
                    "size": 2
                  }
                }
              }
            }
          }
        }
      },
      "SDMA": {
        "description": "System Direct Access Memory",
        "children": {
          "registers": {
            "DMA_STATUS": {
              "description": "DMA Status register",
              "offset": 0,
              "size": 32,
              "reset_value": 269418496,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "master_enable": {
                    "description": "Set if controller is enabled",
                    "offset": 0,
                    "size": 1
                  },
                  "state": {
                    "description": "Current state of the control state machine.",
                    "offset": 4,
                    "size": 4,
                    "enum": "types.peripherals.SDMA.children.enums.state"
                  },
                  "chnls_minus1": {
                    "description": "Number of available DMA channels (value in register + 1)",
                    "offset": 16,
                    "size": 5
                  },
                  "test_status": {
                    "description": "To reduce the gate count you can configure the controller to exclude the integration Test logic. If value = 1, the integration Test logic is included. If 0, Test logic is not included. Any other value is undefined",
                    "offset": 28,
                    "size": 4
                  }
                }
              }
            },
            "DMA_CFG": {
              "description": "DMA configuration register",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "master_enable": {
                    "description": "Set to enable the controller",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  },
                  "chnl_prot_ctrl": {
                    "description": "Sets the AHB-Lite protection by controlling the HPROT[3:1] signal levels as follows:        \\n \\n Bit [7] Controls HPROT[3] to indicate if a cacheable access is occurring.      \\n \\n Bit [6] Controls HPROT[2] to indicate if a bufferable access is occurring.      \\n \\n Bit [5] Controls HPROT[1] to indicate if a privileged access is occurring.      \\n \\n Note\\n \\n When bit [n] = 1 then the corresponding HPROT is HIGH. \\n     \\n When bit [n] = 0 then the corresponding HPROT is LOW.",
                    "offset": 5,
                    "size": 3,
                    "access": "write-only"
                  }
                }
              }
            },
            "CTRL_BASE_PTR": {
              "description": "Control the pointer to the base address of the primary data structure",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ctrl_base_ptr": {
                    "description": "Pointer to the base address of the primary data structure",
                    "offset": 9,
                    "size": 23
                  }
                }
              }
            },
            "ALT_CTRL_BASE_PTR": {
              "description": "Base address of the alternate data structure.",
              "offset": 12,
              "size": 32,
              "reset_value": 256,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "alt_ctrl_base_ptr": {
                    "description": "Base address of the alternate data structure",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMA_WAITONREQ_STATUS": {
              "description": "Channel wait on request status",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "dma_waitonreq_status": {
                    "description": "Channel wait on request status. \\n \\n Read as: \\n \\n Bit [C] = 0 dma_waitonreq[C] is LOW. \\n \\n Bit [C] = 1 dma_waitonreq[C] is HIGH.",
                    "offset": 0,
                    "size": 16,
                    "access": "read-only"
                  }
                }
              }
            },
            "CHNL_SW_REQ": {
              "description": "Registers to generate a software DMA request in one of the 16 DMA channels",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_sw_request": {
                    "description": "Set the appropriate bit to generate a software DMA request on the corresponding DMA channel. Write as: \\n \\n Bit [C] = 0 Does not create a DMA request for channel C. \\n \\n Bit [C] = 1 Creates a DMA request for channel C. \\n \\n Writing to a bit where a DMA channel is not implemented does not create a DMA request for that channel.",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_USE_BURST_SET": {
              "description": "Returns the useburst status, or disables dma_sreq[Channel] from generating DMA requests",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_use_burst_set": {
                    "description": "Returns the useburst status, or disables dma_sreq[C] from generating DMA requests.  Read as: \\n \\n Bit [C] = 0 DMA channel C responds to requests that it receives on dma_req[C] or dma_sreq[C]. The controller performs 2R, or single, bus transfers. \\n \\n Bit [C] = 1 DMA channel C does not respond to requests that it receives on dma_sreq[C]. The controller only responds to dma_req[C] requests and performs 2R transfers. \\n \\n Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_useburst_clr Register to set bit [C] to 0. \\n \\n Bit [C] = 1 Disables dma_sreq[C] from generating DMA requests. The controller  performs 2R transfers. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "CHNL_USEBURST_SET": {
              "description": "Set the appropriate bit to enable dma_sreq[Channel] to generate requests.",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_useburst_clr": {
                    "description": "Set the appropriate bit to enable dma_sreq[] to generate requests. Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_useburst_set Register to disable dma_sreq[] from generating requests. \\n \\n Bit [C] = 1 Enables dma_sreq[C] to generate DMA requests. \\n\\n Writing to a bit where a DMA channel is not implemented has no effect",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_REQ_MASK_SET": {
              "description": "Returns the request mask status of dma_req[] and dma_sreq[], or disables the corresponding channel from generating DMA requests.",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_req_mask_set": {
                    "description": "Returns the request mask status of dma_req[C] and dma_sreq[C], or disables the corresponding channel from generating DMA requests. Read as: \\n \\n Bit [C] = 0 External requests are enabled for channel C. \\n \\n Bit [C] = 1 External requests are disabled for channel C. \\n \\n Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_req_mask_clr Register to enable DMA requests. \\n Bit [C] = 1 Disables dma_req[C] and dma_sreq[C] from generating DMA requests. \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "CHNL_REQ_MASK_CLR": {
              "description": "Set the appropriate bit to enable DMA requests for the  channel corresponding to dma_req[C] and dma_sreq[C]. ",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_req_mask_cler": {
                    "description": "Set the appropriate bit to enable DMA requests for the  channel corresponding to dma_req[C] and dma_sreq[C]. Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_req_mask_set Register to disable dma_req[C] and \\n \\n dma_sreq[C] from generating requests. \\n \\n Bit [C] = 1 Enables dma_req[C] or dma_sreq[C] to generate DMA requests. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_ENABLE_SET": {
              "description": "Returns the enable status of the channels, or enables the corresponding channels.",
              "offset": 40,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_enable_set": {
                    "description": "Returns the enable status of the channels, or enables the corresponding channels. Read as: \\n \\n Bit [C] = 0 Channel C is disabled. \\n \\n Bit [C] = 1 Channel C is enabled. \\n \\n Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_enable_clr Register to disable a channel. \\n \\n Bit [C] = 1 Enables channel C. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "CHNL_ENABLE_CLR": {
              "description": "Set the appropriate bit to disable the corresponding DMA channel.",
              "offset": 44,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_enable_clr": {
                    "description": "Set the appropriate bit to disable the corresponding DMA channel. Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_enable_set Register to enable DMA channels. \\n \\n Bit [C] = 1 Disables channel C. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_PRI_ALT_SET": {
              "description": "Returns the channel control data structure status, or selects the alternate data structure for the  corresponding DMA channel. ",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_pri_alt_set": {
                    "description": "Returns the channel control data structure status, or selects the alternate data structure for the  corresponding DMA channel. Read as: \\n \\n Bit [C] = 0 DMA channel C is using the primary data structure. \\n \\n Bit [C] = 1 DMA channel C is using the alternate data structure. \\n \\n Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_pri_alt_clr Register to set bit [C] to 0. \\n \\n Bit [C] = 1 Selects the alternate data structure for channel C. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "CHNL_PRI_ALT_CLR": {
              "description": "Set the appropriate bit to select the primary data structure for the corresponding DMA channel.",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_pri_alt_clr": {
                    "description": "Set the appropriate bit to select the primary data structure for the corresponding DMA channel. Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_pri_alt_set Register to select the alternate data structure. \\n \\n Bit [C] = 1 Selects the primary data structure for channel C. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_PRIORITY_SET": {
              "description": "Returns the channel priority mask status, or sets the channel priority to high.",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_priority_set": {
                    "description": "Returns the channel priority mask status, or sets the channel priority to high. Read as: \\n \\n Bit [C] = 0 DMA channel C is using the default priority level. \\n \\n Bit [C] = 1 DMA channel C is using a high priority level. \\n \\n Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_priority_clr Register to set channel C to the default priority level. \\n \\n Bit [C] = 1 Channel C uses the high priority level. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16,
                    "access": "write-only"
                  }
                }
              }
            },
            "CHNL_PRIORITY_CLEAR": {
              "description": "Set the appropriate bit to select the default priority level for the specified DMA channel.",
              "offset": 60,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "chnl_priority_clear": {
                    "description": "Set the appropriate bit to select the default priority level for the specified DMA channel. Write as: \\n \\n Bit [C] = 0 No effect. Use the chnl_priority_set Register to set channel C to the high priority level. \\n \\n Bit [C] = 1 Channel C uses the default priority level. \\n \\n Writing to a bit where a DMA channel is not implemented has no effect.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "ERR_CLR": {
              "description": "Returns the status of dma_err, or sets the signal LOW.",
              "offset": 76,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "err_clr": {
                    "description": "Returns the status of dma_err, or sets the signal LOW. Read as:\\n \\n 0 = dma_err is LOW \\n  \\n 1 = dma_err is HIGH. \\n \\n Write as: \\n \\n 0 = No effect, status of dma_err is unchanged. \\n \\n 1 = Sets dma_err LOW. \\n \\n For Test purposes, use the err_set register to set dma_err HIGH.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PERIPH_ID_4": {
              "description": "Peripheral identification 4",
              "offset": 4048,
              "size": 32,
              "reset_value": 4,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "periph_id_4": {
                    "description": "Peripheral identification 4",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PERIPH_ID_0": {
              "description": "Peripheral identification 0",
              "offset": 4064,
              "size": 32,
              "reset_value": 48,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "periph_id_0": {
                    "description": "Peripheral identification 0",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PERIPH_ID_1": {
              "description": "Peripheral identification 1",
              "offset": 4068,
              "size": 32,
              "reset_value": 178,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "periph_id_1": {
                    "description": "Peripheral identification 1",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PERIPH_ID_2": {
              "description": "Peripheral identification 2",
              "offset": 4072,
              "size": 32,
              "reset_value": 11,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "periph_id_2": {
                    "description": "Peripheral identification 2",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PERIPH_ID_3": {
              "description": "Peripheral identification 3",
              "offset": 4076,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "periph_id_3": {
                    "description": "Peripheral identification 3",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PCELL_ID_0": {
              "description": "PrimeCell identification 0",
              "offset": 4080,
              "size": 32,
              "reset_value": 13,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pcell_id_0": {
                    "description": "PrimeCell identification 0",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PCELL_ID_1": {
              "description": "PrimeCell identification 1",
              "offset": 4080,
              "size": 32,
              "reset_value": 240,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pcell_id_1": {
                    "description": "PrimeCell identification 1",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PCELL_ID_2": {
              "description": "PrimeCell identification 2",
              "offset": 4080,
              "size": 32,
              "reset_value": 5,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pcell_id_2": {
                    "description": "PrimeCell identification 2",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "PCELL_ID_3": {
              "description": "PrimeCell identification 3",
              "offset": 4080,
              "size": 32,
              "reset_value": 177,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "pcell_id_3": {
                    "description": "PrimeCell identification 3",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "state": {
              "size": 4,
              "children": {
                "enum_fields": {
                  "idle": {
                    "description": "idle state",
                    "value": 0
                  },
                  "read_ch_cntrl_data": {
                    "description": "reading channel controller data.",
                    "value": 1
                  },
                  "read_src_data_end_ptr": {
                    "description": "reading source data end pointer",
                    "value": 2
                  },
                  "read_dest_data_end_ptr": {
                    "description": "reading destination data end pointer",
                    "value": 3
                  },
                  "read_src_data": {
                    "description": "reading source data",
                    "value": 4
                  },
                  "write_dest_data": {
                    "description": "writing destination data",
                    "value": 5
                  },
                  "wait_dma_req_clear": {
                    "description": "waiting for DMA request to clear",
                    "value": 6
                  },
                  "write_ch_ctrl_data": {
                    "description": "writing channel controller data",
                    "value": 7
                  },
                  "stalled": {
                    "description": "stalled state",
                    "value": 8
                  },
                  "done": {
                    "description": "done state",
                    "value": 9
                  },
                  "periph_scatter_gather_trans": {
                    "description": "peripheral scatter-gather transition",
                    "value": 10
                  }
                }
              }
            }
          }
        }
      },
      "SPI": {
        "description": "SPI peripheral control",
        "children": {
          "registers": {
            "CTRLR0": {
              "description": "Control Register 0: This register controls the serial data transfer. It is impossible to write to this register when the SPI Master is enabled. The SPI Master is enabled and disabled by writing to the SSIENR register (0x008).",
              "offset": 0,
              "size": 21,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DFS": {
                    "description": "Data Frame Size. Dependencies: When SSI_HC_FRF=1, SCPH bit is a read-only bit, with its value set by SSI_DFLT_SCPH. Selects the data frame length. When the data frame size is programmed to be less than 16 bits, the receive data are automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded. You must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data. For the field decode, refer to Table 6-2.",
                    "offset": 0,
                    "size": 4,
                    "enum": "types.peripherals.SPI.children.enums.DFS"
                  },
                  "FRF": {
                    "description": "00 - Motorola SPI only",
                    "offset": 4,
                    "size": 2
                  },
                  "SCPH": {
                    "description": "Serial Clock Phase. Valid when the frame format (FRF) is set to Motorola SPI. The serial clock phase selects the relationship of the serial clock with the slave select signal. When SCPH = 0, data are captured on the first edge of the serial clock. When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock. Dependencies: When SSI_HC_FRF=1, SCPH bit is a read-only bit, with its value set by SSI_DFLT_SCPH.    ",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.SCPH"
                  },
                  "SCPOL": {
                    "description": "Serial Clock Polarity. Valid when the frame format (FRF) is set to Motorola SPI. Used to select the polarity of the inactive serial clock, which is held inactive when the SPI Master is not actively transferring data on the serial bus. Dependencies: When SSI_HC_FRF=1, SCPOL bit is a read-only bit with its value set by SSI_DFLT_SCPOL.",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.SCPOL"
                  },
                  "TMOD": {
                    "description": "Transfer Mode. Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid. In transmit-only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer. In receive-only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer. In transmit-and-receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor. In eeprom-read mode, receive data is not valid while control data is being transmitted. When all control data is sent to the EEPROM, receive data becomes valid and transmit data becomes invalid. All data in the transmit FIFO is considered control data in this mode. This transfer mode is only valid when the SPI Master is configured as a master device.",
                    "offset": 8,
                    "size": 2,
                    "enum": "types.peripherals.SPI.children.enums.TMOD"
                  },
                  "SLV_OE": {
                    "description": "No function for SPI Master. Slave usage only.",
                    "offset": 10,
                    "size": 1
                  },
                  "SRL": {
                    "description": "Shift Register Loop. Used for testing purposes only. When internally active, connects the transmit shift register output to  the receive shift register input. Can be used in both serial slave and serial-master modes. When the SPI Master is  configured as a slave in loopback mode, the ss_in_n and ssi_clk signals must be provided by an external source. In this mode, the slave cannot generate these signals because there is nothing to which to loop back.",
                    "offset": 11,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.SRL"
                  },
                  "CFS": {
                    "description": "Control Frame Size. Selects the length of the control word for the Microwire frame format. For the field decode, refer to Table 6-3 on page 101 ",
                    "offset": 12,
                    "size": 4,
                    "enum": "types.peripherals.SPI.children.enums.CFS"
                  },
                  "DFS_32": {
                    "description": "Data Frame Size in 32-bit mode. Used to select the data frame size in 32-bit mode. These bits are only valid when SSI_MAX_XFER_SIZE is configured to 32. When the data frame size is programmed to be less than 32 bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded. You are responsible for making sure the transmit data is right-justified before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data. For the field decode value, refer to Table 6-3 on page 101.",
                    "offset": 16,
                    "size": 5,
                    "access": "read-only",
                    "enum": "types.peripherals.SPI.children.enums.DFS"
                  }
                }
              }
            },
            "CTRLR1": {
              "description": "Control Register 1: CTRLR1 register controls the end of serial transfers when in receive-only mode. It is impossible to write to this register when the SPI Master is enabled. The SPI Master is enabled and disabled by writing to the SSIENR register (0x008).",
              "offset": 4,
              "size": 16,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "NDF": {
                    "description": "Number of Data Frames. When TMOD = 10 or TMOD = 11, this register field sets the number of data frames to be continuously received by the SPI Master. The SPI Master continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables you to receive up to 64 KB of data in a continuous transfer. When the SPI Master is configured as a serial slave, the transfer continues for as long as the slave is selected. Therefore, this register serves no purpose and is not present when the SPI Master is configured as a serial slave.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "SSIENR": {
              "description": "SSI Enable Register: This register enables and disables the SPI Master.  The following SPI Master registers are NOT writeable when SPI Master is enabled =1: CTRLR0, CTRLR1, BAUDR.  You must set SSIENR = 0, before writing these 3 registers. The following SPI Master registers are writeable ONLY when the SPI Master is enabled = 1: DR0. ",
              "offset": 8,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SSI_EN": {
                    "description": "SSI Enable. Enables and disables all SPI Master operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the SPI Master control registers when enabled. When disabled, the ssi_sleep output is set (after delay) to inform the system that it is safe to remove the ssi_clk, thus saving power consumption in the system.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "SER": {
              "description": "Slave Enable Register: This register enables the individual slave select output lines from the SPI Master. You cannot write to this register when SPI Master is busy.",
              "offset": 16,
              "size": 3,
              "reset_value": 0,
              "reset_mask": 0,
              "children": {
                "fields": {
                  "SER_SS1": {
                    "description": "Slave 1 Select Enable Flag. When set, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this register have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, you should enable the bit in this register. When not operating in broadcast mode, only one bit in the register should be set.",
                    "offset": 0,
                    "size": 1
                  },
                  "SER_SS2": {
                    "description": "Slave 2 Select Enable Flag. When set, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this register have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, you should enable the bit in this register. When not operating in broadcast mode, only one bit in the register should be set.",
                    "offset": 1,
                    "size": 1
                  },
                  "SER_SS3": {
                    "description": "Slave 3 Select Enable Flag. When set, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this register have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, you should enable the bit in this register. When not operating in broadcast mode, only one bit in the register should be set.",
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "BAUDR": {
              "description": "Baud Rate Select Register: This register derives the frequency of the serial clock that regulates the data transfer. It is impossible to write to this register when the SPI Master is enabled. The SPI Master is enabled and disabled by writing the SSIENR register (0x008).",
              "offset": 20,
              "size": 16,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "SCKDV_0": {
                    "description": "From description of `SCKDV_15_1`: 'The LSB for this field is always set to 0 and is unaffected by a write operation, which ensures an even value is held in this register. ' `SCKDV` is broken into `SCK_DV_15_1` and `SCK_DV_0`.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "SCKDV_15_1": {
                    "description": "SSI Clock Divider. The LSB for this field is always set to 0 and is unaffected by a write operation, which ensures an even value is held in this register. If the value is 0, the serial output clock (sclk_out) is disabled. The frequency of the sclk_out is derived from the following equation: `Fsclk_out = Fssi_clk/SCKDV` where SCKDV is any even value between 2 and 65534. For example: for `Fssi_clk = 3.6864MHz` and `SCKDV` =2, `Fsclk_out = 3.6864/2 = 1.8432MHz`",
                    "offset": 1,
                    "size": 1
                  }
                }
              }
            },
            "TXFTLR": {
              "description": "Transmit FFIFO Threshold Level Register: This register controls the threshold value for the transmit FIFO memory.",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "TFT": {
                    "description": "Transmit FIFO Threshold. Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt ssi_txe_intr`. The FIFO depth is configurable in the range 2-256; this register is sized to the number of address bits needed to access the FIFO. If you attempt to set bits [7:0] of this register to a value greater than or equal to the depth of the FIFO, this field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered. For field decode, refer to Table 6-4.",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "RXFTLR": {
              "description": "Receive FIFO Threshold Level Register: This register controls the threshold value for the receive FIFO memory.",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "RFT": {
                    "description": "Receive FIFO Threshold. Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt `ssi_rxf_intr`. The FIFO depth is configurable in the range 2-256. This register is sized to the number of address bits needed to access the FIFO. If you attempt to set this value greater than the depth of the FIFO, this field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered. For field decode, refer to Table 6-5.",
                    "offset": 0,
                    "size": 3
                  }
                }
              }
            },
            "TXFLR": {
              "description": "Transmit FIFO Level Register: This register contains the number of valid data entries in the transmit FIFO memory.",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "TXTFL": {
                    "description": "Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.",
                    "offset": 0,
                    "size": 3,
                    "access": "read-only"
                  }
                }
              }
            },
            "RXFLR": {
              "description": "Receive FIFO Level Register: This register contains the number of valid data entries in FIFO memory. This register can be read at any time.",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "RXTFL": {
                    "description": "Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.",
                    "offset": 0,
                    "size": 3,
                    "access": "read-only"
                  }
                }
              }
            },
            "SR": {
              "description": "Status Register: This is a read-only register used to indicate the current transfer status, FIFO status, and any  transmission/reception errors that may have occurred. This status register may be read at any time. None of the bits in this register request an interrupt.",
              "offset": 40,
              "size": 7,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "BUSY": {
                    "description": "SSI Busy Flag. When set, indicates that a serial transfer is in progress; when cleared indicates that the SPI Master is idle or disabled.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TFNF": {
                    "description": "Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TFE": {
                    "description": "Transmit FIFO Empty. When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RFNE": {
                    "description": "Receive FIFO Not Empty. Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RFF": {
                    "description": "Receive FIFO Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TXE": {
                    "description": "No function for SPI Master. Slave usage only.",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DCOL": {
                    "description": "Data Collision Error. Relevant only when the SPI Master is configured as a master device. This bit is set if the SPI Master is actively transmitting when another master selects this device as a slave. This informs the processor that the last data transfer was halted before completion. This bit is cleared when read.",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "IMR": {
              "description": "Interrupt Mask Register: This read/write register masks or enables all interrupts generated by the SPI Master.",
              "offset": 44,
              "size": 32,
              "reset_value": 31,
              "reset_mask": 31,
              "children": {
                "fields": {
                  "TXEIM": {
                    "description": "Transmit FIFO Empty Interrupt Mask",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  },
                  "TXOIM": {
                    "description": "Transmit FIFO Overflow Interrupt Mask",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  },
                  "RXUIM": {
                    "description": "Receive FIFO Underflow Interrupt Mask",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  },
                  "RXFOIM": {
                    "description": "Receive FIFO Overflow Interrupt Mask",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  },
                  "RXFIM": {
                    "description": "Receive FIFO Full Interrupt Mask",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  },
                  "MSTIM": {
                    "description": "Multi-Master Contention Interrupt Mask. This bit field is not present if the SPI Master is configured as a serial-slave device.",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.SPI.children.enums.TXEIM"
                  }
                }
              }
            },
            "ISR": {
              "description": "Interrupt Status Register: This register reports the status of SPI Master interrupts after they have been masked.",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TXEIS": {
                    "description": "Transmit FIFO Empty Interrupt Status",
                    "offset": 0,
                    "size": 1
                  },
                  "TXOIS": {
                    "description": "Transmit FIFO Overflow Interrupt Status",
                    "offset": 1,
                    "size": 1
                  },
                  "RXUIS": {
                    "description": "Receive FIFO Underflow Interrupt Status",
                    "offset": 2,
                    "size": 1
                  },
                  "RXOIS": {
                    "description": "Receive FIFO Overflow Interrupt Status",
                    "offset": 3,
                    "size": 1
                  },
                  "RXFIS": {
                    "description": "Receive FIFO Full Interrupt Status",
                    "offset": 4,
                    "size": 1
                  },
                  "MSTIS": {
                    "description": "Multi-Master Contention Interrupt Status. This bit field is not present if the SPI Master is configured as a serial-slave device.",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "RISR": {
              "description": "Raw Interrupt Status Register: This read-only register reports the status of the SPI Master interrupts prior to masking.",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TXEIS": {
                    "description": "Transmit FIFO Empty Raw Interrupt Status",
                    "offset": 0,
                    "size": 1
                  },
                  "TXOIS": {
                    "description": "Transmit FIFO Overflow Raw Interrupt Status",
                    "offset": 1,
                    "size": 1
                  },
                  "RXUIS": {
                    "description": "Receive FIFO Underflow Raw Interrupt Status",
                    "offset": 2,
                    "size": 1
                  },
                  "RXOIS": {
                    "description": "Receive FIFO Overflow Raw Interrupt Status",
                    "offset": 3,
                    "size": 1
                  },
                  "RXFIS": {
                    "description": "Receive FIFO Full Raw Interrupt Status",
                    "offset": 4,
                    "size": 1
                  },
                  "MSTIS": {
                    "description": "Multi-Master Contention Raw Interrupt Status. This bit field is not present if the SPI Master is configured as a serial-slave device.",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "TXOICR": {
              "description": "Transmit FIFO Overflow Interrupt Clear Register.",
              "offset": 56,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXOICR": {
                    "description": "Clear Transmit FIFO Overflow Interrupt. This register reflects the status of the interrupt. A read from this register clears the ssi_txo_intr interrupt; writing has no effect.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "RXOICR": {
              "description": "Receive FIFO Overflow Interrupt Clear Register.",
              "offset": 60,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXOICR": {
                    "description": "Clear Receive FIFO Overflow Interrupt. This register reflects the status of the interrupt. A read from this register clears the ssi_txo_intr interrupt; writing has no effect.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "RXUICR": {
              "description": "Receive FIFO Underflow Interrupt Clear Register.",
              "offset": 64,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXOICR": {
                    "description": "Clear Receive FIFO Underflow Interrupt. This register reflects the status of the interrupt. A read from this register clears the ssi_rxu_intr interrupt; writing has no effect.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "MSTICR": {
              "description": "Multi-Master Interrupt Clear Register.",
              "offset": 68,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXOICR": {
                    "description": "Clear Multi-Master Contention Interrupt. This register reflects the status of the interrupt. read from this register clears the ssi_mst_intr interrupt; writing has no effect.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "ICR": {
              "description": "Interrupt Clear Register.",
              "offset": 72,
              "size": 1,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "TXOICR": {
                    "description": "Clear Interrupts. This register is set if any of the interrupts below are active. A read clears the ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_mst_intr interrupts. Writing to this register has no effect.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "IDR": {
              "description": "Identification Code. This register contains the peripherals identification code.",
              "offset": 88,
              "size": 32,
              "reset_value": 4294967295,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "IDCODE": {
                    "description": "Identification Code. This register contains the peripherals identification code.",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "SSI_COMP_VERSION": {
              "description": "Contains the hex representation of the component version. Consists of ASCII value for each number in the version, followed by *. For example 32_30_31_2A represents the version 2.01*.",
              "offset": 92,
              "size": 32,
              "reset_value": 858927914,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SSI_COMP_VERSION": {
                    "description": "Contains the hex representation of the component version. Consists of ASCII value for each number in the version, followed by *. For example 32_30_31_2A represents the version 2.01*.",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "DR0": {
              "description": "The SPI Master data register is a 16-bit read/write buffer for the transmit/receive FIFOs. When the register is read, data in the receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN = 0. Please refer to SSIENR register (0x008) to enable and disable the SPI Master.  The DR register in the SPI Master occupies 131(for TX)/8(for RX) 32-bit address locations of the memory map to facilitate AHB burst transfers. Writing to any of these address locations has the same effect as pushing the data from the pwdata bus into the transmit FIFO. Reading from any of these locations has the same effect as popping data from the receive FIFO onto the prdata bus. The FIFO buffers on the SPI Master are not addressable.",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "DR": {
                    "description": "Data Register. When writing to this register, you must right-justify the data. Read data are automatically right-justified. Read = Receive FIFO buffer (SSI_RX_FIFO_DEPTH = 0x8) Write = Transmit FIFO buffer (SSI_TX_FIFO_DEPTH = 0x83)",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            }
          },
          "enums": {
            "DFS": {
              "size": 4,
              "children": {
                "enum_fields": {
                  "word_4bit": {
                    "description": "4 bit serial data transfer",
                    "value": 3
                  },
                  "word_5bit": {
                    "description": "5 bit serial data transfer",
                    "value": 4
                  },
                  "word_6bit": {
                    "description": "6 bit serial data transfer",
                    "value": 5
                  },
                  "word_7bit": {
                    "description": "7 bit serial data transfer",
                    "value": 6
                  },
                  "word_8bit": {
                    "description": "8 bit serial data transfer",
                    "value": 7
                  },
                  "word_9bit": {
                    "description": "9 bit serial data transfer",
                    "value": 8
                  },
                  "word_10bit": {
                    "description": "10 bit serial data transfer",
                    "value": 9
                  },
                  "word_11bit": {
                    "description": "11 bit serial data transfer",
                    "value": 10
                  },
                  "word_12bit": {
                    "description": "12 bit serial data transfer",
                    "value": 11
                  },
                  "word_13bit": {
                    "description": "13 bit serial data transfer",
                    "value": 12
                  },
                  "word_14bit": {
                    "description": "14 bit serial data transfer",
                    "value": 13
                  },
                  "word_15bit": {
                    "description": "15 bit serial data transfer",
                    "value": 14
                  },
                  "word_16bit": {
                    "description": "16 bit serial data transfer",
                    "value": 15
                  }
                }
              }
            },
            "SCPH": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "toggle_middle": {
                    "description": "Serial clock toggles in middle of first data bit",
                    "value": 0
                  },
                  "toggle_start": {
                    "description": "Serial clock toggles at start of first data bit",
                    "value": 1
                  }
                }
              }
            },
            "SCPOL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "inactive_low": {
                    "description": "Inactive state of serial clock is low",
                    "value": 0
                  },
                  "inactive_high": {
                    "description": "Inactive state of serial clock is high",
                    "value": 1
                  }
                }
              }
            },
            "TMOD": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "tx_rx": {
                    "description": "Transmit and receive",
                    "value": 0
                  },
                  "tx": {
                    "description": "Transmit only",
                    "value": 1
                  },
                  "rx": {
                    "description": "Receive only",
                    "value": 2
                  },
                  "eeprom": {
                    "description": "EEPROM read",
                    "value": 3
                  }
                }
              }
            },
            "SRL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "normal": {
                    "description": "Normal mode operation",
                    "value": 0
                  },
                  "Test": {
                    "description": "Test mode operation",
                    "value": 1
                  }
                }
              }
            },
            "CFS": {
              "size": 4,
              "children": {
                "enum_fields": {
                  "word_1bit": {
                    "description": "1 bit control word ",
                    "value": 0
                  },
                  "word_2bit": {
                    "description": "2 bit control word ",
                    "value": 1
                  },
                  "word_3bit": {
                    "description": "3 bit control word ",
                    "value": 2
                  },
                  "word_4bit": {
                    "description": "4 bit control word ",
                    "value": 3
                  },
                  "word_5bit": {
                    "description": "5 bit control word ",
                    "value": 4
                  },
                  "word_6bit": {
                    "description": "6 bit control word ",
                    "value": 5
                  },
                  "word_7bit": {
                    "description": "7 bit control word ",
                    "value": 6
                  },
                  "word_8bit": {
                    "description": "8 bit control word ",
                    "value": 7
                  },
                  "word_9bit": {
                    "description": "9 bit control word ",
                    "value": 8
                  },
                  "word_10bit": {
                    "description": "10 bit control word ",
                    "value": 9
                  },
                  "word_11bit": {
                    "description": "11 bit control word ",
                    "value": 10
                  },
                  "word_12bit": {
                    "description": "12 bit control word ",
                    "value": 11
                  },
                  "word_13bit": {
                    "description": "13 bit control word ",
                    "value": 12
                  },
                  "word_14bit": {
                    "description": "14 bit control word ",
                    "value": 13
                  },
                  "word_15bit": {
                    "description": "15 bit control word ",
                    "value": 14
                  },
                  "word_16bit": {
                    "description": "16 bit control word ",
                    "value": 15
                  }
                }
              }
            },
            "TXEIM": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "mask": {
                    "description": "Mask the interrupt",
                    "value": 0
                  },
                  "unmask": {
                    "description": "Unmask the interrupt",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "SPT": {
        "description": "Simple Periodic Timer",
        "children": {
          "registers": {
            "SPT_CFG": {
              "description": "Configuration register for the simple periodic timer",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SPT_EN": {
                    "description": "Field to enable the timer/counter",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.SPT_EN"
                  },
                  "CLK_SRC_SEL": {
                    "description": "Select the clock source",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.CLK_SRC_SEL"
                  },
                  "INT_MASK_N_0": {
                    "description": "Activate or deactive interrupt trigger signal 0",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_1": {
                    "description": "Activate or deactive interrupt trigger signal 1",
                    "offset": 3,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_2": {
                    "description": "Activate or deactive interrupt trigger signal 2",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_3": {
                    "description": "Activate or deactive interrupt trigger signal 3",
                    "offset": 5,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_4": {
                    "description": "Activate or deactive interrupt trigger signal 4",
                    "offset": 6,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_5": {
                    "description": "Activate or deactive interrupt trigger signal 5",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_6": {
                    "description": "Activate or deactive interrupt trigger signal 6",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "INT_MASK_N_7": {
                    "description": "Activate or deactive interrupt trigger signal 7",
                    "offset": 9,
                    "size": 1,
                    "enum": "types.peripherals.SPT.children.enums.INT_MASK_N_0"
                  },
                  "FFE_TO_PERIOD": {
                    "description": "FFE Kick Off (timeout) perdiod configuration (value in registers = period, max value is 100). NOTE : If 0x0, The Event Counter will be turn off and all the Signals to PMU will be de-asserted. NOTE : If PMU_TO_PERIOD is 0x0, FFE Kick off signal will not trigger until FFE is alive.",
                    "offset": 10,
                    "size": 8
                  },
                  "PMU_TO_PERIO": {
                    "description": "PMU Kick Off (Time out Period) Configuration PMU Kick Off signal will assert N cycles (value in field) before FFE kick signal asserting. NOTE : For 0x0, FFE Time out Event will be used to wake up FFE power domain.",
                    "offset": 18,
                    "size": 4
                  }
                }
              }
            },
            "SLEEP_MODE": {
              "description": "Allows blocking the PMU and FFE kickoff signal",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "SLEEP_MODE": {
                    "description": "If set, the PMU and FFE kick off signal will be blocked. This bit will be cleared by HW if any of non-Mask INT triggered",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "ERROR_CMP_40M": {
              "description": "40 msec increment error compensation register",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROR_CMP_40M": {
                    "description": "Each 40ms period contains sub-events. For each sub-event, you can add 1ms when it triggers. Theres a sub-event every odd number, with each bit of this field corresponding to that event, so: [bit 0 = 1st ms event, bit 1 = 3rd ms event ... bit 19 = 39th ms event]",
                    "offset": 0,
                    "size": 20
                  }
                }
              }
            },
            "ERROR_CMP_1S_0": {
              "description": "1 sec Increment Error Compensation 0 Register",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROR_CMP_1S_0": {
                    "description": "Each 1s period contains sub-events for every 40ms counted, and a subevent for the first ms counted. Each bit-pair in this field corresponds to one of those sub-events. Values of 0 or 2 in bit pairs do nothing. A value of 3 means the counter should decrease 1ms everytime the subevent is triggered, and a value of 1 means the counter should increment 1ms every time the event is triggered. [bits 1:0 = 1st 1ms event, bit 3:2 = 1st 40ms event ... 31:30 = 15th 40ms event]",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "ERROR_CMP_1S_1": {
              "description": "1 sec Incremente Error Compensation 1 Register",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROR_CMP_1S_1": {
                    "description": "Each 1s period contains sub-events for every 40ms counted. Each bit-pair in this field corresponds to one of those sub-events. Values of 0 or 2 in bit pairs do nothing. A value of 3 means the counter should decrease 1ms everytime the sub-event is triggered, and a value of 1 means the counter should increment 1ms every time the event is triggered. Starts from the 16th 40ms event. [bits 1:0 = 16st 40ms event, bit 3:2 = 17st 40ms event ... 17:16 = 24th 40ms event]",
                    "offset": 0,
                    "size": 18
                  }
                }
              }
            },
            "ERROR_CMP_1S_2": {
              "description": "1 sec Incremente Error Compensation 2 Register",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROR_CMP_1S_2": {
                    "description": "Each 1s period contains sub-events for every 80ms counted. Each bit-pair in this field corresponds to one of those sub-events. Values of 0 or 2 in bit pairs do nothing. A value of 3 means the counter should decrease 1ms everytime the sub-event is triggered, and a value of 1 means the counter should increment 1ms every time the event is triggered. [bits 1:0 = 1st 80ms event, bit 3:2 = 2nd 80ms event ... 23:22 = 12th 80ms event]",
                    "offset": 0,
                    "size": 24
                  }
                }
              }
            },
            "ERROR_CMP_1S_3": {
              "description": "1 sec Incremente Error Compensation 3 Register",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROR_CMP_1S_3": {
                    "description": "Each 1s period contains sub-events for every 150ms counted. Each bit-pair in this field corresponds to one of those sub-events. Values of 0 or 2 in bit pairs do nothing. A value of 3 means the counter should decrease 1ms everytime the sub-event is triggered, and a value of 1 means the counter should increment 1ms every time the event is triggered. [bits 1:0 = 1st 150ms event, bit 3:2 = 2nd 150ms event ... 11:10 = 6th 150ms event]",
                    "offset": 0,
                    "size": 12
                  }
                }
              }
            },
            "ERROR_CMP_RTC_0": {
              "description": "2, 4, 6, 8, 16 sec Increment Error Compensation Register",
              "offset": 28,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROT_CMP_RTC_0_16": {
                    "description": "Every 16s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 1:0 4002ms event, bits 3:2 4450ms event, bits 5:4 6002ms event, bits 7:6 6450ms event]",
                    "offset": 0,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_8": {
                    "description": "Every 8s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 9:8 4002ms event, bits 11:10 4450ms event, bits 13:12 6002ms event, bits 15:14 6450ms event]",
                    "offset": 8,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_4": {
                    "description": "Every 4s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 17:16 2002ms event, bits 19:18 2450ms event, bits 21:20 3002ms event, bits 23:22 3450ms event]",
                    "offset": 16,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_2": {
                    "description": "Every 2s there are 2 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 25:24 1002ms event, bits 27:26 1450ms event]",
                    "offset": 24,
                    "size": 4
                  }
                }
              }
            },
            "ERROR_CMP_RTC_1": {
              "description": "32, 64, 128, 256 sec Increment Error Compensation Register",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROT_CMP_RTC_0_256": {
                    "description": "Every 256s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 1:0 128002ms event, bits 3:2 128450ms event, bits 5:4 192002ms event, bits 7:6 192450ms event]",
                    "offset": 0,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_128": {
                    "description": "Every 128s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 9:8 64002ms event, bits 11:10 64450ms event, bits 13:12 96002ms event, bits 15:14 96450ms event]",
                    "offset": 8,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_64": {
                    "description": "Every 64s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 17:16 32002ms event, bits 19:18 32450ms event, bits 21:20 48002ms event, bits 23:22 48450ms event]",
                    "offset": 16,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_32": {
                    "description": "Every 32s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 25:24 16002ms event, bits 27:26 16450ms event, bits 29:28 24450 event, bits 31:30 24450 event]",
                    "offset": 24,
                    "size": 8
                  }
                }
              }
            },
            "ERROR_CMP_RTC_2": {
              "description": "512, 1024, 2048, 4096 sec Increment Error Compensation Register.",
              "offset": 36,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROT_CMP_RTC_0_4096": {
                    "description": "Every 4096s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 1:0 2048002ms event, bits 3:2 2048450ms event, bits 5:4 3072002ms event, bits 7:6 3072450ms event]",
                    "offset": 0,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_2_2048": {
                    "description": "Every 2048s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 9:8 1024002ms event, bits 11:10 1024450ms event, bits 13:12 1536002ms event, bits 15:14 1536450ms event]",
                    "offset": 8,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_1024": {
                    "description": "Every 1024s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 17:16 512002ms event, bits 19:18 512450ms event, bits 21:20 768002ms event, bits 23:22 768450ms event]",
                    "offset": 16,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_0_512": {
                    "description": "Every 512s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 25:24 256002ms event, bits 27:26 256450ms event, bits 29:28 384002 event, bits 31:30 384450 event]",
                    "offset": 24,
                    "size": 8
                  }
                }
              }
            },
            "ERROR_CMP_RTC_3": {
              "description": "8192, 16384 sec Increment Error Compensation Register",
              "offset": 40,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "ERROT_CMP_RTC_0_16384": {
                    "description": "Every 16384s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 1:0 8192002ms event, bits 3:2 8192450ms event, bits 5:4 12288002ms event, bits 7:6 12288450ms event]",
                    "offset": 0,
                    "size": 8
                  },
                  "ERROT_CMP_RTC_2_8192": {
                    "description": "Every 8192s there are 4 sub-events. Each bit pair in this field corresponds to those sub-events. Values of 0 and 2 do nothing. A value of 3 means the counter should decrement 1ms, and a value of 1 means the counter must add 1ms. [bits 9:8 4096002ms event, bits 11:10 4096450ms event, bits 13:12 6144002ms event, bits 15:14 6144450ms event]",
                    "offset": 8,
                    "size": 8
                  }
                }
              }
            },
            "UPDATE_TMR_VAL": {
              "description": "Update the 30-Bit Timer once write. Note: Please programmed  SPT_EN (0x000, bit 0) to 0 before write this register to avoid any potential issue",
              "offset": 44,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "UPDATE_TIMER_VALUE": {
                    "description": "Update the 30-Bit Timer once write. Note: Please programmed  SPT_EN (0x000, bit 0) to 0 before write this register to avoid any potential issue",
                    "offset": 0,
                    "size": 30
                  }
                }
              }
            },
            "SPARE_BITS": {
              "description": "Not documented",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "SPARE_BITS": {
                    "description": "Not documented",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "TIMER_VALUE": {
              "description": "Return the Value of 30-bits, in 1mS resoultion. This is the RTC  value",
              "offset": 52,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TIMER_VALUE": {
                    "description": "Return the Value of 30-bits, in 1mS resoultion. This is the RTC  value",
                    "offset": 0,
                    "size": 30,
                    "access": "read-only"
                  }
                }
              }
            },
            "EVENT_CNT_VALUE": {
              "description": "Return the Value of the Event counter generating FFE Time out event It is an upcount counter, in 1mS resoultion.",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "EVENT_CNT_VALUE": {
                    "description": "Return the Value of the Event counter generating FFE Time out event It is an upcount counter, in 1mS resoultion.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "MS_CNT_VALUE": {
              "description": "Return the Value of the 1mS counter which is generating the 1mS event. It is an downcount counter. Default is 0x40 (65-1). For 32KHz input, the resoultion is ~15uS. For 16KHz input, the resoultion is ~30uS",
              "offset": 56,
              "size": 32,
              "reset_value": 64,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MS_CNT_VALUE": {
                    "description": "Return the Value of the 1mS counter which is generating the 1mS event. It is an downcount counter. Default is 0x40 (65-1). For 32KHz input, the resoultion is ~15uS. For 16KHz input, the resoultion is ~30uS",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "SPT_EN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable": {
                    "description": "Except 30 bits Timer, all the counter will be reset to 0.",
                    "value": 0
                  },
                  "enable": {
                    "description": "Turn on Counter/Timer",
                    "value": 1
                  }
                }
              }
            },
            "CLK_SRC_SEL": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "clock_32khz": {
                    "description": "Clock source is 32KHz",
                    "value": 0
                  },
                  "clock_16khz": {
                    "description": "Clock source is 16KHz",
                    "value": 1
                  }
                }
              }
            },
            "INT_MASK_N_0": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "unmask": {
                    "description": "Unmask the interrupt",
                    "value": 0
                  },
                  "mask": {
                    "description": "Mask the interrupt",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "SPI_TLC": {
        "description": "Communication Manager - Top Level controller",
        "children": {
          "registers": {
            "CM_FIFO_0_DATA": {
              "description": "PF Bank FIFO 0 Read Port",
              "offset": 9,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DATA": {
                    "description": "PF FIFO Read Port",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "CM_FIFO_1_DATA": {
              "description": "PF Bank FIFO 1 Read Port",
              "offset": 10,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DATA": {
                    "description": "PF FIFO Read Port",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "CM_FIFO_2_DATA": {
              "description": "PF Bank FIFO 2 Read Port",
              "offset": 11,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DATA": {
                    "description": "PF FIFO Read Port",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "CM_FIFO_3_DATA": {
              "description": "PF Bank FIFO 3 Read Port",
              "offset": 12,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DATA": {
                    "description": "PF FIFO Read Port",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "MemAddrByte0": {
              "description": "Memory Address, It is representing AHB Byte Address bit [7:0]. \\n Bit 7:0 R/W, Default All 0 \\n Bit [1:0] will be ignored since only Support Word Access",
              "offset": 32,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemAddrByte0": {
                    "description": "Memory Address, It is representing AHB Byte Address bit [7:0]. \\n Bit 7:0 R/W, Default All 0 \\n Bit [1:0] will be ignored since only Support Word Access",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemAddrByte1": {
              "description": "AHB Memory Address, It is representing AHB Byte Address bit [15:8]. Bit 7:0 R/W, Default All 0 \\n Once write to this SFR, an AHB memory Read Could be Trigger. See 'TLC AHB Memory Read Trigger' worksheet for detail.",
              "offset": 33,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemAddrByte1": {
                    "description": "AHB Memory Address, It is representing AHB Byte Address bit [15:8]. Bit 7:0 R/W, Default All 0 \\n Once write to this SFR, an AHB memory Read Could be Trigger. See 'TLC AHB Memory Read Trigger' worksheet for detail.",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemAddrByte2": {
              "description": "AHB Memory Address, It is representing AHB Byte Address bit [23:16]. Bit 7:0 R/W, Default All 0",
              "offset": 34,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemAddrByte2": {
                    "description": "AHB Memory Address, It is representing AHB Byte Address bit [23:16]. Bit 7:0 R/W, Default All 0",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemAddrByte3": {
              "description": "AHB Memory Address, It is representing AHB Byte Address bit [31:24]. Bit 7:0 R/W,Default All 0",
              "offset": 35,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemAddrByte3": {
                    "description": "AHB Memory Address, It is representing AHB Byte Address bit [31:24]. Bit 7:0 R/W,Default All 0",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemDataByte0": {
              "description": "First Byte (LSB) of AHB memory data",
              "offset": 40,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemDataByte0": {
                    "description": "First Byte (LSB) of AHB memory data",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemDataByte1": {
              "description": "Second byte of AHB memory data",
              "offset": 41,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemDataByte1": {
                    "description": "Second byte of AHB memory data",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemDataByte2": {
              "description": "Third byte of AHB memory data",
              "offset": 42,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemDataByte2": {
                    "description": "Third byte of AHB memory data",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "MemDataByte3": {
              "description": "Forth byte of AHB memory data, once write to this SFR \\n 1. Trigger a AHB memory Write \\n 2. Auto Increment the AHB memory address (MemAddrByte0/MemAddrByte1) by 4 since AHB memory Address is in Byte Granunality. (offset 0x20~0x21, 64KB range)",
              "offset": 43,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "MemDataByte3": {
                    "description": "Forth byte of AHB memory data, once write to this SFR \\n 1. Trigger a AHB memory Write \\n 2. Auto Increment the AHB memory address (MemAddrByte0/MemAddrByte1) by 4 since AHB memory Address is in Byte Granunality. (offset 0x20~0x21, 64KB range)",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "AHBSTATUS": {
              "description": "AHB status register",
              "offset": 47,
              "size": 8,
              "reset_value": 8,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "NoPendingAhbReq": {
                    "description": "If set, there's pending AHB Memory Read/Write request",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AhbReadDataValid": {
                    "description": "Set if AHB Read Data is Ready. This bit is Auto Clear Once a new AHB read Access kick off and Auto Set once AHB read data is valid.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AhbReqFIFOFull": {
                    "description": "Set if AHB Address/Data/Command FIFO is Full. (Read Only)",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AhbReqFIFOhalfEmpty": {
                    "description": "Set if AHB Address/Data/Command FIFO is less than half full.",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "AhbReqFIFOSize": {
                    "description": "0 if FIFO is 4 entries, 1 if FIFO is 8 entries.",
                    "offset": 6,
                    "size": 2,
                    "access": "read-only"
                  }
                }
              }
            },
            "AHBACCESSCTL": {
              "description": "AHB access control register",
              "offset": 48,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "AhbReadReqMode": {
                    "description": "AHB Memory Read Option \\n 2'b11 : If MemAddrByte[1:0] is 2'b11, then AHB Memory Read will not be automatically triggered once MemAddrByte1 is written Other : The AHB Memory Read behavior is same as S2, Once MemAddrByte1 is  written, AHB Memory read is triggered.",
                    "offset": 0,
                    "size": 2
                  },
                  "scratch0": {
                    "description": "General Purpose Registers",
                    "offset": 2,
                    "size": 6
                  }
                }
              }
            },
            "SCRATCHBYTE": {
              "description": "General Purpose Registers, R/W, Default 0",
              "offset": 49,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "ScratchByte": {
                    "description": "General Purpose Registers, R/W, Default 0",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "TAMARSTATUS": {
              "description": "???",
              "offset": 50,
              "size": 8,
              "reset_value": 224,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "M4PowerStatus": {
                    "description": "Indicate the M4 Power Status",
                    "offset": 0,
                    "size": 2,
                    "access": "read-only",
                    "enum": "types.peripherals.SPI_TLC.children.enums.M4PowerStatus"
                  },
                  "M4ResetStatus": {
                    "description": "Indicates if the M4 Subsystem reset is released (not core reset)",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.SPI_TLC.children.enums.M4ResetStatus"
                  },
                  "M4RebootReq": {
                    "description": "This bit is reflect the value on RFUPMU offset 3EC. It will not set for cold start.",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only",
                    "enum": "types.peripherals.SPI_TLC.children.enums.M4RebootReq"
                  },
                  "PORiniCond": {
                    "description": "0xE value if POR trigger, It reflect the value of rfupmu offset 00C",
                    "offset": 4,
                    "size": 4,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMADEBUGCTL0": {
              "description": "Set bit to clear the DMA FIFO. Firmware can only set this bit to 1 after set DmaClear bit to 1 and Program this bit to 0 after clear DmaClear bit",
              "offset": 54,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DmaFifoClear": {
                    "description": "Set bit to clear the DMA FIFO. Firmware can only set this bit to 1 after set DmaClear bit to 1 and Program this bit to 0 after clear DmaClear bit",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "DMADEBUGCTL1": {
              "description": "Set bit to Reset the DMA engineer. Firmware needs to clear it before kick off the new DMA Transfer. Need to do a dummy Read on this SFR after program this bit",
              "offset": 55,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DmaClear": {
                    "description": "Set bit to Reset the DMA engineer. Firmware needs to clear it before kick off the new DMA Transfer. Need to do a dummy Read on this SFR after program this bit",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "DMAADDR0": {
              "description": "DMA Starting Address,  It is representing AHB Byte Address bit [7:0]. Bit [1:0] will be ignored since only Support Word Access",
              "offset": 56,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMAAddr0": {
                    "description": "DMA Starting Address,  It is representing AHB Byte Address bit [7:0]. Bit [1:0] will be ignored since only Support Word Access",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "DMAADDR1": {
              "description": "DMA Starting Address,  It is representing AHB Byte Address bit [15:8]. ",
              "offset": 57,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMAAddr1": {
                    "description": "DMA Starting Address,  It is representing AHB Byte Address bit [15:8]. ",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "DMAADDR2": {
              "description": "DMA Starting Address,  It is representing AHB Byte Address bit [23:16]",
              "offset": 58,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMAAddr2": {
                    "description": "DMA Starting Address,  It is representing AHB Byte Address bit [23:16]",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "DMAADDR3": {
              "description": "DMA Starting Address,  It is representing AHB Byte Address bit [31:24]",
              "offset": 59,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMAAddr3": {
                    "description": "DMA Starting Address,  It is representing AHB Byte Address bit [31:24]",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "DMABURSTSIZE0": {
              "description": "DMA transfer size indicates the number of bytes to be read out ( X ). The minimum transfer size is 4 bytes. \\n Program the value for number of bytes to read minus 4 bytes ( X -4 ), into the 2 registers. \\n DmaBurstSize0 register represents the BurstSize[7:0]. \\n DmaBurstSize1 register represents the BurstSize[15:8]. \\n Lower 2 bits are ignored by hardware, since it only supports Word Access. This means only multiples of 4 are supported. \\n For example:  \\n To read 4 bytes, you would write: \\n DmaBurstSize0 = 0, DmaBurstSize1 = 0 \\n To read 8 bytes, you would write: \\n DmaBurstSize0 = 4, DmaBurstSize1 = 0 \\n  \\n To read 256 bytes, you would write: \\n DmaBurstSize0 = FC, DmaBurstSize1 = 0 \\n To read 260 bytes, you would write: \\n DmaBurstSize0 = 0, DmaBurstSize1 = 1 \\n ... and so on, etc.",
              "offset": 60,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMABurstSize0": {
                    "description": "LSB Byte of DMA transfer size. It is representing BurstSize[7:0]",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "DMABURSTSIZE1": {
              "description": "MSB Byte of DMA transfer size. it is representing BurstSize[15:8]. Max transfer size is 64KB, Once it is written, DMA will be kickoff unless DmaBurstSize0[1:0] = 2'b10.  Min. Transfer Size will be 4 Bytes once DMA is Kick Off ({DmaBurstSize0, DmaBurstSize1} == 0x0}",
              "offset": 61,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DMABurstSize1": {
                    "description": "MSB Byte of DMA transfer size. It is representing BurstSize[15:8]",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "Reserved_dummy": {
              "description": "For dummy write purpose.",
              "offset": 62,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "dummy": {
                    "description": "For dummy write purpose",
                    "offset": 0,
                    "size": 8,
                    "access": "write-only"
                  }
                }
              }
            },
            "DMASTATUS": {
              "description": "DMA Status register",
              "offset": 63,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DmaFIFO_Empty": {
                    "description": "Set if DMA FIFO is Empty",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DmaFIFO_underflow": {
                    "description": "Set if DMA hit underflow condition",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "DMARDDATA": {
              "description": "DMA Read Data Port",
              "offset": 64,
              "size": 8,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DmaRdData": {
                    "description": "DMA Read Data Port",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "DEVICEIDBYTE": {
              "description": "Device ID, Read Only. 0x21, the Protocol of accessing this SFR is different, See Device ID read Page for detail",
              "offset": 0,
              "size": 8,
              "reset_value": 33,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "DeviceIDByte": {
                    "description": "Device ID, Read Only. 0x21, the Protocol of accessing this SFR is different, See Device ID read Page for detail",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "M4PowerStatus": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "active": {
                    "description": "Active mode.",
                    "value": 0
                  },
                  "deep_sleep": {
                    "description": "Deep Sleep mode.",
                    "value": 1
                  },
                  "shut_down": {
                    "description": "Shut down mode.",
                    "value": 2
                  },
                  "clock_off": {
                    "description": "Clock off mode.",
                    "value": 3
                  }
                }
              }
            },
            "M4ResetStatus": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "reset_released": {
                    "description": "M4 Subsystem reset is released.",
                    "value": 0
                  },
                  "reset_not_release": {
                    "description": "M4 Subsystem reset is NOT released.",
                    "value": 1
                  }
                }
              }
            },
            "M4RebootReq": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "no_reload_need": {
                    "description": "No Code reload is neccesary",
                    "value": 0
                  },
                  "reload_needed": {
                    "description": "Need to Re-Load the Code in AP mode",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "TIMER": {
        "description": "Timer peripheral",
        "children": {
          "registers": {
            "CTRL": {
              "description": "Timer control register",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 15,
              "children": {
                "fields": {
                  "ENABLE": {
                    "description": "Enable",
                    "offset": 0,
                    "size": 1
                  },
                  "SEL_EXTINT_AS_ENABLE": {
                    "description": "Select external input as enable",
                    "offset": 1,
                    "size": 1
                  },
                  "SEL_EXINT_AS_CLOCK": {
                    "description": "Select external input as clock",
                    "offset": 2,
                    "size": 1
                  },
                  "TIMER_INT_ENABLE": {
                    "description": "Timer interrupt enable",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "VALUE": {
              "description": "Current Value",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "VALUE": {
                    "description": "Current Value",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "RELOAD": {
              "description": "Reload value. A write to this register sets the current value",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RELOAD": {
                    "description": "Reload value. A write to this register sets the current value",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "INTSTATUS_INTCLEAR": {
              "description": "Timer interrupt. Write one to clear",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "INTSTATUS_INTCLEAR": {
                    "description": "Timer interrupt, Write one to clear",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "PID4": {
              "description": "Peripheral ID register 4: [7:4] Block count. [3:0] jep106_c_code.",
              "offset": 4048,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID5": {
              "description": "Peripheral ID register 5",
              "offset": 4052,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID6": {
              "description": "Peripheral ID register 6",
              "offset": 4056,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID7": {
              "description": "Peripheral ID register 7",
              "offset": 4060,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID0": {
              "description": "Peripheral ID Register 0: [7:0] Part Number[7:0].",
              "offset": 4064,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID1": {
              "description": "Peripheral ID register 1: [7:0] jep106_id_3_0. [3:0] Par number[11:8].",
              "offset": 4068,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID2": {
              "description": "Peripheral ID register 2: [7:4] Revision. [3] jedec_used. [2:0] jep106_id_6_4.",
              "offset": 4072,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "PID3": {
              "description": "Peripheral ID register 3: [7:4] ECO revision number. [3:0] Customer modification number.",
              "offset": 4076,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Peripheral ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "CID0": {
              "description": "Component ID register 0",
              "offset": 4080,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Component ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "CID1": {
              "description": "Component ID register 1",
              "offset": 4084,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Component ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "CID2": {
              "description": "Component ID register 2",
              "offset": 4088,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Component ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "CID3": {
              "description": "Component ID register 3",
              "offset": 4092,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "PID": {
                    "description": "Component ID",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            }
          }
        }
      },
      "UART": {
        "description": "Universal Asynchronous Receiver Transmitter",
        "children": {
          "registers": {
            "UART_DR": {
              "description": "Uart Data register",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DATA": {
                    "description": "Receive (read) data character. Transmit (write) data character.",
                    "offset": 0,
                    "size": 8
                  },
                  "FE": {
                    "description": "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.",
                    "offset": 8,
                    "size": 1
                  },
                  "PE": {
                    "description": "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H on page 3-12 select. In FIFO mode, this error is associated with the character at the top of the FIFO.",
                    "offset": 9,
                    "size": 1
                  },
                  "BE": {
                    "description": "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop  bits).  In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.",
                    "offset": 10,
                    "size": 1
                  },
                  "OE": {
                    "description": "Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full.  This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.",
                    "offset": 11,
                    "size": 1
                  }
                }
              }
            },
            "UART_RSR": {
              "description": "UART receive status register/error clear register. (WC)",
              "offset": 4,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FE": {
                    "description": "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO",
                    "offset": 0,
                    "size": 1
                  },
                  "PE": {
                    "description": "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H on page 3-12 select. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.",
                    "offset": 1,
                    "size": 1
                  },
                  "BE": {
                    "description": "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.",
                    "offset": 2,
                    "size": 1
                  },
                  "OE": {
                    "description": "Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.",
                    "offset": 3,
                    "size": 1
                  }
                }
              }
            },
            "UART_TFR": {
              "description": "UART Flag Register",
              "offset": 24,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "CTS": {
                    "description": "Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DSR": {
                    "description": "Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DCD": {
                    "description": "Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "BUSY": {
                    "description": "UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RXFE": {
                    "description": "Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TXFF": {
                    "description": "Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RXFF": {
                    "description": "Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TXFE": {
                    "description": "Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H on page 3-12. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RI": {
                    "description": "Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_ILPR": {
              "description": "8-bit low-power divisor value.",
              "offset": 32,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_ILPR": {
                    "description": "8-bit low-power divisor value.",
                    "offset": 0,
                    "size": 8
                  }
                }
              }
            },
            "UART_IBRD": {
              "description": "The integer baud rate divisor.",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "UART_IBRD": {
                    "description": "The integer baud rate divisor.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "UART_FBRD": {
              "description": "The fractional baud rate divisor.",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "UART_FBRD": {
                    "description": "The fractional baud rate divisor.",
                    "offset": 0,
                    "size": 6
                  }
                }
              }
            },
            "UART_LCR_H": {
              "description": "UART Line Control Register. This register accesses bit 29 to 22 of the UART Line Control Register, UARTLCR.",
              "offset": 44,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "BRK": {
                    "description": "Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.",
                    "offset": 0,
                    "size": 1
                  },
                  "PEN": {
                    "description": "Parity enable. See Table 3-11 on page 3-14 for the parity truth table.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.PEN"
                  },
                  "EPS": {
                    "description": "Even parity select. Controls the type of parity the UART uses during transmission and reception. This bit has no effect when the PEN bit disables parity checking and generation. See Table 3-11 on page 3-14 for the parity truth table.",
                    "offset": 2,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.EPS"
                  },
                  "STP2": {
                    "description": "Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.",
                    "offset": 3,
                    "size": 1
                  },
                  "FEN": {
                    "description": "Enable FIFOs:",
                    "offset": 4,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.FEN"
                  },
                  "WLEN": {
                    "description": "Word length. These bits indicate the number of data bits transmitted or received in a frame",
                    "offset": 5,
                    "size": 2,
                    "enum": "types.peripherals.UART.children.enums.WLEN"
                  },
                  "SPS": {
                    "description": "Stick parity select. This bit has no effect when the PEN bit disables parity checking and generation. See Table 3-11 on  page 3-14 for the parity truth table.",
                    "offset": 7,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.SPS"
                  }
                }
              }
            },
            "UART_CR": {
              "description": "UART Control Register",
              "offset": 48,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "UARTEN": {
                    "description": "UART enable",
                    "offset": 0,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.UARTEN"
                  },
                  "SIREN": {
                    "description": "Siren enable. This bit has no effect if the UARTEN bit disables the UART.",
                    "offset": 1,
                    "size": 1,
                    "enum": "types.peripherals.UART.children.enums.SIREN"
                  },
                  "SIRLP": {
                    "description": "SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3/16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.",
                    "offset": 2,
                    "size": 1
                  },
                  "LBE": {
                    "description": "Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR on page 4-5 is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the Test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the Test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system Test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.",
                    "offset": 7,
                    "size": 1
                  },
                  "TXE": {
                    "description": "Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.",
                    "offset": 8,
                    "size": 1
                  },
                  "RXE": {
                    "description": "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.",
                    "offset": 9,
                    "size": 1
                  },
                  "DTR": {
                    "description": "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.",
                    "offset": 10,
                    "size": 1
                  },
                  "RTS": {
                    "description": "Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.",
                    "offset": 11,
                    "size": 1
                  },
                  "Out1": {
                    "description": "This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).",
                    "offset": 12,
                    "size": 1
                  },
                  "Out2": {
                    "description": "This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).",
                    "offset": 13,
                    "size": 1
                  },
                  "RTSEn": {
                    "description": "RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.",
                    "offset": 14,
                    "size": 1
                  },
                  "CTSEn": {
                    "description": "CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.",
                    "offset": 15,
                    "size": 1
                  }
                }
              }
            },
            "UART_IFLS": {
              "description": "Interrupt FIFO Level Select Register",
              "offset": 52,
              "size": 32,
              "reset_value": 18,
              "reset_mask": 63,
              "children": {
                "fields": {
                  "TXIFLSEL": {
                    "description": "Transmit interrupt FIFO level select. The trigger points for the receive interrupt are as follows",
                    "offset": 0,
                    "size": 3,
                    "enum": "types.peripherals.UART.children.enums.TXIFLSEL"
                  },
                  "RXIFLSEL": {
                    "description": "Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows",
                    "offset": 3,
                    "size": 3,
                    "enum": "types.peripherals.UART.children.enums.TXIFLSEL"
                  }
                }
              }
            },
            "UART_IMSC": {
              "description": "Interrupt Mask Set/Clear Register",
              "offset": 56,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 2047,
              "children": {
                "fields": {
                  "RMIMIM": {
                    "description": "nUARTRI modem interrupt mask.",
                    "offset": 0,
                    "size": 1
                  },
                  "CTSMIM": {
                    "description": "nUARTCTS modem interrupt mask.",
                    "offset": 1,
                    "size": 1
                  },
                  "DCDMIM": {
                    "description": "nUARTDCD modem interrupt mask.",
                    "offset": 2,
                    "size": 1
                  },
                  "DSRMIM": {
                    "description": "nUARTDSR interrupt mask.",
                    "offset": 3,
                    "size": 1
                  },
                  "RXIM": {
                    "description": "Receive interrupt mask.",
                    "offset": 4,
                    "size": 1
                  },
                  "TXMIM": {
                    "description": "Transmit interrupt mask.",
                    "offset": 5,
                    "size": 1
                  },
                  "RTIM": {
                    "description": "Receive timeout interrupt mask.",
                    "offset": 6,
                    "size": 1
                  },
                  "FEIM": {
                    "description": "Framing error interrupt mask.",
                    "offset": 7,
                    "size": 1
                  },
                  "PEIM": {
                    "description": "Parity error interrupt mask.",
                    "offset": 8,
                    "size": 1
                  },
                  "BEIM": {
                    "description": "Break error interrupt mask.",
                    "offset": 9,
                    "size": 1
                  },
                  "OEIM": {
                    "description": "Overrun error interrupt mask.",
                    "offset": 10,
                    "size": 1
                  }
                }
              }
            },
            "UART_RIS": {
              "description": "Raw interrupt status register",
              "offset": 60,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RIRMIS": {
                    "description": "nUARTRI interrupt status (raw interrupt state) ",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "CTSRMIS": {
                    "description": "nUARTCTS interrupt status (raw interrupt state) ",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DCDRMIS": {
                    "description": "nUARTDCD interrupt status (raw interrupt state) ",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DSRRMIS": {
                    "description": "nUARTDSR interrupt status (raw interrupt state) ",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RXRMIS": {
                    "description": "Receive interrupt status (raw interrupt state) ",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TXRMIS": {
                    "description": "Transmit interrupt status (raw interrupt state) ",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RTRIS": {
                    "description": "Receive timeout interrupt status (raw interrupt state) ",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FEIS": {
                    "description": "Framing error interrupt status (raw interrupt state) ",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  },
                  "PEIS": {
                    "description": "Parity error interrupt status (raw interrupt state) ",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  },
                  "BEIS": {
                    "description": "Break error interrupt status (raw interrupt state) ",
                    "offset": 9,
                    "size": 1,
                    "access": "read-only"
                  },
                  "OERMIS": {
                    "description": "Overrun error interrupt status (raw interrupt state) ",
                    "offset": 10,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_MIS": {
              "description": "Masked interrupt status register",
              "offset": 64,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RIMMIS": {
                    "description": "nUARTRI modem masked interrupt status (masked interrupt state) ",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "CTSMMIS": {
                    "description": "nUARTCTS modem masked interrupt status (masked interrupt state) ",
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DCDMMIS": {
                    "description": "nUARTDCD modem masked interrupt status (masked interrupt state) ",
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "DSRMMIS": {
                    "description": "nUARTDSR modem masked interrupt status (masked interrupt state) ",
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RXMIS": {
                    "description": "Receive masked interrupt status (masked interrupt state) ",
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "TXMIS": {
                    "description": "Transmit masked interrupt status (masked interrupt state) ",
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "RTMIS": {
                    "description": "Receive timeout masked interrupt status (masked interrupt state) ",
                    "offset": 6,
                    "size": 1,
                    "access": "read-only"
                  },
                  "FEMIS": {
                    "description": "Framing error masked interrupt status (masked interrupt state) ",
                    "offset": 7,
                    "size": 1,
                    "access": "read-only"
                  },
                  "PEMIS": {
                    "description": "Parity error masked interrupt status (masked interrupt state) ",
                    "offset": 8,
                    "size": 1,
                    "access": "read-only"
                  },
                  "BEMIS": {
                    "description": "Break error masked interrupt status (masked interrupt state) ",
                    "offset": 9,
                    "size": 1,
                    "access": "read-only"
                  },
                  "OEMIS": {
                    "description": "Overrun error masked interrupt status (masked interrupt state) ",
                    "offset": 10,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_ICR": {
              "description": "Interrupt clear register",
              "offset": 68,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "RIMIC": {
                    "description": "nUARTRI modem interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  },
                  "CTSMIC": {
                    "description": "nUARTCTS modem interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 1,
                    "size": 1,
                    "access": "write-only"
                  },
                  "DCDMIC": {
                    "description": "nUARTDCD modem interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 2,
                    "size": 1,
                    "access": "write-only"
                  },
                  "DSRMIC": {
                    "description": "nUARTDSR modem interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 3,
                    "size": 1,
                    "access": "write-only"
                  },
                  "RXIC": {
                    "description": "Receive interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 4,
                    "size": 1,
                    "access": "write-only"
                  },
                  "TXIC": {
                    "description": "Transmit interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 5,
                    "size": 1,
                    "access": "write-only"
                  },
                  "RTIC": {
                    "description": "Receive timeout interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 6,
                    "size": 1,
                    "access": "write-only"
                  },
                  "FEIC": {
                    "description": "Framing error interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 7,
                    "size": 1,
                    "access": "write-only"
                  },
                  "PEIC": {
                    "description": "Parity error interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 8,
                    "size": 1,
                    "access": "write-only"
                  },
                  "BEIC": {
                    "description": "Break error interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 9,
                    "size": 1,
                    "access": "write-only"
                  },
                  "OEIC": {
                    "description": "Overrun error interrupt clear. Writing a 1 clears the interrupt. ",
                    "offset": 10,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "UART_TCR": {
              "description": "Test Control Register",
              "offset": 128,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 7,
              "children": {
                "fields": {
                  "ITEN": {
                    "description": "Integration Test enable.",
                    "offset": 0,
                    "size": 1,
                    "access": "write-only"
                  },
                  "TESTFINFO": {
                    "description": "Test FIFO enable.",
                    "offset": 1,
                    "size": 1,
                    "access": "write-only"
                  },
                  "SIRTEST": {
                    "description": "Siren Test enable.",
                    "offset": 2,
                    "size": 1,
                    "access": "write-only"
                  }
                }
              }
            },
            "UART_ITIP": {
              "description": "Integration Test input register",
              "offset": 132,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UARTRXD": {
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  },
                  "SIRIN": {
                    "offset": 1,
                    "size": 1,
                    "access": "read-only"
                  },
                  "nUARTDSR": {
                    "offset": 2,
                    "size": 1,
                    "access": "read-only"
                  },
                  "nUARTCTS": {
                    "offset": 3,
                    "size": 1,
                    "access": "read-only"
                  },
                  "nUARTDCD": {
                    "offset": 4,
                    "size": 1,
                    "access": "read-only"
                  },
                  "nUARTRI": {
                    "offset": 5,
                    "size": 1,
                    "access": "read-only"
                  },
                  "UARTRXDMACLR": {
                    "offset": 6,
                    "size": 1
                  },
                  "UARTTXDMACLR": {
                    "offset": 7,
                    "size": 1
                  }
                }
              }
            },
            "UART_ITOP": {
              "description": "Integration Test output register",
              "offset": 136,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 65535,
              "children": {
                "fields": {
                  "UART_ITOP": {
                    "description": "Integration Test output.",
                    "offset": 0,
                    "size": 16
                  }
                }
              }
            },
            "UART_TDR": {
              "description": "Test data register",
              "offset": 140,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 2047,
              "children": {
                "fields": {
                  "UART_TDR": {
                    "description": "Test data",
                    "offset": 0,
                    "size": 11
                  }
                }
              }
            },
            "UART_PeriphID0": {
              "description": "UART Peripheral ID 0 register",
              "offset": 4064,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 17,
              "children": {
                "fields": {
                  "UART_PeriphID0": {
                    "description": "UART Peripheral ID 0 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PeriphID1": {
              "description": "UART Peripheral ID 1 register",
              "offset": 4068,
              "size": 32,
              "reset_value": 16,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PeriphID1": {
                    "description": "UART Peripheral ID 1 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PeriphID2": {
              "description": "UART Peripheral ID 2 register",
              "offset": 4072,
              "size": 32,
              "reset_value": 52,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PeriphID2": {
                    "description": "UART Peripheral ID 2 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PeriphID3": {
              "description": "UART Peripheral ID 3 register",
              "offset": 4076,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PeriphID3": {
                    "description": "UART Peripheral ID 3 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PCellID0": {
              "description": "UART PCell ID 0 register",
              "offset": 4080,
              "size": 32,
              "reset_value": 13,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PCellID0": {
                    "description": "UART PCell ID 0 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PCellID1": {
              "description": "UART PCell ID 1 register",
              "offset": 4084,
              "size": 32,
              "reset_value": 240,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PCellID1": {
                    "description": "UART PCell ID 1 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PCellID2": {
              "description": "UART PCell ID 2 register",
              "offset": 4088,
              "size": 32,
              "reset_value": 5,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PCellID2": {
                    "description": "UART PCell ID 2 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "UART_PCellID4": {
              "description": "UART PCell ID 4 register",
              "offset": 4092,
              "size": 32,
              "reset_value": 177,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "UART_PCellID4": {
                    "description": "UART PCell ID 4 register",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "PEN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "parity_disable": {
                    "description": "parity is disabled and no parity bit added to the data frame",
                    "value": 0
                  },
                  "parity_enable": {
                    "description": "parity checking and generation is enabled.",
                    "value": 1
                  }
                }
              }
            },
            "EPS": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "odd_parity": {
                    "description": "Select odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits.",
                    "value": 0
                  },
                  "even_parity": {
                    "description": "Select even parity. The UART generates or checks for an even number of 1s in the data and parity bits.",
                    "value": 1
                  }
                }
              }
            },
            "FEN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_fifos": {
                    "description": "FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers",
                    "value": 0
                  },
                  "enable_fifos": {
                    "description": "transmit and receive FIFO buffers are enabled (FIFO mode).",
                    "value": 1
                  }
                }
              }
            },
            "WLEN": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "use_5_bit_word": {
                    "description": "Word lenght of data bits is will be configured as 5 bit",
                    "value": 0
                  },
                  "use_6_bit_word": {
                    "description": "Word lenght of data bits is will be configured as 6 bit",
                    "value": 1
                  },
                  "use_7_bit_word": {
                    "description": "Word lenght of data bits is will be configured as 7 bit",
                    "value": 2
                  },
                  "use_8_bit_word": {
                    "description": "Word lenght of data bits is will be configured as 8 bit",
                    "value": 3
                  }
                }
              }
            },
            "SPS": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "disable_stick_parity": {
                    "description": "Stick parity is disabled",
                    "value": 0
                  },
                  "enable_stick_parity": {
                    "description": "If EPS = 1 => parity bit is trasmitted and checked as a 1, If EPS = 0 => parity bit is trasmitted an checked as a 0",
                    "value": 1
                  }
                }
              }
            },
            "UARTEN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "uart_disable": {
                    "description": "UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping.",
                    "value": 0
                  },
                  "uart_enable": {
                    "description": "the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.",
                    "value": 1
                  }
                }
              }
            },
            "SIREN": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "siren_disable": {
                    "description": "IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect.",
                    "value": 0
                  },
                  "siren_enable": {
                    "description": "IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect.",
                    "value": 1
                  }
                }
              }
            },
            "TXIFLSEL": {
              "size": 3,
              "children": {
                "enum_fields": {
                  "one_eight": {
                    "description": "Trigger when corresponding FIFO becomes  1/8 full",
                    "value": 0
                  },
                  "one_quarter": {
                    "description": "Trigger when corresponding FIFO becomes  1/4 full",
                    "value": 1
                  },
                  "one_half": {
                    "description": "Trigger when corresponding FIFO becomes  1/2 full",
                    "value": 2
                  },
                  "three_quarters": {
                    "description": "Trigger when corresponding FIFO becomes  3/4 full",
                    "value": 3
                  },
                  "seven_eights": {
                    "description": "Trigger when corresponding FIFO becomes  7/8 full",
                    "value": 4
                  }
                }
              }
            }
          }
        }
      },
      "WDT": {
        "description": "WatchDog Timer",
        "children": {
          "registers": {
            "WDOGLOAD": {
              "description": "The WDOGLOAD Register contains the value from which the counter is to decrement. When this register is written to, the count is immediately restarted from the new value. The minimum valid value for WDOGLOAD is 1.",
              "offset": 0,
              "size": 32,
              "reset_value": 4294967295,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDGLOAD": {
                    "description": "Load value of the WhatchDog timer",
                    "offset": 0,
                    "size": 32
                  }
                }
              }
            },
            "WDOGVALUE": {
              "description": "The WDOGVALUE Register gives the current value of the decrementing counter.",
              "offset": 4,
              "size": 32,
              "reset_value": 4294967295,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDGVALUE": {
                    "description": "The WDOGVALUE Register gives the current value of the decrementing counter.",
                    "offset": 0,
                    "size": 32,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGCONTROL": {
              "description": "Control register for the WatchDog timer",
              "offset": 8,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 3,
              "children": {
                "fields": {
                  "INTEN": {
                    "description": "Enable the interrupt event, WDOGINT. Set HIGH to enable the counter and the interrupt, or LOW to diable the counter and interrupt. Reloads the counter from the value in WDOGLAND when the interrupt is enabled, after previously being disabled.",
                    "offset": 0,
                    "size": 1
                  },
                  "RESEN": {
                    "description": "Enable watchdog reset output, WDOGRES. Acts as a mask for the reset output. Set HIGH to enable the reset or LOW to disable the reset.",
                    "offset": 1,
                    "size": 1
                  }
                }
              }
            },
            "WDOGINTCLR": {
              "description": "A write of any value to the WDOGINTCLR Register clears the watchdog interrupt, and reloads the counter from the value in WDOGLOAD.",
              "offset": 12,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDOGINTCLR": {
                    "description": "A write of any value to the WDOGINTCLR Register clears the watchdog interrupt, and reloads the counter from the value in WDOGLOAD.",
                    "offset": 0,
                    "size": 32,
                    "access": "write-only"
                  }
                }
              }
            },
            "WDOGRIS": {
              "description": "The WDOGRIS Register indicates the raw interrupt status from the counter. This value is ANDed with the interrupt enable bit from the control register to create the masked interrupt, that is passed to the interrupt output pin. ",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDOGRIS": {
                    "description": "The WDOGRIS Register indicates the raw interrupt status from the counter. This value is ANDed with the interrupt enable bit from the control register to create the masked interrupt, that is passed to the interrupt output pin. ",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "WDOGMIS": {
              "description": "The WDOGMIS Register indicates the masked interrupt status from the counter. This value is the logical AND of the raw interrupt status with the INTEN bit from the control register, and is the same value that is passed to the interrupt output pin. Enabled interrupt status from the counter.",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDOGMIS": {
                    "description": "The WDOGMIS Register indicates the masked interrupt status from the counter. This value is the logical AND of the raw interrupt status with the INTEN bit from the control register, and is the same value that is passed to the interrupt output pin. Enabled interrupt status from the counter.",
                    "offset": 0,
                    "size": 1,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGLOCK": {
              "description": "The WDOGLOCK Register diables write accesses to all other registers. This is to prevent rogue software from diabling the watchdog functionality. Writing a value 0x1ACCE551 enables write access to all other registers. Writing any other value disables write accesses. ",
              "offset": 3072,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDOGLOCK": {
                    "description": "The WDOGLOCK Register diables write accesses to all other registers. This is to prevent rogue software from diabling the watchdog functionality. Writing a value 0x1ACCE551 enables write access to all other registers. Writing any other value disables write accesses. ",
                    "offset": 0,
                    "size": 32,
                    "enum": "types.peripherals.WDT.children.enums.WDOGLOCK"
                  }
                }
              }
            },
            "WDOGITCR": {
              "description": "The WDOGITCR Register enables integration Test mode. When in this more, the Test output register directly controls the masted interrup output, WDOGINT, and reset output, WDOGRES. Integration Test mode Enable [0] When set HIGH, places th watchdog into integration Test mode.",
              "offset": 3840,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 1,
              "children": {
                "fields": {
                  "WDOGITCR": {
                    "description": "The WDOGITCR Register enables integration Test mode. When in this more, the Test output register directly controls the masted interrup output, WDOGINT, and reset output, WDOGRES. Integration Test mode Enable [0] When set HIGH, places th watchdog into integration Test mode.",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            },
            "WDOGITOP": {
              "description": "Watchdog Integration Test Output Set Register When the WDOGITOP Register is in integration Test mode, the values in this register directly drive the enabled interrupt output and reset output.",
              "offset": 3844,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "WDOGITOP": {
                    "description": "Watchdog Integration Test Output Set Register When the WDOGITOP Register is in integration Test mode, the values in this register directly drive the enabled interrupt output and reset output.",
                    "offset": 0,
                    "size": 2,
                    "access": "write-only",
                    "enum": "types.peripherals.WDT.children.enums.WDOGITOP"
                  }
                }
              }
            },
            "WDOGPERIPHID4": {
              "description": "Peripheral ID Register 4: [7:4] Block count. [3:0] jep106_c_code.",
              "offset": 4048,
              "size": 32,
              "reset_value": 4,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID4": {
                    "description": "Peripheral ID Register 4: [7:4] Block count. [3:0] jep106_c_code.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID5": {
              "description": "Peripheral ID Register 5.",
              "offset": 4052,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID5": {
                    "description": "Peripheral ID Register 5.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID6": {
              "description": "Peripheral ID Register 6.",
              "offset": 4056,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID6": {
                    "description": "Peripheral ID Register 6.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID7": {
              "description": "Peripheral ID Register 7.",
              "offset": 4060,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID7": {
                    "description": "Peripheral ID Register 7.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID0": {
              "description": "Periperhal ID Register 0. [7:0] Part number[7:0].",
              "offset": 4064,
              "size": 32,
              "reset_value": 36,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID0": {
                    "description": "Periperhal ID Register 0. [7:0] Part number[7:0].",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID1": {
              "description": "Peripheral ID Register 1. [7:4] jep106_id_3_0. [3:0] Part number [11:8].",
              "offset": 4068,
              "size": 32,
              "reset_value": 184,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID1": {
                    "description": "Peripheral ID Register 1. [7:4] jep106_id_3_0. [3:0] Part number [11:8].",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID2": {
              "description": "Peripheral ID Register 2. [7:4] Revision. [3] jedec_used. [2:0] jep106_id_6_4.",
              "offset": 4072,
              "size": 32,
              "reset_value": 27,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID2": {
                    "description": "Peripheral ID Register 2. [7:4] Revision. [3] jedec_used. [2:0] jep106_id_6_4.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPERIPHID3": {
              "description": "Peripherial ID Register 3. [7:4] ECO revision number. [3:0] Customer modification number.",
              "offset": 4076,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPERIPHID3": {
                    "description": "Peripherial ID Register 3. [7:4] ECO revision number. [3:0] Customer modification number.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPCELLID0": {
              "description": "Component ID Register 0.",
              "offset": 4080,
              "size": 32,
              "reset_value": 13,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPCELLID0": {
                    "description": "Component ID Register 0.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPCELLID1": {
              "description": "Component ID Register 1.",
              "offset": 4084,
              "size": 32,
              "reset_value": 240,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPCELLID1": {
                    "description": "Component ID Register 1.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPCELLID2": {
              "description": "Component ID Register 2.",
              "offset": 4088,
              "size": 32,
              "reset_value": 5,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPCELLID2": {
                    "description": "Component ID Register 2.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            },
            "WDOGPCELLID3": {
              "description": "Component ID Register 3.",
              "offset": 4092,
              "size": 32,
              "reset_value": 177,
              "reset_mask": 255,
              "children": {
                "fields": {
                  "WDOGPCELLID3": {
                    "description": "Component ID Register 3.",
                    "offset": 0,
                    "size": 8,
                    "access": "read-only"
                  }
                }
              }
            }
          },
          "enums": {
            "WDOGLOCK": {
              "size": 32,
              "children": {
                "enum_fields": {
                  "locked": {
                    "description": "Write access is enabled, not locked",
                    "value": 0
                  },
                  "not_locked": {
                    "description": "Write access is disabled, locked",
                    "value": 1
                  }
                }
              }
            },
            "WDOGITOP": {
              "size": 2,
              "children": {
                "enum_fields": {
                  "wdocres": {
                    "description": "Select integration Test with WDOCRES value",
                    "value": 0
                  },
                  "wdogint": {
                    "description": "Select integration Test with WDOGINT value",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "EXTM4Regs": {
        "description": "External registers to control M4 Subsystem (not a core peripheral)",
        "children": {
          "registers": {
            "SYSTICK_REG": {
              "description": "System tick timer register",
              "offset": 0,
              "size": 32,
              "reset_value": 33554432,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "SYSTICK_TENMS": {
                    "description": "Provides an integer value to compute a 10ms (100Hz) delay. For example, apply the value 0x07A11F if no reference is implemented, and FCLK is 50MHz.",
                    "offset": 0,
                    "size": 24
                  },
                  "SYSTICK_SKEW": {
                    "description": "Systick clock is an exact multiple of 10ms",
                    "offset": 24,
                    "size": 1
                  },
                  "SYSTICK_NOREF": {
                    "description": "Indicates that no alternative reference clock source has been integrated.",
                    "offset": 25,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG1": {
              "description": "Configuration register 1",
              "offset": 16,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "CURRPRI": {
                    "description": "Indicates what priority interrupt, or base boost, is being used now. CURRPRI represents the preemption priority, and does not indicate secondary priority.",
                    "offset": 0,
                    "size": 8
                  },
                  "BRCHSTAT": {
                    "description": "Branch status",
                    "offset": 8,
                    "size": 4,
                    "enum": "types.peripherals.EXTM4Regs.children.enums.BRCHSTAT"
                  },
                  "HALTED": {
                    "description": "In halting mode debug. HALTED remains asserted while the core is in debug.",
                    "offset": 15,
                    "size": 1
                  },
                  "MEMATTRS": {
                    "description": "Memory Attributes. \\n  \\n Bit 0 = Allocate \\n \\n Bit 1 = Shareable. ",
                    "offset": 22,
                    "size": 2
                  },
                  "MEMATTRD": {
                    "description": "Memory attributes. Always 0b01 for this bus. They are always Non-shareable, Non-allocate.",
                    "offset": 24,
                    "size": 2
                  },
                  "MEMATTRI": {
                    "description": "Memory attributes. Always 0b01 for this bus. They are always Non-shareable, Non-allocate.",
                    "offset": 26,
                    "size": 2
                  },
                  "EXREQS": {
                    "description": "Exclusive Request. EXREQS is an address phase control signal that indicates if the access is because of a LDREX or STREX:\\n \\n 0 = No request \\n \\n 1 = Exclusive request \\n \\n You can use EXREQS and EXRESPS to synchronize primitives and semaphores.",
                    "offset": 30,
                    "size": 1
                  },
                  "EXREQD": {
                    "description": "Exclusive Request. EXREQD is an address phase control signal that indicates if the access is because of a LDREX or STREX: \\n \\n 0 = No request \\n \\n 1 = Exclusive request. \\n \\n You can use EXREQD and EXRESPD to synchronize primitives and semaphores.",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG2": {
              "description": "Configuration register 2",
              "offset": 20,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FPU_DISABLE": {
                    "description": "Set to disable the Floating Point Arithmetic Unit",
                    "offset": 0,
                    "size": 1
                  },
                  "MPU_DISABLE": {
                    "description": "Set to disable de Memory Protection Unit",
                    "offset": 1,
                    "size": 1
                  },
                  "DBG_DIS": {
                    "description": "Set to disable the M4 debugger",
                    "offset": 4,
                    "size": 1
                  },
                  "EDBGEQ": {
                    "description": "External debug request. Internal use only",
                    "offset": 5,
                    "size": 1
                  },
                  "DBGRESTART": {
                    "description": "Debugger restart. Internal use only",
                    "offset": 6,
                    "size": 1
                  },
                  "BIGEND": {
                    "description": "Static endianness setting. This signal is sampled at reset, and cannot be changed when reset is inactive.",
                    "offset": 8,
                    "size": 1,
                    "enum": "types.peripherals.EXTM4Regs.children.enums.BIGEND"
                  },
                  "EXRESPS": {
                    "description": "Exclusive Response. EXRESPS is a data phase response like HRESPS, but is only valid for exclusive accesses and indicates the success or failure of an exclusive operation: \\n \\n 0 = Exclusive request accepted \\n \\n 1 = Exclusive request failed. \\n \\n You can use EXREQS and EXRESPS to synchronize primitives and semaphores.",
                    "offset": 30,
                    "size": 1
                  },
                  "EXRESPD": {
                    "description": "Exclusive Response. EXRESPD is a data phase response like HRESPD, but is only valid for exclusive accesses and indicates the success or failure of an exclusive operation: \\n \\n 0 = Exclusive request accepted \\n \\n 1 = Exclusive request failed. \\n \\n You can use EXREQD and EXRESPD to synchronize primitives and semaphores.",
                    "offset": 31,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_FP1": {
              "description": "FPU configuration register 1",
              "offset": 256,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "access": "read-only",
              "children": {
                "fields": {
                  "FPIDC": {
                    "description": "Floating-point input denormal exception",
                    "offset": 0,
                    "size": 1
                  },
                  "FPIZC": {
                    "description": "Floating-point divide-by-zero exception",
                    "offset": 1,
                    "size": 1
                  },
                  "FPIOC": {
                    "description": "Floating-point invalid exception",
                    "offset": 2,
                    "size": 1
                  },
                  "FPIFC": {
                    "description": "Floating-point underflow exception",
                    "offset": 3,
                    "size": 1
                  },
                  "FPOFC": {
                    "description": "Floating-point overflow exception",
                    "offset": 4,
                    "size": 1
                  },
                  "FPIXC": {
                    "description": "Floating-point inexact exception",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_FP2": {
              "description": "FPU configuration register 2",
              "offset": 260,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FPIDZC_EN": {
                    "description": "Mask exception to cpu; Floating-point divide-by-zero exception",
                    "offset": 1,
                    "size": 1
                  },
                  "FPIOC_EN": {
                    "description": "Mask exception to cpu; Floating-point invalid operation exception",
                    "offset": 2,
                    "size": 1
                  },
                  "FPIFC_EN": {
                    "description": "Mask exception to cpu; Floating-point underflow exception",
                    "offset": 3,
                    "size": 1
                  },
                  "FPIDC_EN": {
                    "description": "Mask exception to cpu; Floating-point overflow exception",
                    "offset": 4,
                    "size": 1
                  },
                  "FPIXC_EN": {
                    "description": "Mask exception to cpu; Floating-point inexact exception",
                    "offset": 5,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_MEM1": {
              "description": "Memory configuration register 1",
              "offset": 512,
              "size": 32,
              "reset_value": 67650,
              "reset_mask": 16777215,
              "children": {
                "fields": {
                  "MEM0_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 0,
                    "size": 2
                  },
                  "MEM0_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 5,
                    "size": 2
                  },
                  "MEM1_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 10,
                    "size": 2
                  },
                  "MEM2_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 14,
                    "size": 1
                  },
                  "MEM3_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 15,
                    "size": 2
                  },
                  "MEM4_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 19,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_MEM2": {
              "description": "Memory configuration register 2",
              "offset": 516,
              "size": 32,
              "reset_value": 67650,
              "reset_mask": 16777215,
              "children": {
                "fields": {
                  "MEM0_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 0,
                    "size": 2
                  },
                  "MEM0_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 5,
                    "size": 2
                  },
                  "MEM1_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 10,
                    "size": 2
                  },
                  "MEM2_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 14,
                    "size": 1
                  },
                  "MEM3_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 15,
                    "size": 2
                  },
                  "MEM4_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 19,
                    "size": 1
                  }
                }
              }
            },
            "CONFIG_MEM3": {
              "description": "Memory configuration register 3",
              "offset": 520,
              "size": 32,
              "reset_value": 67650,
              "reset_mask": 16777215,
              "children": {
                "fields": {
                  "MEM0_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 0,
                    "size": 2
                  },
                  "MEM0_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 5,
                    "size": 2
                  },
                  "MEM1_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 10,
                    "size": 2
                  },
                  "MEM2_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 14,
                    "size": 1
                  },
                  "MEM3_32K_RM": {
                    "description": "Read and write margin control. Recommended setting is 2b10. 2b00 provides the most margin (slowest speed). 2b11 provides the least margin (fastest speed) memory. This setting is required for VDDMIN operation.",
                    "offset": 15,
                    "size": 2
                  },
                  "MEM4_32K_DST": {
                    "description": "Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clk edge. Requires margin[] to be set to 2b00. This pin is intended for debug/FA purposes only.",
                    "offset": 19,
                    "size": 1
                  }
                }
              }
            },
            "M4_MEM_INT": {
              "description": "SRAM access while in low power mode interrupt flag register (Set bit to clear)",
              "offset": 540,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "MEMO_INTR0": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 0 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 0,
                    "size": 1
                  },
                  "MEMO_INTR1": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 0 32KB_1)  while it in deep sleep or shut down mode",
                    "offset": 1,
                    "size": 1
                  },
                  "MEMO_INTR2": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 0 32KB_2)  while it in deep sleep or shut down mode",
                    "offset": 2,
                    "size": 1
                  },
                  "MEMO_INTR3": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 0 32KB_3)  while it in deep sleep or shut down mode",
                    "offset": 3,
                    "size": 1
                  },
                  "MEM1_INTR0": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 1 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_INTR1": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 1 32KB_1)  while it in deep sleep or shut down mode",
                    "offset": 5,
                    "size": 1
                  },
                  "MEM1_INTR2": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 1 32KB_2)  while it in deep sleep or shut down mode",
                    "offset": 6,
                    "size": 1
                  },
                  "MEM1_INTR3": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 1 32KB_3)  while it in deep sleep or shut down mode",
                    "offset": 7,
                    "size": 1
                  },
                  "MEM2_INTR0": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 2 32KB_0)  while it in deep sleep or shut down mode",
                    "offset": 8,
                    "size": 1
                  },
                  "MEM2_INTR1": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 2 32KB_1)  while it in deep sleep or shut down mode",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_INTR2": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 2 32KB_2)  while it in deep sleep or shut down mode",
                    "offset": 10,
                    "size": 1
                  },
                  "MEM2_INTR3": {
                    "description": "Interrupt caused by a SRAM access (M4 SRAM segment 2 32KB_3)  while it in deep sleep or shut down mode",
                    "offset": 11,
                    "size": 1
                  }
                }
              }
            },
            "M4_MEM_INTR_EN": {
              "description": "SRAM memory access while M4 in low power mode interrupts enable register",
              "offset": 544,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "MEM0_INTR0_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 0 32KB_0) ",
                    "offset": 0,
                    "size": 1
                  },
                  "MEM0_INTR1_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 0 32KB_1) ",
                    "offset": 1,
                    "size": 1
                  },
                  "MEM0_INTR2_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 0 32KB_2) ",
                    "offset": 2,
                    "size": 1
                  },
                  "MEM0_INTR3_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 0 32KB_3) ",
                    "offset": 3,
                    "size": 1
                  },
                  "MEM1_INTR0_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 1 32KB_0) ",
                    "offset": 4,
                    "size": 1
                  },
                  "MEM1_INTR1_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 1 32KB_1) ",
                    "offset": 5,
                    "size": 1
                  },
                  "MEM1_INTR2_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 1 32KB_2) ",
                    "offset": 6,
                    "size": 1
                  },
                  "MEM1_INTR3_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 1 32KB_3) ",
                    "offset": 7,
                    "size": 1
                  },
                  "MEM2_INTR0_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 2 32KB_0) ",
                    "offset": 8,
                    "size": 1
                  },
                  "MEM2_INTR1_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 2 32KB_1) ",
                    "offset": 9,
                    "size": 1
                  },
                  "MEM2_INTR2_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 2 32KB_2) ",
                    "offset": 10,
                    "size": 1
                  },
                  "MEM2_INTR3_EN": {
                    "description": "Interrupt enable (M4 SRAM segment 2 32KB_3) ",
                    "offset": 11,
                    "size": 1
                  }
                }
              }
            },
            "TO_INTR": {
              "description": "No description provided",
              "offset": 560,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TO_INTR_TMR_MON": {
                    "offset": 0,
                    "size": 1
                  },
                  "TO_INTR_UART_MON": {
                    "offset": 1,
                    "size": 1
                  },
                  "TO_INTR_AON": {
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "TO_INTR_EN": {
              "description": "No description provided",
              "offset": 564,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "TO_INTR_TMR_MON_EN": {
                    "offset": 0,
                    "size": 1
                  },
                  "TO_INTR_UART_MON_EN": {
                    "offset": 1,
                    "size": 1
                  },
                  "TO_INTR_AON_EN": {
                    "offset": 2,
                    "size": 1
                  }
                }
              }
            },
            "A1_POWER_STAT": {
              "description": "Status of the A1 subsystem power status",
              "offset": 592,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "A1_POWER_STAT": {
                    "description": "Status of the A1 subsystem power status",
                    "offset": 0,
                    "size": 2,
                    "access": "read-only"
                  }
                }
              }
            },
            "FB_RAMFIFO": {
              "description": "Sets Fabric in APB mode",
              "offset": 768,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "FB_RAMFIFO_MODE": {
                    "description": "Sets Fabric in APB mode",
                    "offset": 0,
                    "size": 1
                  }
                }
              }
            }
          },
          "enums": {
            "BRCHSTAT": {
              "size": 4,
              "children": {
                "enum_fields": {
                  "no_hint": {
                    "description": "No hint.",
                    "value": 0
                  },
                  "cond_backwards_decode": {
                    "description": "Conditional branch backwards in decode",
                    "value": 1
                  },
                  "cond_decode": {
                    "description": "Conditional branch in decode",
                    "value": 2
                  },
                  "cond_execute": {
                    "description": "Conditional branch in execute",
                    "value": 3
                  },
                  "uncond_decode": {
                    "description": "Unconditional branch in decode",
                    "value": 4
                  },
                  "uncond_execute": {
                    "description": "Unconditional branch in execute",
                    "value": 5
                  },
                  "cond_decode_taken": {
                    "description": "Conditional branch in decode taken (cycle after IHTRANS)",
                    "value": 8
                  }
                }
              }
            },
            "BIGEND": {
              "size": 1,
              "children": {
                "enum_fields": {
                  "little_endian": {
                    "description": "Select little endian as endiannes setting",
                    "value": 0
                  },
                  "big_endian": {
                    "description": "Select big endian as endiannes setting",
                    "value": 1
                  }
                }
              }
            }
          }
        }
      },
      "SCB_ACTRL": {
        "description": "System control block ACTLR",
        "children": {
          "registers": {
            "ACTRL": {
              "description": "Auxiliary control register",
              "offset": 0,
              "size": 32,
              "reset_value": 0,
              "reset_mask": 4294967295,
              "children": {
                "fields": {
                  "DISMCYCINT": {
                    "description": "DISMCYCINT",
                    "offset": 0,
                    "size": 1
                  },
                  "DISDEFWBUF": {
                    "description": "DISDEFWBUF",
                    "offset": 1,
                    "size": 1
                  },
                  "DISFOLD": {
                    "description": "DISFOLD",
                    "offset": 2,
                    "size": 1
                  },
                  "DISFPCA": {
                    "description": "DISFPCA",
                    "offset": 8,
                    "size": 1
                  },
                  "DISOOFP": {
                    "description": "DISOOFP",
                    "offset": 9,
                    "size": 1
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "devices": {
    "EOS-S3": {
      "arch": "cortex_m4",
      "description": "EOS-S3",
      "properties": {
        "cpu.endian": "selectable",
        "cpu.mpuPresent": "true",
        "cpu.revision": "r0p1",
        "cpu.name": "CM4",
        "cpu.nvicPrioBits": "3",
        "cpu.vendorSystickConfig": "false",
        "cpu.fpuPresent": "true"
      },
      "children": {
        "interrupts": {
          "Software_Interrupt_2": {
            "index": 0
          },
          "Software_Interrupt_1": {
            "index": 1
          },
          "FFE0_Message": {
            "index": 3
          },
          "Fabric_Message": {
            "index": 4
          },
          "Sensor_GPIO": {
            "index": 5,
            "description": "Global GPIO interrupt"
          },
          "UART": {
            "index": 7,
            "description": "Global UART interrupt"
          },
          "TIMER": {
            "index": 8,
            "description": "Interrupt triggered when a timer counts down to 0. The status can be read and cleared (0x4000_4830[2]), and can be masked (0x4000_4834[2] for Host), and (0x4000_4838[2] for M4)."
          },
          "CPU_WDOG_INTR": {
            "index": 9
          },
          "CPU_WDOG_RST": {
            "index": 10
          },
          "BUS_Timeout": {
            "index": 11
          },
          "FPU": {
            "index": 12
          },
          "PKFB": {
            "index": 13
          },
          "I2S": {
            "index": 14
          },
          "Audio": {
            "index": 15
          },
          "SPI_MS": {
            "index": 16
          },
          "CFG_DMA": {
            "index": 17
          },
          "PMU_TIMER": {
            "index": 18
          },
          "ADC_DONE": {
            "index": 19,
            "description": "ADC Done interrupt"
          },
          "RTC_Alarm": {
            "index": 20
          },
          "Reset_Interrupt": {
            "index": 21
          },
          "FFE0_Combined": {
            "index": 22
          },
          "FFE_WDT": {
            "index": 23
          },
          "AP_Boot": {
            "index": 24
          },
          "LDO30_PG_INTR": {
            "index": 25
          },
          "LDO50_PG_INTR": {
            "index": 26
          },
          "SRAM_128_TIMEOUT": {
            "index": 27
          },
          "LPSD_Voice_Det": {
            "index": 28
          },
          "DMIC_Voice_Det": {
            "index": 29
          },
          "SDMA_DONE_1": {
            "index": 31
          },
          "SDMA_DONE_2": {
            "index": 32
          },
          "SDMA_DONE_3": {
            "index": 33
          },
          "SDMA_DONE_4": {
            "index": 34
          },
          "SDMA_DONE_5": {
            "index": 35
          },
          "SDMA_DONE_6": {
            "index": 36
          },
          "SDMA_DONE_7": {
            "index": 37
          },
          "SDMA_DONE_8": {
            "index": 38
          },
          "SDMA_DONE_9": {
            "index": 39
          },
          "SDMA_DONE_10": {
            "index": 40
          },
          "SDMA_DONE_11": {
            "index": 41
          },
          "AP_PDM_CLK_ON": {
            "index": 42
          },
          "AP_PDM_CLK_OFF": {
            "index": 43
          },
          "DMAC0_BLK_DONE": {
            "index": 44
          },
          "DMAC0_BUF_DONE": {
            "index": 45
          },
          "DMAC1_BLK_DONE": {
            "index": 46
          },
          "DMAC1_BUF_DONE": {
            "index": 47
          },
          "SDMA_DONE_0": {
            "index": 48
          },
          "SDMA_ERR": {
            "index": 49
          },
          "I2SSLV_M4_tx_or_intr": {
            "index": 50
          },
          "LPSD_VOICE_OFF": {
            "index": 51
          },
          "DMIC_VOICE_OFF": {
            "index": 52
          },
          "NMI": {
            "index": -14
          },
          "HardFault": {
            "index": -13
          },
          "MemManageFault": {
            "index": -12
          },
          "BusFault": {
            "index": -11
          },
          "UsageFault": {
            "index": -10
          },
          "SVCall": {
            "index": -5
          },
          "PendSV": {
            "index": -2
          },
          "SysTick": {
            "index": -1
          }
        },
        "peripheral_instances": {
          "A1_Regs": {
            "description": "Selects source APB Master to SPI Master between M4/AP and Fabric",
            "offset": 1073766400,
            "type": "types.peripherals.A1_Regs"
          },
          "IOMUX": {
            "description": "IO Multiplexing Control",
            "offset": 1073761280,
            "type": "types.peripherals.IOMUX"
          },
          "ADC": {
            "description": "Analog-to-Digital Converter",
            "offset": 1073764864,
            "type": "types.peripherals.ADC"
          },
          "AIP": {
            "description": "Analog IP block",
            "offset": 1073763328,
            "type": "types.peripherals.AIP"
          },
          "AUD": {
            "description": "Audio Subsystem",
            "offset": 1073827840,
            "type": "types.peripherals.AUD"
          },
          "CFG_CTL": {
            "description": "PIF Register (FPGA Programming interface)",
            "offset": 1073823744,
            "type": "types.peripherals.CFG_CTL"
          },
          "CRU": {
            "description": "Clock Reset Unit",
            "offset": 1073758208,
            "type": "types.peripherals.CRU"
          },
          "DMA": {
            "description": "Direct Memory Access peripheral",
            "offset": 1073771520,
            "type": "types.peripherals.DMA"
          },
          "ExtRegsFFE": {
            "description": "Flexible Fusion Engine registers",
            "offset": 1074044928,
            "type": "types.peripherals.ExtRegsFFE"
          },
          "I2S_Slave": {
            "description": "I2S Slave",
            "offset": 1073786880,
            "type": "types.peripherals.I2S_Slave"
          },
          "INTR_CTRL": {
            "description": "Interrupt Controller",
            "offset": 1073760256,
            "type": "types.peripherals.INTR_CTRL"
          },
          "MISC": {
            "description": "MISC registers",
            "offset": 1073762304,
            "type": "types.peripherals.MISC"
          },
          "PKFB": {
            "description": "Packet FFO Bank control",
            "offset": 1073750016,
            "type": "types.peripherals.PKFB"
          },
          "PMU": {
            "description": "Power Management Unit",
            "offset": 1073750016,
            "type": "types.peripherals.PMU"
          },
          "SDMA_Bridge": {
            "description": "System Direct Memory Access Bridge",
            "offset": 1073795072,
            "type": "types.peripherals.SDMA_Bridge"
          },
          "SDMA_SRAM": {
            "description": "System DMA SRAM",
            "offset": 1073803264,
            "type": "types.peripherals.SDMA_SRAM"
          },
          "SDMA": {
            "description": "System Direct Access Memory",
            "offset": 1073790976,
            "type": "types.peripherals.SDMA"
          },
          "SPI": {
            "description": "SPI peripheral control",
            "offset": 1073770496,
            "type": "types.peripherals.SPI"
          },
          "SPT": {
            "description": "Simple Periodic Timer",
            "offset": 1073765376,
            "type": "types.peripherals.SPT"
          },
          "SPI_TLC": {
            "description": "Communication Manager - Top Level controller",
            "offset": 1074069504,
            "type": "types.peripherals.SPI_TLC"
          },
          "TIMER": {
            "description": "Timer peripheral",
            "offset": 1073819648,
            "type": "types.peripherals.TIMER"
          },
          "UART": {
            "description": "Universal Asynchronous Receiver Transmitter",
            "offset": 1073807360,
            "type": "types.peripherals.UART"
          },
          "WDT": {
            "description": "WatchDog Timer",
            "offset": 1073815552,
            "type": "types.peripherals.WDT"
          },
          "EXTM4Regs": {
            "description": "External registers to control M4 Subsystem (not a core peripheral)",
            "offset": 1073741824,
            "type": "types.peripherals.EXTM4Regs"
          },
          "SCB_ACTRL": {
            "description": "System control block ACTLR",
            "offset": 3758153736,
            "type": "types.peripherals.SCB_ACTRL"
          }
        }
      }
    }
  }
}